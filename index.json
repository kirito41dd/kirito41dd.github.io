[{"categories":["program"],"content":" 阴影映射之前渲染的模型中，物体明暗强弱主要通过光方向和法向量计算，并没有考虑光被遮挡的场景。 如何确认哪些部分的光被遮挡了呢？这个问题很简单，我们把摄像机朝向和平行光方向保持一致，进行一次渲染，得到的zbuffer就能表示光的视角能看到的部分，看不到的部分就是阴影！然后再进行正常的渲染。 定义一个阴影着色器： rust pub struct ShadowShader\u003c'a\u003e { model: \u0026'a obj::Obj\u003cTexturedVertex, u32\u003e, varying_tri: Mat3, // 三个顶点的屏幕坐标 view_port: Mat4, projection: Mat4, model_view: Mat4, } impl\u003c'a\u003e IShader for ShadowShader\u003c'a\u003e { fn vertex(\u0026mut self, i_face: usize, nth_vert: usize) -\u003e glm::Vec4 { let i_vert = self.model.indices[i_face * 3 + nth_vert]; let vert = self.model.vertices[i_vert as usize]; let v = Vec3::from_array(\u0026vert.position); // 顶点位置 let gl_v = self.view_port * self.projection * self.model_view * v.extend(1.); self.varying_tri.as_array_mut()[nth_vert] = v4p2v3(gl_v); gl_v } fn fragment(\u0026mut self, bar: glm::Vec3, color: \u0026mut image::Rgba\u003cu8\u003e) -\u003e bool { let p = self.varying_tri * bar; // 当前像素的插值位置 let depth = 2000.; let r = (255. * p.z / depth) as u8; let g = (255. * p.z / depth) as u8; let b = (255. * p.z / depth) as u8; *color = image::Rgba([r, g, b, 255]); // 设置当前像素颜色为阴影颜色,深度越小颜色越潜 return false; // 不丢弃任何像素 } } 这个作色器会根据视线方向，将深度信息转换为颜色，深度越大(离摄像机越近)颜色越深 然后尝试渲染出图片，这次用暗黑三模型： rust let light_dir = glm::normalize(glm::vec3(1., 1., 0.)); let input = BufReader::new(File::open(\"obj/diablo3/diablo3_pose.obj\").unwrap()); let model_view_light = lookat(light_dir, center, up); // 光照方向作为摄像机方向 let projection = glm::Mat4::one(); // 使用正交投影，因为是平行光 let mut shader = ShadowShader::new(\u0026model, model_view_light, projection, view_port); // 正常用着色器渲染 for i in 0..model.indices.len() / 3 { let mut clip_coords: [glm::Vec4; 3] = [glm::Vec4::zero(); 3]; for j in 0..3 { clip_coords[j] = shader.vertex(i, j); } triangle_with_shader( clip_coords[0], clip_coords[1], clip_coords[2], \u0026mut shader, \u0026mut image, \u0026mut zbuffer, ); } 得到结果如下： 完整代码: 3dc57eb84b1f48e8b0a40c429a712bcb604d8f00 现在得到了光的视角的zbuffer，我们叫他shadow buffer。接下来渲染模型： 需要进行两次渲染，第一次使用ShadowShader来获得shadow buffer，第二步渲染模型时，着色器会参考第一次渲染的shadow buffer。这是新的着色器：它是由上一篇中的PhongShader扩展来的，加入了计算阴影的逻辑。 rust pub struct PhongShaderWithShadow\u003c'a\u003e { model: \u0026'a obj::Obj\u003cTexturedVertex, u32\u003e, diffuse: \u0026'a ImageBuffer\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e, diffuse_nm: \u0026'a ImageBuffer\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e, // 法线贴图 diffuse_spec: \u0026'a ImageBuffer\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e, // 高光贴图 shadow_buffer: \u0026'a Vec\u003cf32\u003e, // 阴影缓冲区 varying_uv: glm::Mat3, // 三个顶点的纹理坐标 varying_tri: glm::Mat3, // 三个顶点的屏幕坐标 uniform_m: Mat4, // 模型的变换矩阵m projection*model_view ,不带view_port,不用到屏幕坐标 uniform_mv_it: Mat4, // uniform_m的逆转置矩阵 m.inverse().transpose() uniform_m_shadow: Mat4, // 用来将frame buffer中的屏幕坐标，转换为shadow buffer中的屏幕坐标 light_dir: Vec3, view_port: Mat4, projection: Mat4, model_view: Mat4, width: u32, // 画布宽度 } impl\u003c'a\u003e IShader for PhongShaderWithShadow\u003c'a\u003e { fn vertex(\u0026mut self, i_face: usize, nth_vert: usize) -\u003e glm::Vec4 { let i_vert = self.model.indices[i_face * 3 + nth_vert]; let vert = self.model.vertices[i_vert as usize]; let v = Vec3::from_array(\u0026vert.position); // 顶点位置 let uv = Vec3::from_array(\u0026vert.texture); // 纹理坐标 self.varying_uv.as_array_mut()[nth_vert] = uv.clone(); // 每一列是一个顶点处的纹理坐标 let gl_v = self.view_port * self.projection * self.model_view * v.extend(1.); // 直接到屏幕坐标 self.varying_tri.as_array_mut()[nth_vert] = v4p2v3(gl_v); gl_v } fn fragment(\u0026mut self, bar: glm::Vec3, color: \u0026mut image::Rgba\u003cu8\u003e) -\u003e bool { // 把当前fragment的屏幕坐标转换到shadow buffer的屏幕坐标 let sb_p = self.uniform_m_shadow * (self.varying_tri * bar).extend(1.); let sb_p = v4p2v3(sb_p); let idx = sb_p.x as u32 + (sb_p.y as u32 * self.width); // shadow buffer的下标 // 当前点的阴影深度大于深度缓冲时，说明没有被遮挡光线 let shadow = 0.3 + 0.7 * (if self.shadow_buffer[idx as usize] \u003c= sb_p.z { 1. } else { 0. }); // ... let mut n = Vec3::from_array(\u0026[nm_px[0] as _, nm_px[1] as _, nm_px[2] as _]).clone(); // 从贴图中加载法向量 n.as_array_mut() .iter_mut() .for_each(|v| *v = *v / 255. * 2. - 1.); // tga图像中[0,255], 转换到[-1,-1] //println!(\"normal: {:?}\", n); let n = self.uniform_mv_it * n.extend(0.); // 法线映射 注意向量转换位齐次坐标是填0 let n = glm::normalize(vec4_to_3(n)); // 齐次坐标投影回3d 注意向量不需要除w分量 let l = self.uniform_m * self.ligh","date":"2025-07-24","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B05%E9%98%B4%E5%BD%B1%E5%92%8C%E7%9F%AB%E6%AD%A3%E9%80%8F%E8%A7%86%E5%8F%98%E5%BD%A2-%E5%AE%8C%E7%BB%93/:1:0","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记5：阴影和矫正透视变形 - 完结","uri":"/tinyrenderer%E7%AC%94%E8%AE%B05%E9%98%B4%E5%BD%B1%E5%92%8C%E7%9F%AB%E6%AD%A3%E9%80%8F%E8%A7%86%E5%8F%98%E5%BD%A2-%E5%AE%8C%E7%BB%93/#阴影映射"},{"categories":["program"],"content":" 透视变形观察下面两张图，会发现使用屏幕空间重心坐标对纹理插值会有问题： 使用屏幕空间重心坐标 使用裁剪空间重心坐标 问题的原因主要是变换链的非线性。为了从齐次坐标转换为3d坐标(屏幕空间)，我们除以了w分量，打破了变换的线性。因此，我们没有权利使用屏幕空间重心坐标来插值原始空间中的任何东西。 下面推导如何计算裁剪空间中的重心坐标： 属于三角形$ABC$的某个点$P$经过透视除法后变换为点$P’$ ，注意$rz+1$就是裁剪空间$w$分量 $$ P = \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} \\rightarrow P' = \\frac{1}{rz+1} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} $$ 我们知道$P’$相对于三角形$A’B’C’$的重心坐标（三角形的屏幕空间坐标），这里$\\alpha’\\ \\beta’ \\ \\gamma’$就是屏幕空间重心坐标$bc_screen$ $$ P' = \\begin{bmatrix} A' \u0026 B' \u0026 C' \\end{bmatrix} \\begin{bmatrix} \\alpha' \\\\ \\beta' \\\\ \\gamma' \\end{bmatrix} $$ 我们需要找到$P$关于裁剪空间三角形$ABC$的重心坐标 $$ P = \\begin{bmatrix} A \u0026 B \u0026 C \\end{bmatrix} \\begin{bmatrix} \\alpha \\\\ \\beta \\\\ \\gamma \\end{bmatrix} $$ 重新来表示$P’$，第二个等号表示$P’$可以由$P$进行透视除法得到，第三个等号代换$A’$通过$A$进行透视除法得到 $$ P' = \\begin{bmatrix} A' \u0026 B' \u0026 C' \\end{bmatrix} \\begin{bmatrix} \\alpha' \\\\ \\beta' \\\\ \\gamma' \\end{bmatrix} =P\\frac{1}{rP.z+1} = \\begin{bmatrix} A\\frac{1}{rA.z+1} \u0026 B\\frac{1}{rB.z+1} \u0026 C\\frac{1}{rC.z+1} \\end{bmatrix} \\begin{bmatrix} \\alpha' \\\\ \\beta' \\\\ \\gamma' \\end{bmatrix} $$ 后面的等式，两边同时乘以$rP.z+1$ $$ P = \\begin{bmatrix} A \u0026 B \u0026 C \\end{bmatrix} \\begin{bmatrix} \\alpha' / (rA.z+1) \\\\ \\beta' / (rB.z+1) \\\\ \\gamma' / (rC.z+1) \\end{bmatrix} (rP.z+1) $$ 这个等式后面的部分就是裁剪空间的重心坐标。点P可以由三个顶点乘以重心坐标得到。 如果需要求裁剪空间的重心坐标，我们看下公式，其中只有$rP.z+1$是未知的的，点$P$的$w$分量 我们求重心坐标是为了求点$P$，现在却需要$P.w$，陷入了循环。 我们需要跳出这个循环，在(归一化的)重心坐标中，所有分量的和等于1，也就是$alpha + beta+gamma=1$ $$ \\left( \\frac{\\alpha'}{rA.z+1} + \\frac{\\beta'}{rB.z+1} +\\frac{\\gamma'}{rC.z+1} \\right) (rP.z+1)=1 $$ 在代码中计算裁剪空间重心坐标$bc_clip$ rust // 屏幕空间中的重心坐标，透视除法后 let bc_screen = barycentric(a, b, c, glm::vec3(px as f32, py as f32, 0.)); // 裁剪空间中的中心坐标 let bc_clip = glm::vec3( bc_screen.x / a_4d.w, bc_screen.y / b_4d.w, bc_screen.z / c_4d.w, ); let bc_clip = bc_clip / (bc_clip.x + bc_clip.y + bc_clip.z); 第一步屏幕重心坐标每个分量分别除以$ABC$的$w$分量 第二步是乘$rP.z+1$也就是除以(bc_clip.x + bc_clip.y + bc_clip.z) 这就是裁剪空间重心坐标: $$ \\begin{bmatrix} \\alpha' / (rA.z+1) \\\\ \\beta' / (rB.z+1) \\\\ \\gamma' / (rC.z+1) \\end{bmatrix} / \\left( \\frac{\\alpha'}{rA.z+1} + \\frac{\\beta'}{rB.z+1} +\\frac{\\gamma'}{rC.z+1} \\right) $$ 计算深度信息和片段着色器插值时都传入裁剪空间重心坐标即可 rust // 计算深度也使用裁剪空间的重心坐标插值 let frag_depth = glm::dot(glm::vec3(a_4d.z, b_4d.z, c_4d.z), bc_clip); let idx = px + py * image.width() as i32; if bc_screen.x \u003c 0. || bc_screen.y \u003c 0. || bc_screen.z \u003c 0. || zbuffer[idx as usize] \u003e frag_depth { continue; } let mut color = image::Rgba([0; 4]); let discard = shader.fragment(bc_clip, \u0026mut color); if !discard { zbuffer[idx as usize] = frag_depth; image.put_pixel(px as u32, py as u32, color); } 完整代码: e7ff99171d03a4477f0947513e64f9d0560b22ef ","date":"2025-07-24","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B05%E9%98%B4%E5%BD%B1%E5%92%8C%E7%9F%AB%E6%AD%A3%E9%80%8F%E8%A7%86%E5%8F%98%E5%BD%A2-%E5%AE%8C%E7%BB%93/:2:0","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记5：阴影和矫正透视变形 - 完结","uri":"/tinyrenderer%E7%AC%94%E8%AE%B05%E9%98%B4%E5%BD%B1%E5%92%8C%E7%9F%AB%E6%AD%A3%E9%80%8F%E8%A7%86%E5%8F%98%E5%BD%A2-%E5%AE%8C%E7%BB%93/#透视变形"},{"categories":["program"],"content":" 完结撒花一些注意点： 前面提到的正交投影矩阵(单位矩阵)和透视投影矩阵都是为了突出原理的简化版本，实际的投影矩阵更为复杂 关于切空间法线贴图的内容只是提了一下，详细内容还是看原文 tangent-space-normal-mapping 阴影映射时的z-fighting是个很复杂的问题，可以单开好多内容，有兴趣可以自己搜一下。 一些感悟： 重心坐标很美妙 线性代数很美妙 从2022年1月开始到2025年7月，花了两年多才学完，是真的懒得没边了~ 接下来可能会去玩一下wgpu，也是rust。 ","date":"2025-07-24","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B05%E9%98%B4%E5%BD%B1%E5%92%8C%E7%9F%AB%E6%AD%A3%E9%80%8F%E8%A7%86%E5%8F%98%E5%BD%A2-%E5%AE%8C%E7%BB%93/:3:0","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记5：阴影和矫正透视变形 - 完结","uri":"/tinyrenderer%E7%AC%94%E8%AE%B05%E9%98%B4%E5%BD%B1%E5%92%8C%E7%9F%AB%E6%AD%A3%E9%80%8F%E8%A7%86%E5%8F%98%E5%BD%A2-%E5%AE%8C%E7%BB%93/#完结撒花"},{"categories":["program"],"content":" 顶点着色器和片段着色器OpenGL 2的渲染管道可以表示如下(新版本也差不多)： 在较新的OpenGL中还有其他着色器，在这个课程中只关心顶点着色器(vertex shader)和片段着色器(fragment shader)。 在上面图片中，我们无法触摸的阶段都用蓝色表示，我们的回调用橙色表示。 事实上现在的main()函数是原始的处理程序(primitive processing routine)，它可以叫做顶点着色器。我们在这里没有primitive assembly的步骤，由于我们仅绘制三角形在我们的代码中，它与primitive processing合并。现在的triangle()函数是是rasterizer，对于在三角形中的每个像素都调用了了片段着色器的功能，然后执行深度检查之类的。 知道了什么是着色器就可以开始创建着色器了。 顶点着色器的主要目标是变换顶点的坐标，第二个目标是为片段着色器准备数据。 片段着色器的主要目标是确定当前像素的颜色，次要目标是我们可以通过返回true丢弃当前像素。 着色器的定义： rust pub trait IShader { /// 顶点着色器 /// iface 第i个面, nth_vert 面的第n个顶点 /// 返回顶点在裁剪空间的坐标(齐次坐标) fn vertex(\u0026mut self, i_face: usize, nth_vert: usize) -\u003e glm::Vec4; /// 片段着色器 /// bar 当前像素在三角形中的重心坐标 color 像素颜色 /// 返回true表示丢弃当前像素 fn fragment(\u0026mut self, bar: Vec3, color: \u0026mut image::Rgba\u003cu8\u003e) -\u003e bool; } ","date":"2025-01-06","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/:1:0","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记4：着色器","uri":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/#顶点着色器和片段着色器"},{"categories":["program"],"content":" 实现一个着色器实现一个简单的Gouraud着色器： rust pub struct GouraudShader\u003c'a\u003e { model: \u0026'a obj::Obj\u003cTexturedVertex, u32\u003e, varying_intensity: glm::Vec3, // 强度变化，由顶点着色器写入，由片段着色器读取 view_port: Mat4, projection: Mat4, model_view: Mat4, light_dir: Vec3, } impl\u003c'a\u003e GouraudShader\u003c'a\u003e { pub fn new( model: \u0026'a obj::Obj\u003cTexturedVertex, u32\u003e, model_view: Mat4, projection: Mat4, view_port: Mat4, light_dir: Vec3, )// 实现省略; } impl\u003c'a\u003e IShader for GouraudShader\u003c'a\u003e { fn vertex(\u0026mut self, i_face: usize, nth_vert: usize) -\u003e glm::Vec4 { let i_vert = self.model.indices[i_face * 3 + nth_vert]; let vert = self.model.vertices[i_vert as usize]; let normal = Vec3::from_array(\u0026vert.normal); let v = Vec3::from_array(\u0026vert.position); let gl_v = self.view_port * self.projection * self.model_view * v.extend(1.); self.varying_intensity[nth_vert] = glm::dot(*normal, self.light_dir).max(0.); // 计算每个顶点的光照强度 gl_v } fn fragment(\u0026mut self, bar: glm::Vec3, color: \u0026mut image::Rgba\u003cu8\u003e) -\u003e bool { let intensity = glm::dot(self.varying_intensity, bar); // 当前像素的插值强度，重心坐标计算相对三个顶点的强度 let x = (255. * intensity) as u8; *color = image::Rgba([x, x, x, 255]); return false; // 不丢弃任何像素 } } 使用这个着色器，重新实现main函数绘制模型： rust fn main() { let eye = glm::vec3(0., -1., 3.); // camera let center = glm::vec3(0., 0., 0.); let up = glm::vec3(0., 1., 0.); let light_dir = glm::normalize(glm::vec3(1., 1., 1.)); let (width, height) = (800, 800); let mut image = ImageBuffer::\u003cRgba\u003cu8\u003e, _\u003e::from_pixel(width, height, BLACK); let mut zbuffer = ImageBuffer::\u003cLuma\u003cu8\u003e, _\u003e::from_pixel(width, height, Luma([0])); let model = obj::load_obj::\u003cobj::TexturedVertex, _, u32\u003e(input).unwrap(); let model_view = lookat(eye, center, up); #[rustfmt::skip] let projection = glm::mat4( 1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., -1./ glm::distance(eye, center), 0., 0., 0., 1.); let view_port = viewport( width as i32 / 8, height as i32 / 8, width as i32 * 3 / 4, height as i32 * 3 / 4, ); // 创建着色器 let mut shader = GouraudShader::new(\u0026model, model_view, projection, view_port, light_dir); // 遍历每个面 for i in 0..model.indices.len() / 3 { let mut screen_coords: [glm::Vec4; 3] = [glm::Vec4::zero(); 3]; // 遍历每个面的每个顶点 for j in 0..3 { screen_coords[j] = shader.vertex(i, j); } triangle_with_shader( screen_coords[0], screen_coords[1], screen_coords[2], \u0026mut shader, \u0026mut image, \u0026mut zbuffer, ); } flip_vertical_in_place(\u0026mut image); image.save(\"a.png\").unwrap(); flip_vertical_in_place(\u0026mut zbuffer); zbuffer.save(\"b.png\").unwrap(); } 在遍历每个顶点时，调用顶点着色器，在对三角行进行栅格化的时候会调用片段着色器： rust /// 注意现在输入的顶点坐标是齐次坐标 pub fn triangle_with_shader\u003c I: GenericImage\u003cPixel = Rgba\u003cu8\u003e\u003e, I2: GenericImage\u003cPixel = Luma\u003cu8\u003e\u003e, S: IShader, \u003e( a_4d: glm::Vec4, b_4d: glm::Vec4, c_4d: glm::Vec4, shader: \u0026mut S, image: \u0026mut I, zbuffer: \u0026mut I2, ) { let a = v4p2v3(a_4d); // a b c是齐次坐标投影到屏幕上的坐标 let b = v4p2v3(b_4d); let c = v4p2v3(c_4d); // 确定枚举像素的边界 let bboxmin = glm::vec2(a.x.min(b.x).min(c.x).max(0.), a.y.min(b.y).min(c.y).max(0.)); let bboxmax = glm::vec2( a.x.max(b.x).max(c.x).min(image.width() as f32 - 1.), a.y.max(b.y).max(c.y).min(image.height() as f32 - 1.), ); for px in bboxmin.x as i32..=bboxmax.x as i32 { for py in bboxmin.y as i32..=bboxmax.y as i32 { let bc_screen = barycentric(a, b, c, glm::vec3(px as f32, py as f32, 0.)); // 留意下这里，z和w都使用齐次坐标算的 let z = glm::dot(glm::vec3(a_4d.z, b_4d.z, c_4d.z), bc_screen); let w = glm::dot(glm::vec3(a_4d.w, b_4d.w, c_4d.w), bc_screen); let frag_depth = (z / w + 0.5) as u8; let frag_depth = frag_depth.min(255).max(0); if bc_screen.x \u003c 0. || bc_screen.y \u003c 0. || bc_screen.z \u003c 0. { continue; } let mut color = image::Rgba([0; 4]); let discard = shader.fragment(bc_screen, \u0026mut color); let idx = px + py * image.width() as i32; let zb: \u0026mut Luma\u003cu8\u003e = zbuffer.get_pixel_mut(px as _, py as _); if zb.0[0] \u003c= frag_depth { zb.0[0] = frag_depth; if !discard { image.put_pixel(px as u32, py as u32, color); } } } } } 最终画出来的图片如下，一个模型，一个zbuffer的灰度图： a.png b.png 这里是完整代码: 11e8d2cbfc251d694bb65ae40ec463b54636b0c0 ","date":"2025-01-06","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/:2:0","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记4：着色器","uri":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/#实现一个着色器"},{"categories":["program"],"content":" 修改片段着色器令强度仅具有6个值： rust let eye = glm::vec3(1., 1., 3.); // camera let center = glm::vec3(0., 0., 0.); let up = glm::vec3(0., 1., 0.); let light_dir = glm::normalize(glm::vec3(1., 1., 0.9)); fn fragment(\u0026mut self, bar: glm::Vec3, color: \u0026mut image::Rgba\u003cu8\u003e) -\u003e bool { let mut intensity = glm::dot(self.varying_intensity, bar); intensity = if intensity \u003e 0.85 { 1. } else if intensity \u003e 0.6 { 0.8 } else if intensity \u003e 0.45 { 0.6 } else if intensity \u003e 0.3 { 0.45 } else if intensity \u003e 0.15 { 0.3 } else { 0. }; *color = image::Rgba([(255. * intensity) as u8, (155. * intensity) as u8, 0, 255]); return false; } 查看变化 ","date":"2025-01-06","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/:2:1","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记4：着色器","uri":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/#修改片段着色器"},{"categories":["program"],"content":" 纹理现在只计算了每个点的光照，修改着色器带上纹理： rust varying_uv: glm::Mat3, // 三个顶点的纹理坐标 fn vertex(\u0026mut self, i_face: usize, nth_vert: usize) -\u003e glm::Vec4 { let i_vert = self.model.indices[i_face * 3 + nth_vert]; let vert = self.model.vertices[i_vert as usize]; let normal = Vec3::from_array(\u0026vert.normal); // 顶点法向量 let v = Vec3::from_array(\u0026vert.position); // 顶点位置 let uv = Vec3::from_array(\u0026vert.texture); // 纹理坐标 let gl_v = self.view_port * self.projection * self.model_view * v.extend(1.); self.varying_intensity[nth_vert] = glm::dot(*normal, self.light_dir).max(0.); // 计算每个顶点的光照强度 self.varying_uv.as_array_mut()[nth_vert] = uv.clone(); // 每一列是一个顶点出的纹理坐标 gl_v } fn fragment(\u0026mut self, bar: glm::Vec3, color: \u0026mut image::Rgba\u003cu8\u003e) -\u003e bool { let intensity = glm::dot(self.varying_intensity, bar); // 当前像素的插值强度，重心坐标计算相对三个顶点的强度 let uv = self.varying_uv * bar; // 用重心坐标插值当前点的纹理坐标 let px = self.diffuse.get_pixel( (uv.x * self.diffuse.width() as f32) as _, (uv.y * self.diffuse.height() as f32) as _, ); let r = (px[0] as f32 * intensity) as u8; let g = (px[1] as f32 * intensity) as u8; let b = (px[2] as f32 * intensity) as u8; *color = image::Rgba([r, g, b, 255]); return false; // 不丢弃任何像素 } 查看结果： 代码：81b8c2ae2d04f70036f8ef4227f9bb2ffd5a519a ","date":"2025-01-06","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/:2:2","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记4：着色器","uri":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/#纹理"},{"categories":["program"],"content":" 几种着色方法介绍 平面(Flat)着色： 每个三角形只计算一个光照 Gouraud着色： 每个三角形计算三个顶点的光照，使用三个顶点的光照对三角形中每个点做线性插值 Phong着色： 我们把三角形的每个点的法向量都插值出来，然后再计算光照 ","date":"2025-01-06","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/:3:0","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记4：着色器","uri":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/#几种着色方法介绍"},{"categories":["program"],"content":" 法线贴图(Normal Mapping)我们有纹理坐标，和这样的纹理贴图。 除了纹理，也可以把几乎任何东西存进纹理图像中。它可以是颜色、方向、温度等等。 让我们加载这个纹理： 如果我们将RGB值解释为xyz方向，该图像为我们提供了每个渲染像素的法向量，这样我们就不用靠三个顶点的法向量来插值法向量了。 需要注意，如果对模型进行了仿射变换，那么法向量需要做映射才能使用，上篇有讲，结论：法向量的变换矩阵为模型变换矩阵的逆转置矩阵。 也有一些表示方式能直接描述切空间中的法向量。在达布坐标系中，z向量垂直于物体，x是主曲率方向，y是它们的叉积。详细看这里 下面是使用纹理映射的例子： 从这里新建了一个Phong着色器的实现 rust diffuse_nm: \u0026'a ImageBuffer\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e, // 法线贴图 uniform_m: Mat4, // 模型的变换矩阵m projection*model_view uniform_mit: Mat4, // m的逆转置矩阵 m.inverse().transpose() fn vertex(\u0026mut self, i_face: usize, nth_vert: usize) -\u003e glm::Vec4 { let i_vert = self.model.indices[i_face * 3 + nth_vert]; let vert = self.model.vertices[i_vert as usize]; let normal = Vec3::from_array(\u0026vert.normal); // 顶点法向量 let v = Vec3::from_array(\u0026vert.position); // 顶点位置 let uv = Vec3::from_array(\u0026vert.texture); // 纹理坐标 let gl_v = self.uniform_m * v.extend(1.); self.varying_uv.as_array_mut()[nth_vert] = uv.clone(); // 每一列是一个顶点出的纹理坐标 gl_v } fn fragment(\u0026mut self, bar: glm::Vec3, color: \u0026mut image::Rgba\u003cu8\u003e) -\u003e bool { let uv = self.varying_uv * bar; // 用重心坐标插值当前点的纹理坐标 let px = self.diffuse.get_pixel( (uv.x * self.diffuse.width() as f32) as _, (uv.y * self.diffuse.height() as f32) as _, ); let nm_px = self.diffuse_nm.get_pixel( (uv.x * self.diffuse.width() as f32) as _, (uv.y * self.diffuse.height() as f32) as _, ); let mut n = Vec3::from_array(\u0026[nm_px[0] as _, nm_px[1] as _, nm_px[2] as _]).clone(); // 从贴图中加载法向量 n.as_array_mut() .iter_mut() .for_each(|v| *v = *v / 255. * 2. - 1.); // tga图像中[0,255], 转换到[-1,-1] let n = self.uniform_mit * n.extend(0.); // 法线映射 注意向量转换位齐次坐标是填0 let n = glm::normalize(vec4_to_3(n)); // 齐次坐标投影回3d 注意向量不需要除w分量 let l = self.uniform_m * self.light_dir.extend(0.); // 之前是在顶点作色器中计算光照，现在要在切空间计算 let l = glm::normalize(vec4_to_3(l)); let intensity = glm::dot(n, l); let r = (px[0] as f32 * intensity) as u8; let g = (px[1] as f32 * intensity) as u8; let b = (px[2] as f32 * intensity) as u8; *color = image::Rgba([r, g, b, 255]); return false; // 不丢弃任何像素 } 需要注意的点是向量再参与齐次坐标运算时，w分量需要是0，计算后投影回3d时xyz不需要除以w分量。 这里再贴下点和向量映射回来时的区别： rust /// 齐次坐标系中的点投影到3d /// 点坐标需要除以w pub fn v4p2v3(v: glm::Vec4) -\u003e glm::Vec3 { glm::vec3(v.x / v.w, v.y / v.w, v.z / v.w) } /// 齐次坐标系中的向量投影到3d /// 向量坐标不需要除以w pub fn vec4_to_3(v: glm::Vec4) -\u003e glm::Vec3 { glm::vec3(v.x, v.y, v.z) } 结果： 可以看到皮肤的起伏细节相较于只用三个顶点的法向量插值要好的多。 代码：951f42ea125a28c4f7e7aa83573d68fd43cef472 上面得到的图片比作者的亮，后来发现是全局光照进不进行矩阵变换的区别。再次修改代码 rust // let l = self.light_dir.extend(0.); // 之前是在顶点作色器中计算光照，现在要在切空间计算 // let l = glm::normalize(vec4_to_3(l)); let l = self.light_dir; // 全局光照不进行矩阵变换 let intensity = glm::dot(n, l); 结果： 代码：64d58b1c6d0569db3db1eefaead38443d05b9ac9 ","date":"2025-01-06","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/:4:0","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记4：着色器","uri":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/#法线贴图normal-mapping"},{"categories":["program"],"content":" 高光贴图(Specular Mapping)Phong光照模型： Phong提议将最终照明视为三个光强度的加权总和：环境光(ambient lighting)、漫反射光(diffuse lighting)、镜面光(specular lighting) 我们前面计算的光都是漫反射光，计算了光方向向量和法线向量的余弦值。这假设了光在各个方向上均匀反射。如果是光滑的表面比如镜面，光反射范围会更小，只有反射到了我们的眼睛内我们才能看见。 对于漫反射光我们关心的是向量$n$和向量$l$的余弦值，现在我们要开始关注反射光$r$和视角方向$v$之间的夹角。 给出$n$和$l$如何求$r$：glm::normalize(n * (glm::dot(n, l) * 2.) - l) $$ r=2n(n\\cdot l)-l $$ 光滑的表面在一个方向上的反射比在其他方向上的反射要多，如果我们使用余弦值的$n$次方会怎样${\\cos \\theta }^{n}$，所有小于1的数在进行幂运算时都会减小，这意味这余弦的$n$次方会使反射光的半径变小。不同材质的反射表现，这个信息可以存在高光贴图中。他告诉我们每个点是否有光泽。 rust diffuse_spec: \u0026'a ImageBuffer\u003cRgba\u003cu8\u003e, Vec\u003cu8\u003e\u003e, // 高光贴图 fn fragment(\u0026mut self, bar: glm::Vec3, color: \u0026mut image::Rgba\u003cu8\u003e) -\u003e bool { let uv = self.varying_uv * bar; // 用重心坐标插值当前点的纹理坐标 let px = self.diffuse.get_pixel( (uv.x * self.diffuse.width() as f32) as _, (uv.y * self.diffuse.height() as f32) as _, ); let nm_px = self.diffuse_nm.get_pixel( (uv.x * self.diffuse_nm.width() as f32) as _, (uv.y * self.diffuse_nm.height() as f32) as _, ); let spec_px = self.diffuse_spec.get_pixel( (uv.x * self.diffuse_spec.width() as f32) as _, (uv.y * self.diffuse_spec.height() as f32) as _, ); let spec_v = spec_px[0] as f32 / 1.; // 光泽值, 这个值越小越反射范围越大，越不光泽，越大越有光泽 let mut n = Vec3::from_array(\u0026[nm_px[0] as _, nm_px[1] as _, nm_px[2] as _]).clone(); // 从贴图中加载法向量 n.as_array_mut() .iter_mut() .for_each(|v| *v = *v / 255. * 2. - 1.); // tga图像中[0,255], 转换到[-1,-1] let n = self.uniform_mit * n.extend(0.); // 法线映射 注意向量转换位齐次坐标是填0 let n = glm::normalize(vec4_to_3(n)); // 齐次坐标投影回3d 注意向量不需要除w分量 let l = self.uniform_m * self.light_dir.extend(0.); // 映射光照方向 let l = glm::normalize(vec4_to_3(l)); let r = glm::normalize(n * (glm::dot(n, l) * 2.) - l); // 反射光方向 let spec = glm::pow(r.z.max(0.), spec_v); // 我们从z轴看, dot(v,r) let diff = glm::dot(n, l).max(0.); let arg_ambient = 5.; // 环境光 let arg_diffuse = 1.; // 漫反射光 let arg_specular = 0.6; // 镜面反射光 let intensity = glm::dot(n, l); let r = (arg_ambient + px[0] as f32 * (arg_diffuse * diff + arg_specular * spec)) as u8; let g = (arg_ambient + px[1] as f32 * (arg_diffuse * diff + arg_specular * spec)) as u8; let b = (arg_ambient + px[2] as f32 * (arg_diffuse * diff + arg_specular * spec)) as u8; *color = image::Rgba([r, g, b, 255]); return false; // 不丢弃任何像素 } 这些参数都是可以调整的,不同的选择会给对象带来不同的外观 rust let arg_ambient = 5.; // 环境光 let arg_diffuse = 1.; // 漫反射光 let arg_specular = 0.6; // 镜面反射光 结果如下： 代码：175d0b61c92a55d08ca9b349b77dfb245d7a1d2e ","date":"2025-01-06","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/:5:0","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记4：着色器","uri":"/tinyrenderer%E7%AC%94%E8%AE%B04%E7%9D%80%E8%89%B2%E5%99%A8/#高光贴图specular-mapping"},{"categories":["program"],"content":" 3D空间中的基底变化在欧几里得空间中，一个坐标可以由一个原点和基底给出，考虑点$P$在坐标系$(O,i,j,k)$中拥有坐标$(x,y,z)$的含义，它意味着向量$\\overrightarrow{OP}$ 可以表示为: $$ \\overrightarrow{OP}=\\vec{i}x+\\vec{j}y+\\vec{k}z = \\begin{aligned} \\begin{bmatrix} \\vec{i}\u0026 \\vec{j}\u0026 \\vec{k} \\end{bmatrix} \\end{aligned} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} $$ 现在我们有另外一个坐标系$(O,i’,j’,k’)$，如何将坐标从一个坐标系转换到另一个坐标系，首先$(i,j,k)$和$(i’,j’,k’)$是三维的基底，存在一个(非简并)矩阵$M$使得： $$ \\begin{aligned} \\begin{bmatrix} \\vec{i'}\u0026 \\vec{j'}\u0026 \\vec{k'} \\end{bmatrix} \\end{aligned} = \\begin{aligned} \\begin{bmatrix} \\vec{i}\u0026 \\vec{j}\u0026 \\vec{k} \\end{bmatrix} \\end{aligned} \\times M $$ 参考下面的例子 让我们重新表示$\\overrightarrow{OP}$： $$ \\overrightarrow{OP} = \\overrightarrow{OO'} + \\overrightarrow{O'P} = \\begin{aligned} \\begin{bmatrix} \\vec{i}\u0026 \\vec{j}\u0026 \\vec{k} \\end{bmatrix} \\end{aligned} \\begin{bmatrix} O'_{x} \\\\ O'_{y} \\\\ O'_{z} \\end{bmatrix} + \\begin{aligned} \\begin{bmatrix} \\vec{i'}\u0026 \\vec{j'}\u0026 \\vec{k'} \\end{bmatrix} \\end{aligned} \\begin{bmatrix} x' \\\\ y' \\\\ z' \\end{bmatrix} $$ 现在把右边的$(i’,j’,k’)$替换成矩阵 $$ \\overrightarrow{OP} = \\begin{aligned} \\begin{bmatrix} \\vec{i}\u0026 \\vec{j}\u0026 \\vec{k} \\end{bmatrix} \\end{aligned} \\left( \\begin{bmatrix} O'_{x} \\\\ O'_{y} \\\\ O'_{z} \\end{bmatrix} + M \\begin{bmatrix} x' \\\\ y' \\\\ z' \\end{bmatrix} \\right) $$ 它给出了坐标从一个坐标系到另一个坐标系的变换公式 $$ \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} = \\begin{bmatrix} O'_{x} \\\\ O'_{y} \\\\ O'_{z} \\end{bmatrix} + M \\begin{bmatrix} x' \\\\ y' \\\\ z' \\end{bmatrix} \\ \\Rightarrow \\ \\begin{bmatrix} x' \\\\ y' \\\\ z' \\end{bmatrix} = M^{-1} \\left( \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} - \\begin{bmatrix} O'_{x} \\\\ O'_{y} \\\\ O'_{z} \\end{bmatrix} \\right) $$ ","date":"2024-12-28","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B03%E7%A7%BB%E5%8A%A8%E6%91%84%E5%83%8F%E6%9C%BA/:1:0","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记3：移动摄像机","uri":"/tinyrenderer%E7%AC%94%E8%AE%B03%E7%A7%BB%E5%8A%A8%E6%91%84%E5%83%8F%E6%9C%BA/#3d空间中的基底变化"},{"categories":["program"],"content":" look_at目前我们实现的渲染器相当于使用位于Z轴上的摄像机来绘制场景。如果我们想要移动摄像机得到不同视角的画面，没问题，我们可以移动所有的场景，而不移动摄像机。 让我们这样来看待这个问题：我们想画一个场景，相机位于点$e$(眼睛)。相机应对准点$c$(中心)，向量$u$(up)指向画面的上方： 这意味着我们要在坐标系$(c,x’,y’,z’)$中渲染，但是我们的模型是在$(O,x,y,z)$中给出的，这没有问题，我们只需要计算坐标的变换。这是rust代码将世界坐标转换为摄像机坐标的4x4矩阵ModelView： rust // eye 摄像机位置 center 焦点 up视角上方 pub fn lookat(eye: glm::Vec3, center: glm::Vec3, up: Vec3) -\u003e glm::Matrix4\u003cf32\u003e { let z = glm::normalize(eye - center); // 向量ce let x = glm::normalize(glm::cross(up, z)); // 同时垂直于 up和z的向量 let y = glm::normalize(glm::cross(z, x)); // 注意glm中是按列存的 #[rustfmt::skip] let minv = glm::mat4( x.x, y.x, z.x, 0., x.y, y.y, z.y, 0., x.z, y.z, z.z, 0., 0., 0., 0., 1., ); #[rustfmt::skip] // 这里平移为什么是用的center? 因为把摄像机移动回去这个动作，我们并没有定义原来的摄像机位置，所以不知道位移的向量 // 但是原来的焦点可以认为是原点(0,0,0)，摄像机的位移和焦点位移是一样的，所以用center的坐标来计算 // 这里如果用eye，就相当于假设原来摄像机在原点，结果也对就是看着比预想中远 let tr = glm::mat4( 1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., -center.x, -center.y, -center.z, 1., ); minv * tr } 想象原点$O$平移到$c$ ,然后通过旋转$O$的坐标轴，使得坐标轴$xyz$于$x’y’z’$重合。“我们可以移动所有的场景，而不移动摄像机。” 正常理解是摄像机旋转，然后平移：(旋转、平移可以操作可以叠加成一个矩阵，写成乘法是从后往前写) $$ M_{camera}=M_{translation}\\ *\\ M_{rotation} $$ 我们用它来看物体，可以摄像机不动，对物体做上面变换的逆变换： $$ M^{-1}_{camera}=M^{-1}_{rotation}\\ *\\ M^{-1}_{translation} $$ 旋转矩阵的逆是它的转置，平移矩阵的逆也就是再吧它移回去。 rust代码中写的矩阵是这么来的： $$ lookat = \\begin{aligned} \\begin{bmatrix} R_{x}\u0026 R_{y}\u0026 R_{z}\u0026 0\\\\ U_{x}\u0026 U_{y}\u0026 U_{z}\u0026 0\\\\ D_{x}\u0026 D_{y}\u0026 D_{z}\u0026 0\\\\ 0\u0026 0\u0026 0\u0026 1 \\end{bmatrix} \\end{aligned} \\begin{aligned} \\begin{bmatrix} 1\u0026 0\u0026 0\u0026 -P_x\\\\ 0\u0026 1\u0026 0\u0026 -P_y\\\\ 0\u0026 0\u0026 1\u0026 -P_z\\\\ 0\u0026 0\u0026 0\u0026 1 \\end{bmatrix} \\end{aligned} $$ R - 右向量，对应相机坐标系x轴在世界坐标中的表示 U - 上向量，对应相机坐标系y轴在世界坐标中的表示 D - 方向向量，对应相机坐标系z轴在世界坐标中的表示 P - 相机在世界坐标系中的位置，也是平移的向量 ","date":"2024-12-28","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B03%E7%A7%BB%E5%8A%A8%E6%91%84%E5%83%8F%E6%9C%BA/:2:0","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记3：移动摄像机","uri":"/tinyrenderer%E7%AC%94%E8%AE%B03%E7%A7%BB%E5%8A%A8%E6%91%84%E5%83%8F%E6%9C%BA/#look_at"},{"categories":["program"],"content":" viewport我们在代码中写过这样的转换 rust let screen_coords_a = glm::vec3( ((a.x + 1.) * (width) as f32), ((a.y + 1.) * (height) as f32), a.z, ); 我们有一个点$a$，它属于正方形$[-1,1]*[-1,1]$，我们想要把它画成$(width,height)$尺寸的图像。 $a.x + 1$的范围在0到2，$(a.x+1)/2$的范围在0到1，$(a.x+1)*width/2$刚好适配图像尺寸。 接下来要替换掉这种丑陋的方式，把所有的计算写成矩阵形式。 Viewport矩阵： $$ \\begin{aligned} \\begin{bmatrix} \\frac{w}{2}\u0026 0\u0026 0\u0026 x+\\frac{w}{2}\\\\ 0\u0026 \\frac{h}{2}\u0026 0\u0026 y+\\frac{h}{2}\\\\ 0\u0026 0\u0026 \\frac{d}{2}\u0026 \\frac{d}{2}\\\\ 0\u0026 0\u0026 0\u0026 1 \\end{bmatrix} \\end{aligned} $$ 它意味着立方体$[-1,1] * [-1,1] * [-1,1]$映射到屏幕立方体$[x,x+w] * [y,y+h] * [0,d]$其中d是深度对应z轴。作者说：是的，立方体，而不是矩形，这是因为Z-Buffer的深度计算。这是Z-Buffer的分辨率。我喜欢将其等于255，因为简单地将Z-Buffer的黑白图像进行调试。，暂时还不知道这句话含义。 上面的矩阵也很好推倒，他可以拆分为： 平移：把 $[-1,1] * [-1,1] * [-1,1]$ 平移到 $[0,2] * [0,2] * [0,2]$ 缩放： $[0,2] * [0,2] * [0,2]$ 缩放到 $[0,1] * [0,1] * [0,1]$ 缩放： $[0,1] * [0,1] * [0,1]$ 缩放到 $[0,w] * [0,h] * [0,d]$ 平移： $[0,w] * [0,h] * [0,d]$ 平移到 $[x,x+w] * [y,y+h] * [0,d]$ $$ \\begin{aligned} \\begin{bmatrix} 1\u0026 0\u0026 0\u0026 x\\\\ 0\u0026 1\u0026 0\u0026 y\\\\ 0\u0026 0\u0026 1\u0026 0\\\\ 0\u0026 0\u0026 0\u0026 1 \\end{bmatrix} \\end{aligned} \\begin{aligned} \\begin{bmatrix} w\u0026 0\u0026 0\u0026 0\\\\ 0\u0026 h\u0026 0\u0026 0\\\\ 0\u0026 0\u0026 d\u0026 0\\\\ 0\u0026 0\u0026 0\u0026 1 \\end{bmatrix} \\end{aligned} \\begin{aligned} \\begin{bmatrix} \\frac{1}{2}\u0026 0\u0026 0\u0026 0\\\\ 0\u0026 \\frac{1}{2}\u0026 0\u0026 0\\\\ 0\u0026 0\u0026 \\frac{1}{2}\u0026 0\\\\ 0\u0026 0\u0026 0\u0026 1 \\end{bmatrix} \\end{aligned} \\begin{aligned} \\begin{bmatrix} 1\u0026 0\u0026 0\u0026 1\\\\ 0\u0026 1\u0026 0\u0026 1\\\\ 0\u0026 0\u0026 1\u0026 1\\\\ 0\u0026 0\u0026 0\u0026 1 \\end{bmatrix} \\end{aligned} $$ 最终结果就是viewport矩阵 rust fn viewport(x: i32, y: i32, w: i32, h: i32) -\u003e glm::Matrix4\u003cf32\u003e { let (x, y, w, h) = (x as f32, y as f32, w as f32, h as f32); let d = 255.; #[rustfmt::skip] let m = glm::mat4( w/2., 0., 0., 0., 0., h/2., 0., 0., 0., 0., d/2., 0., x+w/2., y+h/2., d/2., 1., ); m } ","date":"2024-12-28","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B03%E7%A7%BB%E5%8A%A8%E6%91%84%E5%83%8F%E6%9C%BA/:3:0","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记3：移动摄像机","uri":"/tinyrenderer%E7%AC%94%E8%AE%B03%E7%A7%BB%E5%8A%A8%E6%91%84%E5%83%8F%E6%9C%BA/#viewport"},{"categories":["program"],"content":" 坐标变换链模型一般在他们的本地坐标系中被创建(object coordinates)，他们被插入世界坐标(world coordinates)表达的场景，从一个位置转换到另一个是用矩阵Model进行的。然后，我们想在相机坐标系(eye coordinates)中表达它，这个转换叫做View。然后使用投影矩阵(Projection)对场景进行透视变形，这个矩阵将场景转换为所谓的裁剪坐标(clip coordinates)。最后，我们绘制场景，将裁剪坐标转换为屏幕坐标的矩阵称为Viewport。 如果我们从.obj文件中读取点v，那么为了在屏幕上绘制它，它将经历以下转换链： text Viewport * Projection * View * Model * v. 当我们只画一个对象时，Model不做用任何事情(我们不需要更改对象在世界中的位置)，可以忽略。 rust let fin =view_port * projection * model_view; let a = v4p2v3(fin * a.extend(1.)); let b = v4p2v3(fin * b.extend(1.)); let c = v4p2v3(fin * c.extend(1.)); 暂时画出来长这样： 代码见这里e6f0a9d3fbda02776d1ca26af742e1d8f5570f5c ","date":"2024-12-28","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B03%E7%A7%BB%E5%8A%A8%E6%91%84%E5%83%8F%E6%9C%BA/:4:0","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记3：移动摄像机","uri":"/tinyrenderer%E7%AC%94%E8%AE%B03%E7%A7%BB%E5%8A%A8%E6%91%84%E5%83%8F%E6%9C%BA/#坐标变换链"},{"categories":["program"],"content":" 法向量的变换如果我们有一个模型，并且其法向量由艺术家给出，如果我们使用该模型进行了仿射变换，那么不能简单的对其原有法向量进行相同的变换。 简单的例子就是如$p(1,0)$是模型的某个法向量，我们把模型沿y轴平移1个单位，如果也对法向量进行平移操作得到$p’(1,1)$，显然$p’$和$p$不是平行的. 具体可以看这里：知乎 结论：法向量的变换矩阵为模型变换矩阵的逆转置矩阵 $$ M'=(M^{-1})^T $$ ","date":"2024-12-28","objectID":"/tinyrenderer%E7%AC%94%E8%AE%B03%E7%A7%BB%E5%8A%A8%E6%91%84%E5%83%8F%E6%9C%BA/:5:0","series":null,"tags":["blog","tinyrenderer","graphics"],"title":"TinyRenderer笔记3：移动摄像机","uri":"/tinyrenderer%E7%AC%94%E8%AE%B03%E7%A7%BB%E5%8A%A8%E6%91%84%E5%83%8F%E6%9C%BA/#法向量的变换"},{"categories":null,"content":" sigmod 定义： $$ \\sigma(x) = \\frac{1}{1+e^{-x}} $$ 求导： $$ \\sigma' = \\sigma(x)(1-\\sigma(x)) $$ ","date":"2024-05-06","objectID":"/%E5%B8%B8%E7%94%A8%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%92%8C%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/:1:0","series":null,"tags":["blog","神经网络"],"title":"常用激活函数和损失函数","uri":"/%E5%B8%B8%E7%94%A8%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%92%8C%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/#sigmod"},{"categories":null,"content":" softmax作为分类问题输出层的激活函数 将各个输出节点的输出值范围映射到[0, 1]，并且约束各个输出节点的输出值的和为1 定义： $$ softmax(z_i) = \\frac{e^{z_i}}{\\sum ^{K}_{j=1}e^{z_j}} $$ 求导：设$softmax(z_i) = p_i$ $$ \\frac{\\partial y_i}{\\partial z_j} = \\begin{cases} p_i(1-p_j) \u0026j=i\\\\ -p_j\\cdot p_i \u0026j\\neq i \\end{cases} $$ ","date":"2024-05-06","objectID":"/%E5%B8%B8%E7%94%A8%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%92%8C%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/:2:0","series":null,"tags":["blog","神经网络"],"title":"常用激活函数和损失函数","uri":"/%E5%B8%B8%E7%94%A8%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%92%8C%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/#softmax"},{"categories":null,"content":" 交叉熵损失函数softmax通常配合交叉熵损失函数使用 $$ p_i = softmax(z_i) = \\frac{e^{z_i}}{\\sum ^{K}_{j=1}e^{z_j}} $$ 定义：$y_i$是真实样本标签值，分类问题里不是0就是1 $$ L=- \\sum ^K_{i=1}y_i\\log(p_i) $$ 求导： $$ \\frac{\\partial L}{\\partial z_i} = p_i - y_i $$ 求导非常简单，所以softmax和交叉熵一起用，反向传播时候计算就非常简单了 ","date":"2024-05-06","objectID":"/%E5%B8%B8%E7%94%A8%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%92%8C%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/:3:0","series":null,"tags":["blog","神经网络"],"title":"常用激活函数和损失函数","uri":"/%E5%B8%B8%E7%94%A8%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%92%8C%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/#交叉熵损失函数"},{"categories":null,"content":"用rust实现上篇笔记：神经网络的结构 中描述的神经网络 还在实现中。。。 https://github.com/kirito41dd/Hello-NN ","date":"2024-03-30","objectID":"/rust%E6%89%8B%E5%86%99%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:0:0","series":null,"tags":["神经网络","blog"],"title":"rust手写神经网络","uri":"/rust%E6%89%8B%E5%86%99%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/#"},{"categories":null,"content":" 训练过程 确定loss函数,$f(x)$为样本的推理结果,$y$是目标结果，多个样本sum得出loss $$ loss=\\frac{1}{n}\\sum^n_{i=1} (f(x_i)-y_i)^2 $$ 将训练样本分为n个batch，每个batch n个样本 按batch进行训练，将batch中每个样本进行正向传播 记录每个样本的结果，以及这个样本正向传播过程中的所有中间结果 遍历完每个样本后，计算loss 通过loss值对每个样本进行反向传播，过程中需要用到前面缓存的中间结果 记录每个样本反向传播过得到的梯度，将所有样本的梯度求平均值，得到最终调整网络的梯度。因为loss是sum的，所以在算一个样本偏导时，其他样本为常量，求导是0，所以每个样本梯度可以独立计算。 $$ a^2 -2ab + b2 =\u003e 2a-2b =\u003e 2(a-b) =\u003e \\frac{2(a-b)}{n} $$ 根据学习率调整网络参数 将所有batch如此循环来一遍，完成一轮训练 用所有训练样本计算下loss，多轮训练后得到满意的模型 ","date":"2024-03-30","objectID":"/rust%E6%89%8B%E5%86%99%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:1:0","series":null,"tags":["神经网络","blog"],"title":"rust手写神经网络","uri":"/rust%E6%89%8B%E5%86%99%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/#训练过程"},{"categories":null,"content":" 神经网络的表示要实现的是一个全连接神经网络，整个网络模型有很多层(Layer)，除了输入层输出层，其余层都统称为隐藏层，对于要实现的网络可以叫全连接层。在每层里都有若干神经元，每个神经元上都保存着该神经元的偏置$b$和与上层神经元链接的每条边的权重$w$。 可以对Layer进行一定程度抽象，每一层都支持正向传播、反向传播、更新参数 rust pub struct NeuralNetworkModel { pub layers: Vec\u003cBox\u003cdyn Layer\u003e\u003e, } pub trait Layer { // 正向传播 // 返回：本层输出 \u0026 本层中间结果 fn forward(\u0026mut self, input: \u0026MatView, training: bool) -\u003e (Mat, LayerCache); // 反向传播 // grads: 后面一层传递过来的梯度 // cache_forward: 本层正向传播时的输入和激活值，内容为forward的返回 // 返回: 本层向前一层传递的梯度 \u0026 本层所有梯度值 fn backward(\u0026mut self, grads: \u0026MatView, cache_forward: \u0026LayerCache) -\u003e (Mat, LayerCache); // 更新权重和偏置 // grads: 本层调整参考的梯度, 内容格式与backward返回的一致 fn update(\u0026mut self, learning_rate: f32, grads: \u0026LayerCache); } 在实际操作中，可以把一个全连接层拆为两层，即将激活函数抽出单独虚拟为一层，这样更加灵活 ","date":"2024-03-30","objectID":"/rust%E6%89%8B%E5%86%99%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:2:0","series":null,"tags":["神经网络","blog"],"title":"rust手写神经网络","uri":"/rust%E6%89%8B%E5%86%99%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/#神经网络的表示"},{"categories":null,"content":" 激活函数层先看简单的激活函数层，使用sigmod作为激活函数，激活函数层上没有任何权重和偏置，所以不需要存储任何参数： rust // 使用激活函数sigmod的层 pub struct SigmodLayer {} 正向传播时只需要求每个输入的sigmod值即可，sigmod的公式是： $$ \\sigma(x) = \\frac{1}{1+e^{-x}} $$ rust // 激活函数层每个神经元只有一条入边, 只是对上层的输出做一个转换, 矩阵形状n行1列 fn forward(\u0026mut self, input: \u0026MatView, training: bool) -\u003e (Mat, LayerCache) { let out = input.map(|x| sigmod(*x)); // 只有在训练时候才保存输出值，反向传播会用到 let mut cache = vec![]; if training { cache.push(out.clone()); } (out, cache) } 求导公式如下 详见：Sigmoid函数求导 $$ \\sigma' = \\sigma(x)(1-\\sigma(x)) $$ 有了求导公式，就可以写出sigmod层反向传播的实现： rust // 激活函数层反向传播, 对sigmod(x)求导即可, 每个神经元只有一条入边,返回的梯度是 n行1列 // simod(x)求导是 sigmod(x)*(1-sigmod(x)) // 每个神经元有多条出边,链式法则后要累加结果 fn backward(\u0026mut self, grads: \u0026MatView, cache_forward: \u0026LayerCache) -\u003e (Mat, LayerCache) { // sigmod(x)的值 let a = cache_forward[0].view(); // 激活函数层的输入和输出数量是相等的, 返回值长度和前一层神经元数量一致 let mut r = Mat::from_shape_fn((a.len(), 1), |(_, _)| 0.); // 对每个神经元求梯度 for (i, out) in a.iter().enumerate() { // 累加当前神经元每条出边的偏导 for g in grads.rows().into_iter() { // 链式法则,与输入偏导相乘 // 当前神经元为 i, 所以g也取每行第i个 r[(i, 0)] += g[i] * (out * (1.0 - out)); } } // 激活函数层没有任何存储任何权重和偏置,无需update (r, vec![]) } 没有参数，所以不需要根据梯度更新参数： RUST fn update(\u0026mut self, _learning_rate: f32, _gradss: \u0026LayerCache) { //不需要做任何事情 } 测试： 正向传播：输入两个$0$，sigmod层激活值是$0.5$，输出层值为$1$ 反向传播：$z=wa+b$对$w$求偏导为$a$，所以输出层每个边的偏导为$0.5$ sigmod层的偏导为 $\\sum \\sigma \\times (1-\\sigma) \\times g = 0.5 \\times (1-0.5) \\times 0.5 = 0.125$，每个神经元只有一条出边所以不用sum rust let mut s = SigmodLayer::new(); let a = s.forward(\u0026array![[0.], [0.]].view(), true); println!(\"a:\\n{}\", a); assert_eq!(a, array![[0.5], [0.5]]); let g = s.backward_and_update(\u0026array![[0.5, 0.5]].view(), 0.1); println!(\"g:\\n{}\", g); assert_eq!(g, array![[0.125], [0.125]]) 完整代码 4157fcb ","date":"2024-03-30","objectID":"/rust%E6%89%8B%E5%86%99%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:2:1","series":null,"tags":["神经网络","blog"],"title":"rust手写神经网络","uri":"/rust%E6%89%8B%E5%86%99%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/#激活函数层"},{"categories":null,"content":" 全连接层全连接层需要存储w和b，并且特地不带激活函数： rust // 没有激活函数的全连接层 pub struct DenseLayerNoActive { // 每个神经元与上一层所有神经元边的权重, n行j列,n是本层神经元个数,j是前一层神经元个数 pub w: Mat, // 每个神经元的偏置, n行1列 pub b: Mat, } 正向传播公式很简单，单个节点的激活值： $$ z = w_1\\times a_1 + w_2\\times a_2 +\\ ... + w_n*a_n + b $$ RUST fn forward(\u0026mut self, input: \u0026MatView, training: bool) -\u003e (Mat, LayerCache) { // 计算每个神经元激活值 w1*a1 + w2*a2 + ... + wn*an + b // 矩阵计算,一次算出结果, w的每行乘以输入的一列最后加b let r = self.w.dot(input) + \u0026self.b; let mut cache = vec![]; if training { cache.push(input.to_owned()); } (r, cache) } 对 $w_i$ 求偏导为$a_i$ 对$b$求偏导为$1$ 反向传播： rust // 每个神经元有多(k)条入边返回的梯度是 n行k列 // z=w*a+b 对w求导是a, 对b求导是1 // 每个神经元看作有多条出边,链式法则后仍要累加(大多情况后一层是激活函数层,只有1条出边,但不排除其他可能) fn backward(\u0026mut self, grads: \u0026MatView, cache_forward: \u0026LayerCache) -\u003e (Mat, LayerCache) { let a = cache_forward[0].view(); let mut bias_grads = Mat::zeros(self.b.raw_dim()); let mut w_grads = Mat::zeros(self.w.raw_dim()); // 对每个神经元求所有w和b的偏导, 每个w的导数都是与其相乘的a, w不需要参与, 对b的偏导是1 for (i, _) in self.w.columns().into_iter().enumerate() { // 累加当前神经元每条出边上的偏导, grads的每行,都是前一层某个神经元和本层连线的偏导 for g in grads.rows().into_iter() { // b在这里求 链式法则相乘 bias_grads[(i, 0)] += g[i] * 1.; //每个神经元上都有和前一层神经元的边, 连接w和a for (k, a) in a.rows().into_iter().enumerate() { w_grads[(i, k)] += a[0] * g[i]; } } } let grads_cache = vec![bias_grads, w_grads.clone()]; // 入边只和w有关系,不用返回偏置上的偏导 (w_grads, grads_cache) } 最后实现参数更新： rust fn update(\u0026mut self, learning_rate: f32, grades: \u0026LayerCache) { let bias_grads = grades[0].view(); let w_grads = grades[1].view(); // 更新偏置 let (i, j) = (self.w.shape()[0], self.w.shape()[1]); for i in 0..i { for j in 0..j { self.w[(i, j)] -= learning_rate * w_grads[(i, j)]; } self.b[(i, 0)] -= learning_rate * bias_grads[(i, 0)]; } } 测试： rust let mut d = DenseLayerNoActive { w: array![[2., 2.], [2., 2.]], b: array![[0.1], [0.1]], }; let (a, f_cache) = d.forward(\u0026array![[0.5], [1.]].view(), true); println!(\"a:\\n{}\", a); assert_eq!(a, array![[3.1], [3.1]]); let (g, b_cache) = d.backward(\u0026array![[3.1, 3.1], [3.1, 3.1]].view(), \u0026f_cache); println!( \"g:\\n{}, b_cache:\\ng_b:\\n{}\\ng_w\\n{}\", g, b_cache[0], b_cache[1] ); assert_eq!(g, array![[3.1, 6.2], [3.1, 6.2]]); d.update(0.1, \u0026b_cache); println!(\"d.w:\\n{}\\nd.b\\n{}\", d.w, d.b); 完整代码 4157fcb ","date":"2024-03-30","objectID":"/rust%E6%89%8B%E5%86%99%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:2:2","series":null,"tags":["神经网络","blog"],"title":"rust手写神经网络","uri":"/rust%E6%89%8B%E5%86%99%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/#全连接层"},{"categories":null,"content":" 参考 神经网络的结构 Digit Recognition with Rust and WASM - Part 1 A tiny artificial neural network rust library(每个样本都立即反向传播，相当于只能batch size都是1，不知道是故意的还是不小心的) $$ C_x = \\frac{(y-a)^2}{2} a = \\sigma(z) \\delta^L= a - y $$ ","date":"2024-03-30","objectID":"/rust%E6%89%8B%E5%86%99%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/:3:0","series":null,"tags":["神经网络","blog"],"title":"rust手写神经网络","uri":"/rust%E6%89%8B%E5%86%99%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/#参考"},{"categories":null,"content":" 背景在服务器日常登录过程中，一般是前端传输账号和密码到服务器，然后服务器对账号密码进行校验。但在这个过程中有两个问题，假设传输过程中信息被截获（或者打印日志然后日志泄漏等操作），可能导致密码泄漏。如果服务器数据泄漏，也会导致密码泄漏。一般来说我们服务器中存储的是密码的sha256，这样可以解决服务器数据泄漏的问题，但是传输过程中的问题没有解决（前端hash再传输是无效的，因为这样做hash后的值等效于密码）。我们希望提出一种方案，同时满足传输过程中信息任意泄漏，服务器数据任意泄漏，也可以保证密码的安全。 想法来源： https://pdos.csail.mit.edu/papers/otfvec/paper.pdf https://arxiv.org/pdf/1906.07221.pdf ","date":"2024-03-14","objectID":"/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%99%BB%E9%99%86/:1:0","series":null,"tags":["blog"],"title":"同态加密登陆","uri":"/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%99%BB%E9%99%86/#背景"},{"categories":null,"content":" 同态简要同态加密允许加密一个值，并使用加密后的值进行运算。实现同态加密有多种方式，这里简单介绍一个简要例子 选择一个自然数作为基数（这个基数需要具备一些特定的属性），将基数记为g，用 g去加密一个值，即g为底数，需要加密的值为指数。比如，我们要加密一个数值 3，取 g为 5： $$ 5^3=125 $$ 125是 3 加密过后的值，如果我们把需要加密的值E(3)乘2，我们就可以给加密后的值（125）提高两个阶数， $$ 125^2=15265=(5^3)^2=5^{2*3}=5^6 $$ 同样，我们可以通过除法来使加密值相减，例如 5−3： $$ {5^5}/{5^3}=5^{5-3}=5^2=25 $$ 我们可以看出，同态加密可以实现加、减、乘操作 ","date":"2024-03-14","objectID":"/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%99%BB%E9%99%86/:2:0","series":null,"tags":["blog"],"title":"同态加密登陆","uri":"/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%99%BB%E9%99%86/#同态简要"},{"categories":null,"content":" 方案简要","date":"2024-03-14","objectID":"/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%99%BB%E9%99%86/:3:0","series":null,"tags":["blog"],"title":"同态加密登陆","uri":"/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%99%BB%E9%99%86/#方案简要"},{"categories":null,"content":" 原理$m为素数，g是m的原根之一，m数量级约 2^{256}，令 h(x) = {g^{x}}\\bmod{m},定义 h(x)*h(y) = g^{x\\ast y}\\bmod{m}$ 在登录的时候，前端需要使用两个信息，1是密码本身，2是一些现场信息，比如当前时间戳、设备信息、当前浏览器、想要登录的服务器id、后端给的保证登录不可复用token等，我们称这部分信息为前端info。后端生成数据的时候需要一个salt，这个数据可以是一个保密的随机数。 简单来说，我们需要使用三个数据。令sm=密码的sha256，sf=前端info的sha256，ss=后端salt的sha256， 当用户注册的时候，后端拿到sm和ss，计算出 $hsmss=h(sm)*h(ss)=g^{sm\\ast{ss}}\\bmod{m}$存入数据库，同时丢弃sm。此时后端能拿到的数据有：ss、g、m、hsmss。 当用户想要登录时，前端有sm和sf，计算出$hsmsf=h(sm)*h(sf)=g^{sm\\ast{sf}}\\bmod{m}$。把hsmsf和sf传入后端（实际上应该传sf的原文，因为后端需要校验时间戳等，这里为了简化使用sf） 此时后端已知hsmss、sf、hsmsf、ss，可以校验 $$ hsmss^{sf} == hsmsf^{ss}(\\bmod{m}) =\u003e g^{(sm\\ast ss)\\ast sf}==g^{(sm\\ast sf)\\ast ss}(\\bmod{m}) $$ 如果相等则密码正确，否则密码错误。 我们可以验证这个方案是否满足需求，假设我们在多机部署，其中一台机器后端数据库泄漏，同时某用户在登录过程中传输的所有信息也泄漏了（例如登录信息打印在日志上，日志泄漏了），此时攻击者是否可以用这些信息登录别的服务器。 为了简化问题，我们列出攻击者实际可以拿到的数据：g、m、ss、hsmss、hsmsf1、sf1（攻击者需要再次登录，被截获的登录的sf为sf1，攻击者登录为sf2）。攻击者需要做的是在不知道sm的情况下，构造出hsmsf2。 $hsmsf2=(g^{sm})^{sf2}\\bmod{m}或(g^{sf2})^{sm}\\bmod{m}$ 所以攻击者需要计算出$g^{sm}\\bmod{m}或sm\\bmod{m}$ 而 $hsmss=(g^{sm})^{ss}\\bmod{m}$ 我们可以将问题再次简化 $m为素数，g是m的原根之一。h=g^{a * b}\\bmod{m}，t=g^{a * c}\\mod{m}，(a,b,c,g,m数量级都是2^{256})$ 问在已知h,b,c,g,m的情况下，是否存在非枚举的方法可以求出t. 走到这步我们很高兴的可以说这个问题是不存在有限时间内的解的，因为证明密码的强度一般是将问题转化成公认的已知困难问题，比如离散对数问题，而这个问题本身就是离散对数问题。 离散对数问题：https://zhuanlan.zhihu.com/p/523658036 代码实现思路参考： https://eprint.iacr.org/2019/458.pdf https://github.com/arnaucube/poseidon-rs 这个库已经提供了m和g的值，以及大整数运算，稍加修改即可 直接贴个m和g： text 21888242871839275222246405745257275088548364400416034343698204186575808495617 7 ","date":"2024-03-14","objectID":"/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%99%BB%E9%99%86/:3:1","series":null,"tags":["blog"],"title":"同态加密登陆","uri":"/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%99%BB%E9%99%86/#原理"},{"categories":null,"content":"视频教程： 【官方双语】深度学习之神经网络的结构 Part 1 ver 2.0 【官方双语】深度学习之梯度下降法 Part 2 ver 0.9 beta 【官方双语】深度学习之反向传播算法 上/下 Part 3 ver 0.9 beta ","date":"2024-01-09","objectID":"/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/:0:0","series":null,"tags":["神经网络","blog"],"title":"神经网络的结构","uri":"/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/#"},{"categories":null,"content":" 神经网络结构如何识别尺寸28x28=784像素的数字图片： 神经网络的变种有很多： 卷积神经网络 Convolutional neural network 擅长图像识别 image recognition 长短期记忆网络 Long short-term memory network 擅长语音识别 多层感知器 MLP(Multilayer Perceptron) 经典原版，就是下面的结构 神经网络名字来源于人类大脑，神经元是什么又是如何连接的。 神经元看作一个装有数字的容器，一般是0到1区间，上面的结构把图片的每个像素都输入到网络对应的神经元中，值为像素的灰度值，值越大像素越白。 一般把神经元中装的值叫做 激活值 Activation 网络中最后一层的十个神经元代表0到9十个数字，他们的激活值也在0到1之间，激活值表示系统认为输入的图像对应着哪个数字的可能性。 网络中间还有几层 隐含层 Hidden layers，例子中选择了两层隐含层，每层16个神经元，随便选的 神经网络运作时，上一层的激活值将决定下一层的激活值，所以神经处理信息的核心机制正是：一层的激活值是通过怎样的运算 算出下一层的激活值。可以看作是模仿生物中神经元组成的网络，某些神经元的触发，就会促使另一些神经元激发。 上层神经元如何影响下层神经元的激活值，给第二层的每个神经元与第一层所有神经元的每一条连线都附上一个权重值 Weights，这些权重都是数字而已 拿第一层的所有激活值，和每条边的权重一起，算出他们的加权和。这样算出来的值可能是任意大小，我们需要激活值都在0到1之间，可以通过某种函数来映射，比如：Sigmoid，这种函数一般叫激活函数Activation Function 所以激活值就是把上面算出来的加权值塞进sigmoid函数映射一下，但有时候即使加权和大于0，也不想把神经元点亮，比如规定加权和大于10的时候才激发，可以加上一个-10之类的数，叫做偏置 bias 。再将它送到sigmoid函数 权重表示神经元受哪些上层神经元的影响，偏执规定加权和得有多大，才能让神经元的激发有意义。除了第一层的神经元，后面每层的神经元都有偏置 所有的权重和偏执都可以看作是旋钮开关供你调整，从而带来不一样的结果。学习或者说训练的过程，就是找到该如何设置这一坨参数，才能让它正确的解决问题。 对于计算下层神经元的激活值，线性代数可以很方便表示 整个神经网络可以看作一个函数，例子是一个输入784个值，输出10个值的函数 ","date":"2024-01-09","objectID":"/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/:1:0","series":null,"tags":["神经网络","blog"],"title":"神经网络的结构","uri":"/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/#神经网络结构"},{"categories":null,"content":" 梯度下降法神经网络训练的过程，是不断调整权重和偏置这些参数，提高网络对训练数据的表现。最终我们希望这个网络可以举一反三，给它没见过的测试数据它也能正确处理。 在一开始，回完全随机的初始化所有的权重和偏置值，这个网络对于给定的训练示例，会表现的非常糟糕。 需要定义一个代价函数来告诉它，结果有多垃圾。 需要将每个垃圾输出激活值，与你想要值之间的差的平方和加起来。我们称之为单个样本上的代价(Cost 也可以叫 Loss)，这个值越大，说明你的模型越找不到北。接下来要考虑所有训练样本中代价的平均值(这个值也叫 Empirical Risk 经验风险)，用这个值来评价网络有多糟糕。 只告诉网络它有多糟糕是没啥用的，还得告诉他怎么改变这些权重和偏置值，才能有进步。 先不考虑13000个参数的函数，而先考虑简单的一元函数，怎么找到输入值x，使函数值最小化呢？ 如果函数很简单，那么直接求斜率为0的位置就是答案，但如果函数很复杂，就不一定能写出来。对于13000个参数的网络，更加不可能。一个技巧是，先随便挑一个输入值，然后考虑向左走还是向右走，函数值才会变小。 可以找到这个地方的斜率，如果为正0就往左走，为负就往右走，每次走一小步，不停的这样，就可以找到一个局部最小值。取决于一开始的输入，最后可能落到不同的坑里，可能并不是最优解，神经网络也会遇到这样的问题。 对于两个输入一个输出的二元函数，则可以看作为一个面，用同样的方法找到某个局部最深的坑 问题变成哪个方向下山最快。和一元函数的斜率一样，多元函数也有斜率，叫做梯度，梯度指出了函数的最陡增长方向。这种算法总结下就是：随便一个输入后，先计算梯度，再按梯度负方向走一小步下山，然后循环。处理13000个输入的函数也一样，这就是梯度下降算法 想象13000个输入的情况是很复杂的，不借助空间，把梯度看着一个向量，负梯度的每一项值都告诉我们两件事，正负号告诉我们输入向量的这一项应该调大还是调小，每一项值的相对大小告诉我们改变哪个输入影响更大。 在网络中，把13000多个权重和偏置作为输入，通过训练数据，得出一个对网络糟糕程度的评分。代价函数的梯度，告诉我们如何微调权重和偏置的值，才可以让代价函数改变的最快。 当你随机初始化权重和偏置，并通过梯度下降法调整了很多次参数之后，期望的是神经网络识别数字的正确率变高，包括识别从来没见过的图片。 ","date":"2024-01-09","objectID":"/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/:2:0","series":null,"tags":["神经网络","blog"],"title":"神经网络的结构","uri":"/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/#梯度下降法"},{"categories":null,"content":" 反向传播神经网络学习的核心算法。为了让整个网络的代价值越来越小，我们要求的是代价函数的负梯度，它告诉你如何改变所有权重和偏置，好让代价下降的最快。反向传播算法正是用来求这个复杂到爆炸的梯度的。 理论上因为代价函数牵扯到对成千上万个训练样本的代价取平均值，所以我们调整每一步梯度下降用的权重偏置，也会基于所有的训练样本。但为了计算效率，这里可以逃课，不必每一步都非得要计算所有的训练样本。 先只关注一个训练样本“2”，会对调整权重偏置产生什么影响，假设网络现在还没训练好，所以输出层的激活值看起来都很随机，我们希望输出结果时2，我们希望对于神经元的激活值变大，其余神经元的激活值变小。并且变动的大小应该与现在值和目标值之间的差成正比，比如增加2对应神经与的激活值，就比减少8的激活值更重要，因为8的激活值已经很接近目标了。 就先来关注一下2的神经元，它的激活值是上一层所有激活值的加权和 加上一个偏置，再通过sigmoid ReLu之类的激活函数算出来的。要增大这个激活值，有三条路： 增加偏置$b$ 增加权重$w$ 改变上一层的激活值$a$（注意不能直接改激活值，只能改上上层的权重偏置） 先看增加权重，各个权重的影响力是不同的，前一层的激活值a越大，这条边权重的影响力就越大 梯度下降时候，并不只看每个参数是该增大还是减小，还看哪个参数的性价比最高 再看第三条路，改变上一层激活值，$w$为正时候，$a$越大越好，$w$为负时候$a$越小越好，和增加权重类似，改变上一层激活值，要依据对应权重大小，对激活值做出成比例的改变 跳出2的神经元，从全局上看，我们还需要输出层其他神经元的激活值变弱，但输出层的每个神经元，对于如何改变倒数第二层都有各自的想法，所以我们会把2的神经元的期待，和别的输出神经元的期待全部加起来，作为如何改变倒数第二次神经元的指示。 这些期待变化不仅是对应的权重的倍数，也是每个神经元激活值改变量的倍数，这其实就是在实现反向传播的理念了。 把所有期待值加起来，就得到了一串对倒数第二层改动的变化量，重复这个过程，改变影响倒数第二层神经元激活值的相关参数，把这个过程循环到第一层。 再放大局面，上面只是训练单个样本“2”的影响，还要对其他所有的训练样本，同样的过一遍反向传播 记录下每个样本想怎样修改权重和偏置，在对每个参数的修改取一个平均值，不严格地说，这就是代价函数的负梯度，至少是标量的倍数： 顺便在实际操作总，如果梯度下降的每一步，都用上每一个训练样本来计算的话，那么花的时间就太长了，所以一般把训练数据打乱，分成不同组，然后按组算出下降的一步。这不是代价函数真正的梯度，然而是个不错的近似，主要是计算量会降低不少。这个技巧叫做随机梯度下降 Stochastic gradient descent ","date":"2024-01-09","objectID":"/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/:3:0","series":null,"tags":["神经网络","blog"],"title":"神经网络的结构","uri":"/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/#反向传播"},{"categories":null,"content":" 微积分原理反向传播最重要是对代价函数求导。 先考虑最简单的网络结构，每层只有一个神经元，只有三个权重和三个偏置。我们目标是找到代价函数对这些变量有多敏感，这样就能知道怎么调整代价降低最快。 先关注最后两个神经元，激活值$a$的上标$L$表示它处在第$L$层，给定一个样本，把样本最终激活值要接近的目标叫做$y$。 这个网络对于单个训练样本的代价就是图上$C_0(…)$ ，把计算最后一层样本用到的加权和与偏置的和叫做$z^{(L)}$ ，当然最终的激活值$a^{(L)}$还经过了一个激活函数$\\sigma(z^{(L)})$ 。 左边的树状结构展示了代价计算过程的层级先后，首我们拿权重、上层的激活值、偏置算出了$z$ ，然后通过激活函数算出了$a$ ，最后再结合$y$算出了代价$C_0$ 我们的第一个目标是理解代价函数对权重$W^{(L)}$的微小变化有多敏感，也就是求$C$对于$w^{(L)}$的导数: $$ \\frac{\\partial C}{\\partial w^{(L)}} $$ 概念上来说$w^{(L)}$的微小变化，会导致$z(L)$产生变化，然后会导致$a^{(L)}$产生变化，最终影响到代价值。 可以根据链式法则，把三个比相乘，就可以算出$C$对$w^{(L)}$的微小变化有多敏感： $$ \\frac{\\partial C_0}{\\partial w^{(L)}} = \\frac{\\partial z^{L}}{\\partial w^{(L)}} \\frac{\\partial a^{L}}{\\partial z^{L}} \\frac{\\partial C_0}{\\partial a^{L}} $$ 一个个看： $C_0$对$a^{(L)}$ 求导就是$2(a^{(L)}-y)$ $a^{(L)}$对$z^{(L)}$求导就是$\\sigma ‘(z^{L})$ ，即对激活函数求导 $z^{(L)}$对$w^{(L)}$求导就是$a^{(L-1)}$ , 常量被干掉了，然后$w^{(L)}$一次方变零次方就是1，所以只剩上层激活值了 这只是一个样本，由于总的代价函数是许许多多训练样本所有代价的平均，它对$w^{(L)}$的导数就需要求这个表达式之于每一个训练样本的平均 当然这只是梯度向量$\\nabla C$的一个分量： 梯度向量$\\nabla C$本身由代价函数对每一个权重和每一个偏置求偏导构成。对偏置求偏导步骤也基本相同，再树状结构上把$b^{(L)}$看作变量来求即可： 回到树的末梢，来看下这个代价函数对上一层的激活值$a^{(L-1)}$的敏感度，同样的计算思路： 这样我们算出了代价函数对$(L-1)$层激活值的敏感度，虽说我们不能改变激活值，但我们仍然需要这个值，因为我们可以反向运用链式法则，来计算代价函数对之前的权重和偏置的敏感度。 很显然，已经有$C_0$对$a^{(L-1)}$的导数的情况下，求更上面的节点的时候比如$w^{(L-1)}$，只要简单相乘就好了： $$ \\frac{\\partial C_0}{\\partial w^{(L-1)}} = \\frac{\\partial z^{(L-1)}}{\\partial w^{(L-1)}} \\frac{\\partial a^{(L-1)}}{\\partial z^{(L-1)}} \\frac{\\partial C_0}{\\partial a^{(L-1)}} $$ 妙蛙~ 对于复杂的结构，无非是夺标几个下标，下标是神经元在当前层的节点编号： 只是看着复杂，和每层只有一个神经元本质是一样的： 唯一改变的是，代价对$(L-1)$层激活值的导数，需要SUM，因为它有多条出边，如图上它同时影响$a^{(L)}_0$ 和$a^{(L)}_1$ 进而影响激活函数，所以得把它们加起来。 这样就完成了，只要算出来倒数第二层 代价函数对激活值的敏感度，接下来只要重复这个过程，计算喂给倒数第二层的权重和偏置就好了。这就是反向传播。 链式法则表达式给出了决定梯度每个分量的偏导，使得我们能够不断下探，最小化神经网络的代价。 ps:怎么更新，$w = w - 学习率 \\times 偏导值$ ，学习率是梯度下降的步长 ","date":"2024-01-09","objectID":"/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/:4:0","series":null,"tags":["神经网络","blog"],"title":"神经网络的结构","uri":"/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/#微积分原理"},{"categories":null,"content":" 补充激活函数： 早先都是使用Sigmoid映射加权值，后来发现ReLU(Rectified linear unit) 线性整流函数效果更好 疑问：ReLU好像并不能让激活值在0到1之间？ 训练数据： MNIST数据库有搜集数以万计的手写数字图像 ","date":"2024-01-09","objectID":"/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/:5:0","series":null,"tags":["神经网络","blog"],"title":"神经网络的结构","uri":"/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/#补充"},{"categories":["program"],"content":"前面渲染模型时候，没有考虑每个点的z坐标，这种方式叫做正交投影Orthographic projection，模型看起来偏胖，因为我们平时在3d世界看到的物体都是近大远小的。透视投影Perspective projection就是用近大远小的方式投影。 两种投影对比： 正交 透视 ","date":"2023-04-08","objectID":"/tinyrenderer-note-2/:0:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记2：透视投影","uri":"/tinyrenderer-note-2/#"},{"categories":["program"],"content":" 2维几何","date":"2023-04-08","objectID":"/tinyrenderer-note-2/:1:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记2：透视投影","uri":"/tinyrenderer-note-2/#2维几何"},{"categories":["program"],"content":" 线性变换Linear transformations线性变换从几何直观有三个要点： 变换前是直线的，变换后依然是直线 直线比例保持不变 变换前是原点的，变换后依然是原点 说白了就是缩放、裁切和旋转， 不包括平移：可以看这个文章 平面上的线性变换都可以用一个二维矩阵计算： $$ \\begin{bmatrix} a \u0026 b \\\\ c \u0026 d \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} ax + by \\\\ cx + dy \\end{bmatrix} $$ ","date":"2023-04-08","objectID":"/tinyrenderer-note-2/:1:1","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记2：透视投影","uri":"/tinyrenderer-note-2/#线性变换linear-transformations"},{"categories":["program"],"content":" 仿射变换affine transformations说简单点就是线性变换加上平移，用矩阵计算： $$ \\begin{bmatrix} a \u0026 b \\\\ c \u0026 d \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} + \\begin{bmatrix} e \\\\ f \\end{bmatrix} = \\begin{bmatrix} ax + by + e\\\\ cx + dy + f \\end{bmatrix} $$ ","date":"2023-04-08","objectID":"/tinyrenderer-note-2/:1:2","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记2：透视投影","uri":"/tinyrenderer-note-2/#仿射变换affine-transformations"},{"categories":["program"],"content":" 齐次坐标Homogeneous coordinates把2x2的变换矩阵加上一行一列，变成3x3，并且把等待变换的向量加上一个总是1的坐标： $$ \\begin{bmatrix} a \u0026 b \u0026 e \\\\ c \u0026 d \u0026 f \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} ax + by + e\\\\ cx + dy + f \\\\ 1 \\end{bmatrix} $$ 这样就实现了和仿射变换一样的效果！这个想法非常简单。平移在二维空间中不是线性的。所以我们将2D嵌入到3D空间中(通过简单地为第三个分量加1)。这意味着二维空间是三维空间中z=1的平面。然后我们执行一个3D线性变换，并将结果投影到我们的2D物理平面上。 将3d投射到2d只需要除以3d分量： $$ \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} \\rightarrow \\begin{bmatrix} x/z \\\\ y/z \\end{bmatrix} $$ 如果z无限逼近0代表被投影后的点在无穷远处： 被投影的点 -\u003e 投影到平面z=?的2d坐标 (x,y,1) -\u003e (x,y) (x,y,1/2) -\u003e (2x,2y) (x,y,1/4) -\u003e (4x,4y) 可以看到，随着平面的下降，投影后的点越来越远，所以当z=0时，表示的是一个向量而不是3d空间中的一个点。 ","date":"2023-04-08","objectID":"/tinyrenderer-note-2/:2:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记2：透视投影","uri":"/tinyrenderer-note-2/#齐次坐标homogeneous-coordinates"},{"categories":["program"],"content":" 3d仿射变换2d的仿射变换可以通过吧2d嵌入3d，转换成3d中的线性变换，再投影回2d。同样的道理：3d的仿射变换，可以通过吧3d嵌入4d，转换成4d中的线性变换，在投影回3d！ 使用齐次坐标: 点(x,y,z) -\u003e (x,y,z,1)，用下面的矩阵试着把它在4d空间中进行变换: $$ \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 r \u0026 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x \\\\ y \\\\ z \\\\ rz+1 \\end{bmatrix} $$ 再投影回3d： $$ \\begin{bmatrix} x \\\\ y \\\\ z \\\\ rz+1 \\end{bmatrix} \\rightarrow \\begin{bmatrix} \\frac{x}{rz+1} \\\\ \\frac{y}{rz+1} \\\\ \\frac{z}{rz+1} \\end{bmatrix} = \\begin{bmatrix} x^{'} \\\\ y^{'} \\\\ z^{'} \\end{bmatrix} $$ 先把这个结果放一边。来看一个模拟现实中人眼将3d中一个点投影到平面上的例子: 有一个点P=(x,y,z)，我们要把它投影到z=0的平面上，摄像机(也就是人的眼睛)在z轴上(0,0,c)的位置，焦点就是原点 根据初中还是高中的知识，三角形ABC和ODC是相似三角形，所以$\\frac{AB}{AC}=\\frac{OD}{OC}$，进而得出$\\frac{x}{c-z}=\\frac{x^{’}}{c}$ 所以： $$ x^{'}= \\frac{x}{1-z/c} $$ 同理： $$ y^{'}= \\frac{y}{1-z/c} $$ 回到矩阵，让r=-1/c: $$ \\begin{bmatrix} x \\\\ y \\\\ z \\\\ rz+1 \\end{bmatrix} \\rightarrow \\begin{bmatrix} \\frac{x}{rz+1} \\\\ \\frac{y}{rz+1} \\\\ \\frac{z}{rz+1} \\end{bmatrix} \\rightarrow \\begin{bmatrix} \\frac{x}{1-z/c} \\\\ \\frac{y}{1-z/c} \\\\ \\frac{z}{1-z/c} \\end{bmatrix} $$ 这个r就是透视投影变换矩阵的关键！ ","date":"2023-04-08","objectID":"/tinyrenderer-note-2/:3:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记2：透视投影","uri":"/tinyrenderer-note-2/#3d仿射变换"},{"categories":["program"],"content":" 总结如果我们想用位于z轴上距离原点为c的摄像机计算一个中心投影(焦点就是原点)，分三步： 将3d嵌入到4d中 在4d中进行线性变换 投影回3d $$ \\begin{aligned} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} \\rightarrow \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} \u0026\\qquad(1)\\\\ \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 -1/c \u0026 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1-z/c \\end{bmatrix} \u0026\\qquad(2)\\\\ \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1-z/c \\end{bmatrix} \\rightarrow \\begin{bmatrix} \\frac{x}{1-z/c} \\\\ \\frac{y}{1-z/c} \\\\ \\frac{z}{1-z/c} \\end{bmatrix} \u0026\\qquad(3) \\end{aligned} $$ rust // 4d投影到3d fn v4p2v3(v: glm::Vec4) -\u003e glm::Vec3 { glm::vec3(v.x / v.w, v.y / v.w, v.z / v.w) } // ... let camera: glm::Vec3 = glm::vec3(0., 0., 3.); // 投影变换矩阵，注意gml初始化一行是矩阵中的一列 let projection = glm::mat4( 1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., -1./camera.z, // 这里camera.z是摄像机到焦点的距离 0., 0., 0., 1.); // ... // 透视投影 let a = v4p2v3(projection * a.extend(1.)); let b = v4p2v3(projection * b.extend(1.)); let c = v4p2v3(projection * c.extend(1.)); 详细代码见这里076b31fc4ea69f00e2cee530e5e3e25445189b67 ","date":"2023-04-08","objectID":"/tinyrenderer-note-2/:4:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记2：透视投影","uri":"/tinyrenderer-note-2/#总结"},{"categories":["default"],"content":"最近Damus App很火，写一篇教程教大家如何在App中获得紫v图标认证。 ","date":"2023-02-04","objectID":"/nostr-nip05-verification/:0:0","series":null,"tags":["nostr","damus","vercel"],"title":"Nostr账号Nip05验证方法","uri":"/nostr-nip05-verification/#"},{"categories":["default"],"content":" NIP05简介NIP是Nostr改进提议Nostr Improvement Proposal，NIP05描述了一种账号验证方法。可以想象成telegram或者twitter上的蓝色V标记，在Damus里是一个紫V图标，客户端展示这个图标，就说明该用户通过了NIP05验证。 该验证由客户端发起，当发现用户设置了用户名和NIP05验证地址，会发送一个https请求。 比如用户名kirito和验证地址kirito@dogdogback.com，客户端会发送如下请求： text https://dogdogback.com/.well-known/nostr.json?name=kirito 如果验证成功，dogdogback.com应该返回如下结果： json { \"names\": { \"kirito\": \"2f7caa968b0ec9bacd55a07cfaf6206aab5a62387c76303c311db949dec8bc57\" } } 你也可以调用这个请求观察下返回: https://dogdogback.com/.well-known/nostr.json?name=kirito 客户端对比返回结果里的公钥和用户的公钥，如果一致则验证完成，Damus会在你头像后展示紫V图标。 ","date":"2023-02-04","objectID":"/nostr-nip05-verification/:1:0","series":null,"tags":["nostr","damus","vercel"],"title":"Nostr账号Nip05验证方法","uri":"/nostr-nip05-verification/#nip05简介"},{"categories":["default"],"content":" 验证方法有两种路线： 找提供验证服务的社区项目，直接用他们的服务，这个自己找吧，缺点是可能不稳定，也不受自己控制 用自己的域名进行验证，前提是你拥有一个域名的控制权，本文主要讲解这种方式 ","date":"2023-02-04","objectID":"/nostr-nip05-verification/:2:0","series":null,"tags":["nostr","damus","vercel"],"title":"Nostr账号Nip05验证方法","uri":"/nostr-nip05-verification/#验证方法"},{"categories":["default"],"content":" 静态文件如果你已经有自己的网站了，并且支持https，那么直接在你的网站根目录放置一个静态文件即可。 文件名为.well-known/nostr.json，内容写上你的用户名和公钥： text { \"names\": { \"kirito\": \"2f7caa968b0ec9bacd55a07cfaf6206aab5a62387c76303c311db949dec8bc57\" } } 可以写多行，为你的小伙伴也提供验证。 ","date":"2023-02-04","objectID":"/nostr-nip05-verification/:2:1","series":null,"tags":["nostr","damus","vercel"],"title":"Nostr账号Nip05验证方法","uri":"/nostr-nip05-verification/#静态文件"},{"categories":["default"],"content":" 云函数当然有更好的方式，而且不需要服务器和证书，下面介绍下我使用的方式：vercel云函数（你自己会搭服务或者有其他云函数也行，原理一样） 我之前写过一篇怎么用vercel云函数的文章，可以参考，当你弄好后，绑定自己的域名，就可以通过自己的域名访问云函数了，这是一个例子: https://dogdogback.com/api/list 代码如果不会写直接克隆我的仓库即可vercel-faas。 具体操作： 修改代码仓库中的文件vercel.json，添加NIP05接口的重定向，这样访问路径/.well-known/nostr.json?name=xxx的请求会被交给/api/entrypoint.go文件处理： json { \"trailingSlash\": false, \"rewrites\": [ { \"source\": \"/api/(.*)\", \"destination\": \"/api/entrypoint.go\" }, { \"source\": \"/.well-known/nostr.json\", \"destination\": \"/api/entrypoint.go\" } ] } 添加处理认证请求的路由，修改/api/entrypoint.go： go func registerRouter(r *gin.RouterGroup) { // ... r.GET(\"/.well-known/nostr.json\", handler.Cors, handler.NIP05) } 添加认证逻辑，修改/handler/handler.go: go func NIP05(c *gin.Context) { name2pubkey := map[string]string{ \"kirito\": \"2f7caa968b0ec9bacd55a07cfaf6206aab5a62387c76303c311db949dec8bc57\", // 可以在这里添加更多的账号，为你的朋友提供验证 // \"\u003cname1\u003e\":\"pubkey1\", // \"\u003cname2\u003e\":\"pubkey2\", } user := c.Query(\"name\") fmt.Println(\"nip05 verify request\", user) if v, ok := name2pubkey[user]; ok { resp := NIP05Resp{} resp.Names[user] = v c.JSON(http.StatusOK, resp) } c.Status(http.StatusNotFound) return } 把代码push到你的仓库，vercel会自动重新部署，然后用你的域名访问看看效果，这是我的： https://dogdogback.com/.well-known/nostr.json?name=kirito https://dogdogback.com/.well-known/nostr.json?name=shishi ","date":"2023-02-04","objectID":"/nostr-nip05-verification/:2:2","series":null,"tags":["nostr","damus","vercel"],"title":"Nostr账号Nip05验证方法","uri":"/nostr-nip05-verification/#云函数"},{"categories":["default"],"content":" 客户端设置以Damus举例，编辑资料，配置你的用户名和NIP05地址，就可以看到紫V图标了 到这里就成功了，有疑问可以评论区提。 ","date":"2023-02-04","objectID":"/nostr-nip05-verification/:2:3","series":null,"tags":["nostr","damus","vercel"],"title":"Nostr账号Nip05验证方法","uri":"/nostr-nip05-verification/#客户端设置"},{"categories":["default"],"content":" 一些提示 有些webapp请求是会受到浏览器跨域策略限制，在http返回header中设置Access-Control-Allow-Origin: *，我的代码中已经处理了，如果用静态文件的方式无法处理跨域。 如何获取hex格式的公钥？在Damus中长按你自己发送的信息，选择Copy Note JSON然后粘贴到一个地方，就能看到了。 vercel也是可以托管静态文件的，仓库里只留一个json文件就行。 富哥V我50 ","date":"2023-02-04","objectID":"/nostr-nip05-verification/:3:0","series":null,"tags":["nostr","damus","vercel"],"title":"Nostr账号Nip05验证方法","uri":"/nostr-nip05-verification/#一些提示"},{"categories":["program"],"content":"云玩家，全靠群友水群时候蹭经验，群友太强啦！ ","date":"2022-12-08","objectID":"/water-water/:0:0","series":null,"tags":["rust"],"title":"水群学习法","uri":"/water-water/#"},{"categories":["program"],"content":" 关于Box\u003cdyn Trait\u003e问题： 这里是box\u003cstruct\u003e -\u003e box\u003cdyn trait\u003e, 还是box\u003cstruct -\u003e dyn trait\u003e, 如果是后者，运行时怎么拿到size的？ rust fn thing_factory(thingtype: i32) -\u003e Box\u003cdyn DoThings\u003e { if thingtype == 1 { return Box::new(MyStruct1 {}); } if thingtype == 2 { return Box::new(MyStruct2 {}); } panic!() } 答案 box\u003cstruct\u003e -\u003e box\u003cdyn trait\u003e 土豆: Box\u003cdyn Trait\u003e == *mut dyn Trait == *mut T + *const metadata_of::\u003cT as Trait\u003e() 菜: 编译器会自动吧box\u003cT\u003e包装成box\u003cT + metadate\u003e对吧 土豆: 那是你亲手写的 as 菜: 其实return box\u003cT\u003e 就是 box\u003cT\u003e as box\u003cdyn trait\u003e，这样对吧 土豆: 照说是应该写出来 as _ 的 5大郎: Rust 能有限做 implicit conversion,因为 Rust implicit conversion 是非常少的,但是这里有 对魔忍 | Han: ","date":"2022-12-08","objectID":"/water-water/:1:0","series":null,"tags":["rust"],"title":"水群学习法","uri":"/water-water/#关于boxdyn-trait"},{"categories":["program"],"content":" 关于Variance协变、逆变、不变 相关背景可以看这篇blog：Rust Subtyping and Variance 疯狂转发到我收藏夹 κόσμος: 假设你有一个 List\u003cDog\u003e，Dog 是 Animal 的子型，你肯定可以传进 func(x: List\u003cAnimal\u003e) 如果这个 func 里修改 List\u003cAnimal\u003e 会发生什么？animals.clear(); animals.add(new Cat()); 你会发现你的 List\u003cDog\u003e 里出现了一个 Cat, 这就是为什么在 mutable 下不能 variant 一样的办法，把这个函数想象成另一个函数的参数。一个函数需要一个 callback: fn(Dog)-\u003eRet，那理应是可以传一个 fn(Animal)-\u003eRet 作为这个 callback 的， 因为这个 fn(Animal) -\u003e Ret 一定可以处理 Dog 数据。所以 fn(Animal)-\u003eRet \u003c fn(Dog)-\u003eRet， 而 Dog \u003c Animal，所以函数参数这样的一个型构造是逆变的 nicball: 你可以把fn()→Cat当成fn()→Animal 你可以把fn(Animal)→()当成fn(Cat)→() 所以函数对返回类型协变，对参数类型逆变 或者把他当成getter setter 可以想成读的时候协变，写的时候逆变 那可变的数据结构就只能不变了 ","date":"2022-12-08","objectID":"/water-water/:2:0","series":null,"tags":["rust"],"title":"水群学习法","uri":"/water-water/#关于variance"},{"categories":["program"],"content":" 屌图 ","date":"2022-12-08","objectID":"/water-water/:3:0","series":null,"tags":["rust"],"title":"水群学习法","uri":"/water-water/#屌图"},{"categories":["program"],"content":"上一篇结尾渲染出了光照下的模型： 但是这个模型看起来有些奇怪，尤其是嘴巴的部分。因为渲染时候仅仅是按照从模型中读取的顶点信息，将三角形一个个的画了出来，但是并没有考虑三角形的遮挡关系。如果我们先画出了面部的三角形，然后又画了脑后勺的三角形，那最终展示出来的图形就会像上面一样很奇怪，原因是我们没有处理深度信息。 ","date":"2022-07-23","objectID":"/tinyrenderer-note-1/:0:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记1：Z-buffer和纹理插值","uri":"/tinyrenderer-note-1/#"},{"categories":["program"],"content":" Y-buffer渲染模型是将3维映射到2维，先来考虑将2维映射到1维该怎么做。目标是把几条2d空间的线段，映射到x轴上。 如果我们以一维的视角从上往下看，看到的应该是一条彩色的线段，写一个函数来绘制这个线段： rust pub fn resterize\u003cI: GenericImage\u003e( mut a: glm::IVec2, mut b: glm::IVec2, image: \u0026mut I, color: I::Pixel, ) { if (a.x - b.x).abs() \u003c (a.y - b.y).abs() { swap(\u0026mut a.x, \u0026mut a.y); swap(\u0026mut b.x, \u0026mut b.y); } for x in a.x..=b.x { for i in 0..image.height() { image.put_pixel(x as u32, i, color); } } } { draw::resterize(glm::ivec2(330, 463), glm::ivec2(594, 200), \u0026mut image, BLUE); draw::resterize(glm::ivec2(120, 434), glm::ivec2(444, 400), \u0026mut image,GREEN); draw::resterize(glm::ivec2(20, 34), glm::ivec2(744, 400), \u0026mut image, RED); } 绘制出来的线段长这样： 明显不太对，只看到了红色，因为我们是最后画的红色线段，红色线段又最长，所以直接覆盖了另外两条。 为了正确画出线段，我们需要知道每个像素的深度信息。在这个例子中，y坐标更大的像素不能被更小的像素覆盖。 引入y-buffer： rust pub fn resterize\u003cI: GenericImage\u003e( mut a: glm::IVec2, mut b: glm::IVec2, image: \u0026mut I, ybuffer: \u0026mut [i32], color: I::Pixel, ) { if (a.x - b.x).abs() \u003c (a.y - b.y).abs() { swap(\u0026mut a.x, \u0026mut a.y); swap(\u0026mut b.x, \u0026mut b.y); } for x in a.x..=b.x { let t = (x - a.x) as f32 / (b.x - a.x) as f32; let y = a.y as f32 * (1. - t) + b.y as f32 * t; if ybuffer[x as usize] \u003c y as i32 { ybuffer[x as usize] = y as i32; for i in 0..image.height() { image.put_pixel(x as u32, i, color); } } } } { let mut ybuffer = vec![0; 800]; draw::resterize(glm::ivec2(330, 463), glm::ivec2(594, 200), \u0026mut image, ybuffer, BLUE); draw::resterize(glm::ivec2(120, 434), glm::ivec2(444, 400), \u0026mut image, ybuffer, GREEN); draw::resterize(glm::ivec2(20, 34), glm::ivec2(744, 400), \u0026mut image, ybuffer, RED); } 现在得到了正确的线段颜色： 详细代码见这里f23d87e4e34700767da9c6754d2b0aa6b37fe58f ","date":"2022-07-23","objectID":"/tinyrenderer-note-1/:1:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记1：Z-buffer和纹理插值","uri":"/tinyrenderer-note-1/#y-buffer"},{"categories":["program"],"content":" Z-buffer回到3d，为了能映射到2d屏幕上，zbuffer需要两个维度： rust let zbuffer = vec![0; width*height]; 虽然需要的数组是二维的，但可以用一维数组来表示，只需要简单的变换: rust let idx = x + y*width; let x = idx % width; let y = idx / wdith; 与ybuffer唯一的不同是如何计算z值，前面y值是这样计算的: rust let y = p0.y*(1-t) + p1.y*t 上面的式子可以看作两个向量的点积: $(y_1, y_2) * (1-t, t)$，$(1-t, t)$ 其实是点x关于线段p0p1的重心坐标。 所以对于z值，可以用三角形三个顶点z坐标和重心坐标计算: $(z_1,z_2,z_3)*(1-u-v, u, v)$ 在模型渲染的代码中引入zbuffer： rust pub fn triangle\u003cI: GenericImage\u003e( //... zbuffer: \u0026mut [f32], ) { //... for px in bboxmin.x as i32..=bboxmax.x as i32 { for py in bboxmin.y as i32..=bboxmax.y as i32 { let bc_screen = barycentric(t0, t1, t2, glm::vec3(px as f32, py as f32, 0.)); if bc_screen.x \u003c 0. || bc_screen.y \u003c 0. || bc_screen.z \u003c 0. { continue; } // 计算z值 let pz = glm::dot(glm::vec3(t0.z, t1.z, t2.z), bc_screen); let idx = px + py * image.width() as i32; if zbuffer[idx as usize] \u003c= pz { zbuffer[idx as usize] = pz; image.put_pixel(px as u32, py as u32, color); } } } } { let mut zbuffer = vec![f32::MIN; (image.width() * image.height()) as usize]; // 注意一定初始化为最小值 //... for arr in model.indices.chunks(3) { //... draw::triangle(sa,sb,sc,\u0026mut image, Rgba([(255. * intensity) as u8, (255. * intensity) as u8 ,(255. * intensity) as u8, 255]), \u0026mut zbuffer, ); } } 这样就能正确渲染了，效果如下： 详细代码见这里7bd6b1b50f602336a3fbc8d345399c5f9872a19d ","date":"2022-07-23","objectID":"/tinyrenderer-note-1/:2:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记1：Z-buffer和纹理插值","uri":"/tinyrenderer-note-1/#z-buffer"},{"categories":["program"],"content":" 纹理前面渲染的模型没有皮肤，都是用白色的强度来表示光照，接下来要进行纹理插值，通过纹理坐标算出每个像素应该是什么颜色。 在模型文件里，有些行是这样的格式: vt u v 0.0 它给出了一个纹理(顶点)坐标。 这些行f x/x/x x/x/x x/x/x 描述了一个面，每组数据(按/分割)中间的x，就是三角形该顶点的纹理坐标编号。 根据纹理坐标对三角形进行插值，乘以纹理图像的宽度-高度，就会得到要渲染的颜色。 作者是通过扫描线的方式计算纹理坐标的，我尝试了一下用重心坐标来计算，zbuffer那里给了我启发，没想到真的可以，体会下重心坐标的神奇。 首先从这里可以下载作者提供的纹理图片。先读取图片： rust let mut diffus = image::open(\"obj/african_head/african_head_diffuse.tga\").unwrap().to_rgba8(); let diffuse = flip_vertical_in_place(\u0026mut diffus); 因为我们之前翻转了y轴，所以也需要将纹理图片翻转一下。 接下来写一个新的函数来画三角形。上面zbuffer部分，我们用重心坐标算出了z值，现在我们有了三角形三个顶点的纹理坐标，同样可以用重心坐标 算出当前位置的纹理坐标： $$ \\begin{aligned} x \u0026= (x_1, x_2, x_3) * barycentric \\\\ y \u0026= (y_1, y_2, y_3) * barycentric \\end{aligned} $$ 根据上面式子算出坐标后，放大到纹理图片比例即可： rust pub fn triangle_with_texture\u003cI: GenericImage\u003cPixel = Rgba\u003cu8\u003e\u003e\u003e( a: glm::Vec3, // 模型顶点 b: glm::Vec3, c: glm::Vec3, ta: glm::Vec3, // 纹理坐标顶点 tb: glm::Vec3, tc: glm::Vec3, image: \u0026mut I, intensity: f32, zbuffer: \u0026mut [f32], diffuse: \u0026I, // 纹理图片 ) { //... for px in bboxmin.x as i32..=bboxmax.x as i32 { for py in bboxmin.y as i32..=bboxmax.y as i32 { let bc_screen = barycentric(a, b, c, glm::vec3(px as f32, py as f32, 0.)); if bc_screen.x \u003c 0. || bc_screen.y \u003c 0. || bc_screen.z \u003c 0. { continue; } // 计算z值 let pz = glm::dot(glm::vec3(a.z, b.z, c.z), bc_screen); // 计算纹理坐标 let tx = glm::dot(glm::vec3(ta.x, tb.x, tc.x), bc_screen) * diffuse.width() as f32; let ty = glm::dot(glm::vec3(ta.y, tb.y, tc.y), bc_screen) * diffuse.height() as f32; let idx = px + py * image.width() as i32; let pi: Rgba\u003cu8\u003e = diffuse.get_pixel(tx as u32, ty as u32); // 获取像素 if zbuffer[idx as usize] \u003c= pz { zbuffer[idx as usize] = pz; image.put_pixel( px as u32, py as u32, Rgba([ (pi.0[0] as f32 * intensity) as u8, (pi.0[1] as f32 * intensity) as u8, (pi.0[2] as f32 * intensity) as u8, 255, ]), ); } } } } 效果如下： 详细代码见这里dd09711edb4fa1dcb129ccce64959a0fec749f42 ","date":"2022-07-23","objectID":"/tinyrenderer-note-1/:3:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记1：Z-buffer和纹理插值","uri":"/tinyrenderer-note-1/#纹理"},{"categories":["program"],"content":"这篇是自己学习tinyrenderer的笔记，不务正业系列。 tinyrenderer教程地址：https://github.com/ssloy/tinyrenderer/wiki 作者教程是用cpp实现的，我用rust来学，列一下用到的库： image - 这是个图片库，充当画布，控制每个像素的颜色，生成图片 obj-rs - 解析obj文件的库，关于obj文件可以看Wavefront OBJ文件格式，里面存的是一些模型顶点 glm - 数学库，比如坐标表示，计算向量点乘、叉乘，矩阵运算 ","date":"2022-01-01","objectID":"/tinyrenderer-note-0/:0:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记0：画线和三角以及面剔除","uri":"/tinyrenderer-note-0/#"},{"categories":["program"],"content":" 准备画布用image库操作图片的每个像素，生成图片： rust use image::{imageops::flip_vertical_in_place, ImageBuffer, Rgba}; const WHITE: Rgba\u003cu8\u003e = Rgba([255, 255, 255, 255]); const RED: Rgba\u003cu8\u003e = Rgba([255, 0, 0, 255]); fn main() { let (width, height) = (400, 400); let mut image = ImageBuffer::\u003cRgba\u003cu8\u003e, _\u003e::from_pixel(width, height, BLACK); for x in 0..200 { for y in 0..200 { image.put_pixel(x, y, RED); } } flip_vertical_in_place(\u0026mut image); // 垂直反转，因为默认坐标原点在左上角，反转后在左下角 image.save(\"a.png\").unwrap(); } ","date":"2022-01-01","objectID":"/tinyrenderer-note-0/:1:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记0：画线和三角以及面剔除","uri":"/tinyrenderer-note-0/#准备画布"},{"categories":["program"],"content":" 画线画线比较简单，思路是对于线段ab，从a出发到b一路画点，x坐标每次移动一个像素，然后计算y坐标应该移动多少，还有一些细节直接看代码： rust fn line\u003cI: GenericImage\u003e(mut a: glm::IVec2, mut b: glm::IVec2, image: \u0026mut I, color: I::Pixel) { let mut steep = false; if (a.x - b.x).abs() \u003c (a.y - b.y).abs() { // 如果这条线是陡峭的，就交换x，y让它躺平 swap(\u0026mut a.x, \u0026mut a.y); swap(\u0026mut b.x, \u0026mut b.y); steep = true; } if a.x \u003e b.x { // make it left−to−right swap(\u0026mut a, \u0026mut b); } let dx = b.x - a.x; let dy = b.y - a.y; let derror = (dy as f64 / dx as f64).abs(); let mut error = 0.0; let mut y = a.y; for x in a.x..=b.x { if steep { image.put_pixel(y as u32, x as u32, color); } else { image.put_pixel(x as u32, y as u32, color); } error += derror; if error \u003e 0.5 { y += if b.y \u003e a.y { 1 } else { -1 }; error -= 1.0; } } } 如果这条线很陡峭，那么x坐标移动一个像素，对应的y坐标可能要移动好几个像素，画出来不连续，所以让它躺平。 然后我们从左到右画，dy/dx算出斜率，比如斜率是0.5，那么x移动一个像素，y应该移动0.5个像素。 因为像素不能分割，所以按照四舍五入的方式，y的变化积攒到一定量再移动一个单位。 看着已经很完美了，但是里面有浮点数，可以根据简单的代换，消除浮点数：我们让derror = derror' * 2dx = 2dy，那么error \u003e 0.5变成error \u003e dx，error -= 1.0变成error -= 2dx，这样一来就全是整数计算： rust fn line\u003cI: GenericImage\u003e(mut a: glm::IVec2, mut b: glm::IVec2, image: \u0026mut I, color: I::Pixel) { let mut steep = false; if (a.x - b.x).abs() \u003c (a.y - b.y).abs() { // if the line is steep, we transpose the image swap(\u0026mut a.x, \u0026mut a.y); swap(\u0026mut b.x, \u0026mut b.y); steep = true; } if a.x \u003e b.x { // make it left−to−right swap(\u0026mut a, \u0026mut b); } let dx = b.x - a.x; let dy = b.y - a.y; let derror = dy.abs() * 2; let mut error = 0; let mut y = a.y; for x in a.x..=b.x { if steep { image.put_pixel(y as u32, x as u32, color); } else { image.put_pixel(x as u32, y as u32, color); } error += derror; if error \u003e dx { y += if b.y \u003e a.y { 1 } else { -1 }; error -= dx * 2; } } } 随便画几条 能画线，就能画三角形框了，把作者提供的obj文件画出来： rust fn main() { let (width, height) = (800, 800); let mut image = ImageBuffer::\u003cRgba\u003cu8\u003e, _\u003e::from_pixel(width, height, BLACK); let input = BufReader::new(File::open(\"a.obj\").unwrap()); let model: obj::Obj = obj::load_obj(input).unwrap(); for arr in model.indices.chunks(3) { for i in 0..3 { let v0 = model.vertices.get(arr[i] as usize).unwrap().position; let v1 = model .vertices .get(arr[(i + 1) % 3] as usize) .unwrap() .position; let x0 = ((v0[0] + 1.0) * (width - 1) as f32 / 2.0) as i32; let y0 = ((v0[1] + 1.0) * (height - 1) as f32 / 2.0) as i32; let x1 = ((v1[0] + 1.0) * (width - 1) as f32 / 2.0) as i32; let y1 = ((v1[1] + 1.0) * (height - 1) as f32 / 2.0) as i32; draw::line(glm::ivec2(x0, y0), glm::ivec2(x1, y1), \u0026mut image, WHITE); } } flip_vertical_in_place(\u0026mut image); image.save(\"a.png\").unwrap(); } 详细代码见这里9f1f2564d8400ed296a5ee6ce9cb23e44203fd3c ","date":"2022-01-01","objectID":"/tinyrenderer-note-0/:2:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记0：画线和三角以及面剔除","uri":"/tinyrenderer-note-0/#画线"},{"categories":["program"],"content":" 填充三角形","date":"2022-01-01","objectID":"/tinyrenderer-note-0/:3:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记0：画线和三角以及面剔除","uri":"/tinyrenderer-note-0/#填充三角形"},{"categories":["program"],"content":" 扫描线扫描线填充三角形的方式和这个方法的名字一样，一行一行的画直线，首先把三角形的三个点按y坐标从低到高排序，最高点和最低点连线是红色，中间点和其他两个点连线是绿色： 这样中间点就将三角形分为了上下两部分，分别画出两部分，就得到了一个完整的三角形： rust pub fn triangle\u003cI: GenericImage\u003e( mut t0: glm::Vec2, mut t1: glm::Vec2, mut t2: glm::Vec2, image: \u0026mut I, color: I::Pixel, ) { if t0.y == t1.y \u0026\u0026 t0.y == t2.y { return; } // 按y坐标排序，从低到高 t0 t1 t2 if t0.y \u003e t1.y { swap(\u0026mut t0, \u0026mut t1); } if t0.y \u003e t2.y { swap(\u0026mut t0, \u0026mut t2); } if t1.y \u003e t2.y { swap(\u0026mut t1, \u0026mut t2); } let total_height = t2.y - t0.y; // 下半部分 // y in t0.y -\u003e t1.y for y in t0.y as i32..=t1.y as i32 { let segment_height = t1.y - t0.y + 1.; let alpha = (y as f32 - t0.y) as f32 / total_height as f32; let beta = (y as f32 - t0.y) as f32 / segment_height as f32; // be careful with divisions by zero let mut a = t0 + (t2 - t0) * alpha; let mut b = t0 + (t1 - t0) * beta; if a.x \u003e b.x { swap(\u0026mut a, \u0026mut b); } for j in a.x as i32..=b.x as i32 { image.put_pixel(j as u32, y as u32, color); } } // 上半部分 for y in t1.y as i32..=t2.y as i32 { let segment_height = t2.y - t1.y + 1.; let alpha = (y as f32 - t0.y) / total_height; let beta = (y as f32 - t1.y) / segment_height; let mut a = t0 + (t2 - t0) * alpha; let mut b = t1 + (t2 - t1) * beta; if a.x \u003e b.x { swap(\u0026mut a, \u0026mut b); } for j in a.x as i32..=b.x as i32 { image.put_pixel(j as u32, y as u32, color); } } } 将代码整理一下，同时画出两部分： rust pub fn triangle\u003cI: GenericImage\u003e( mut t0: glm::Vec2, mut t1: glm::Vec2, mut t2: glm::Vec2, image: \u0026mut I, color: I::Pixel, ) { if t0.y == t1.y \u0026\u0026 t0.y == t2.y { return; } // 按y坐标排序 if t0.y \u003e t1.y { swap(\u0026mut t0, \u0026mut t1); } if t0.y \u003e t2.y { swap(\u0026mut t0, \u0026mut t2); } if t1.y \u003e t2.y { swap(\u0026mut t1, \u0026mut t2); } let total_height = t2.y - t0.y; // 同时画两部分 for i in 0..=total_height as i32 { let second_half = if i \u003e (t1.y - t0.y) as i32 || t1.y == t0.y { true } else { false }; let segment_height = if second_half { t2.y - t1.y } else { t1.y - t0.y }; let alpha = i as f32 / total_height as f32; let beta = (i as f32 - if second_half { t1.y - t0.y } else { 0. }) as f32 / segment_height as f32; // be careful with divisions by zero let mut a = t0 + (t2 - t0) * alpha; let mut b = if second_half { t1 + (t2 - t1) * beta } else { t0 + (t1 - t0) * beta }; if a.x \u003e b.x { swap(\u0026mut a, \u0026mut b); } for j in a.x as i32..=b.x as i32 { image.put_pixel(j as u32, (t0.y + i as f32) as u32, color); } } } 详细代码见这里37bc2e71b0fe47a37da314987c69f43caf9027c1 ","date":"2022-01-01","objectID":"/tinyrenderer-note-0/:3:1","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记0：画线和三角以及面剔除","uri":"/tinyrenderer-note-0/#扫描线"},{"categories":["program"],"content":" 重心坐标扫描线是为单线程CPU编程设计的老式方法，显卡有很多核心，这种方式发挥不了显卡的威力。更好的方式是对于每个像素，直接判断其是否属于三角形内部。 首先需要了解什么是重心坐标，可以看这个文章，总结来讲： 如果点P再三角形ABC内部，必定唯一存在三个数w1,w2,w3，满足： w1+w2+w3=1 且 w1,w2,w3非负数（负数说明不在内部） P=w1*A+w2*B+w3*C （即P表示成A,B,C的线性组合） 则(w1,w2,w3)就称为此三角形上P点的（归一化）重心坐标。 计算的话，教程里的更好理解些，w1,w2,w3表示成(1-u-v,u,v)： $$ \\begin{aligned} P \u0026= (1-u-v)A + uB + vC \\\\ \u0026= A + u(B-A) + v(C-A) \\\\ \u0026= A + u\\overrightarrow{AB} + v\\overrightarrow{AC} \\end{aligned} $$ 然后再把P移过去，就得到： $$ u\\overrightarrow{AB} + v\\overrightarrow{AC} + \\overrightarrow{PA} = 0 $$ 再把向量展开成坐标值表示： $$ \\begin{cases} u\\overrightarrow{AB}_x + v\\overrightarrow{AC}_x + \\overrightarrow{PA}_x \u0026= 0\\\\ u\\overrightarrow{AB}_y + v\\overrightarrow{AC}_y + \\overrightarrow{PA}_y \u0026= 0\\\\ \\end{cases} $$ 然后作者上面的式子写成了矩阵的形式： $$ \\begin{cases} \\begin{bmatrix} u \u0026 v \u00261 \\end{bmatrix} \\begin{bmatrix} \\overrightarrow{AB}_x \\\\ \\overrightarrow{AC}_x \\\\ \\overrightarrow{PA}_x \\end{bmatrix} \u0026= 0 \\\\ \\\\ \\begin{bmatrix} u \u0026 v \u00261 \\end{bmatrix} \\begin{bmatrix} \\overrightarrow{AB}_y \\\\ \\overrightarrow{AC}_y \\\\ \\overrightarrow{PA}_y \\end{bmatrix} \u0026= 0 \\end{cases} $$ 其实不转换成矩阵也行，这一步无所谓。观察上面的式子，如果把参与计算的数值看作三维坐标，就会变得很简单，高中知识就够了： $$ \\begin{aligned} (u,v,1)\\ \u0026*\\ (x_1,x_2,x_3) \u0026= 0\\\\ (u,v,1)\\ \u0026*\\ (y_1,y_2,y_3) \u0026= 0 \\end{aligned} $$ 这不就两个向量的点积么，复习一下： 向量$A*B=|A||B|\\cos\\theta$，什么时候结果为零呢：当两个向量垂直的时候结果为0 回到式子, (u,v,1)和(x1,x2,x3)、(y1,y2,y3)必须同时垂直。换句话说，给定(x1,x2,x3)、(y1,y2,y3)两向量，找到同时垂直他们的向量即可。 继续高中知识就足够了，回忆下两个向量的叉积： 对两个向量做叉积能得到一个新的向量，这个向量同时垂直ab且方向与ab的位置有关。 所以，求(u,v,1)的值，只需要： $$ (\\overrightarrow{AB}_x , \\overrightarrow{AC}_x , \\overrightarrow{PA}_x) \\times (\\overrightarrow{AB}_y , \\overrightarrow{AC}_y , \\overrightarrow{PA}_y) $$ 代码： rust // 求重心坐标 fn barycentric(a: glm::IVec2, b: glm::IVec2, c: glm::IVec2, p: glm::IVec2) -\u003e glm::Vec3 { let ab = b - a; let ac = c - a; let pa = a - p; let u = glm::cross( glm::vec3(ab.x as f32, ac.x as f32, pa.x as f32), glm::vec3(ab.y as f32, ac.y as f32, pa.y as f32), ); // 因为传入坐标都是整数，所以z小于1就意味着z是0，这种情况是因为三角形三个顶点在一条直线上，不是合法三角形 // 这种情况返回一个负值 if u.z.abs() \u003c 1. { return glm::vec3(-1., 1., 1.); } // vec(x,y,z)/z -\u003e (u,v,1) -\u003e (1-u-v, u, v) return glm::vec3(1. - ((u.x + u.y) / u.z) as f32, u.x / u.z, u.y / u.z); } 有了求重心坐标的函数后，只需要枚举坐标，用当前坐标与三角形顶点算重心坐标，如果重心坐标中任意一个值为负数，说明当前坐标不在三角形中，反之则说明该坐标在三角形内： rust pub fn triangle_with_barycentric\u003cI: GenericImage\u003e( t0: glm::IVec2, t1: glm::IVec2, t2: glm::IVec2, image: \u0026mut I, color: I::Pixel, ) { let bboxmin = glm::ivec2(t0.x.min(t1.x).min(t2.x), t0.y.min(t1.y).min(t2.y)); let bboxmax = glm::ivec2(t0.x.max(t1.x).max(t2.x), t0.y.max(t1.y).max(t2.y)); let a = t0[1]; for px in bboxmin.x..=bboxmax.x { for py in bboxmin.y..=bboxmax.y { let bc_screen = barycentric(t0, t1, t2, glm::ivec2(px, py)); if bc_screen.x \u003c 0. || bc_screen.y \u003c 0. || bc_screen.z \u003c 0. { continue; } image.put_pixel(px as u32, py as u32, color); } } } 详细代码见这里a1d23998dccac6a3f42130e3d57f21c399fab0d7 ","date":"2022-01-01","objectID":"/tinyrenderer-note-0/:3:2","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记0：画线和三角以及面剔除","uri":"/tinyrenderer-note-0/#重心坐标"},{"categories":["program"],"content":" 渲染阴影以及面剔除把作者给的obj模型的每个三角形画出来，首先将obj文件里给的坐标转换为屏幕坐标，并随机给一个颜色： rust for arr in model.indices.chunks(3) { let (a, b, c) = ( model.vertices.get(arr[0] as usize).unwrap().position, model.vertices.get(arr[1] as usize).unwrap().position, model.vertices.get(arr[2] as usize).unwrap().position, ); let (a, b, c) = ( glm::vec3(a[0], a[1], a[2]), glm::vec3(b[0], b[1], b[2]), glm::vec3(c[0], c[1], c[2]), ); let (sa, sb, sc) = ( glm::ivec2( (((a.x + 1.) * (width - 1) as f32) / 2.) as i32, (((a.y + 1.) * (height - 1) as f32) / 2.) as i32, ), glm::ivec2( (((b.x + 1.) * (width - 1) as f32) / 2.) as i32, (((b.y + 1.) * (height - 1) as f32) / 2.) as i32, ), glm::ivec2( (((c.x + 1.) * (width - 1) as f32) / 2.) as i32, (((c.y + 1.) * (height - 1) as f32) / 2.) as i32, ), ); draw::triangle_with_barycentric( sa, sb, sc, \u0026mut image, Rgba([ rand::random::\u003cu8\u003e() % 255, rand::random::\u003cu8\u003e() % 255, rand::random::\u003cu8\u003e() % 255, 255, ]), ); } 这里有一个问题，模型中的每个三角形都被画出来了，正常来讲只有面对我们的三角形才应该被画出来，这就涉及到了面剔除，接下来给模型打上光照，同时进行面剔除。 首先看光照，把一束光看作一个向量，然后再求出一个三角形的面向（三角形两条边做叉积，能得到方向垂直于两条边的向量）。面向与光照方向越接近，光照强度就越大。 把面向和光照两个向量再做点积，点积如果是负的，说明该面向背对光源，如果光源方向是我们屏幕外向屏幕内，那么这个面我们是看不见的，应该被剔除。 rust let n = glm::cross(c - a, b - a); // 计算三角形面向 let n = glm::normalize(n); let intensity = glm::dot(light_dir, n); if intensity \u003e 0. { // 既是光照强度，也能当面剔除用，小于0说明背对我们 draw::triangle_with_barycentric( sa, sb, sc, \u0026mut image, Rgba([ (255. * intensity) as u8, (255. * intensity) as u8, (255. * intensity) as u8, 255, ]), ); } note: 模型文件中三角形的坐标是有顺序的，一般顺时针或逆时针排列，从而方便我们计算面向 详细代码见这里990567294a9b58fb4a66a65704640ff0710bd522 ","date":"2022-01-01","objectID":"/tinyrenderer-note-0/:4:0","series":null,"tags":["graphics","tinyrenderer"],"title":"TinyRenderer笔记0：画线和三角以及面剔除","uri":"/tinyrenderer-note-0/#渲染阴影以及面剔除"},{"categories":["program"],"content":"2020年2月春节期间我刷完过一遍LearnOpenGL，这是一个很好的入门openGL良心教程，一直没时间记录。最近打游戏荒废了好久，刚好换了电脑，重新装下环境顺便记录下LearnOpenGL的环境搭建。 教程中使用的环境是Visual Studios + CMake + MSVC，我没用过也没安装过Visual Studio。所以我选择的环境是vscode + CMake + MinGW-w64，在linux直接gcc就行了，mac用gcc、clang都可以。这样的好处是在win、linux、mac上都能搭建这套环境。 ","date":"2021-12-12","objectID":"/learn-opengl-env/:0:0","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#"},{"categories":["program"],"content":" 工具安装我的系统是win，因为要打游戏（ vscode 就不多说了，用其他编辑器/IDE也行 ","date":"2021-12-12","objectID":"/learn-opengl-env/:1:0","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#工具安装"},{"categories":["program"],"content":" mingw-w64编译器肯定是必须的，我没用过msvc，只用过gcc，mingw-w64就是win上的gcc。 下载地址：https://www.mingw-w64.org/downloads/ 双击打开，选择native windows，x86_64，如果是32位系统则选i686。设置好安装目录 直接点process安装 完成后，安装目录的bin文件夹里就有gcc了 最后吧bin目录添加到系统环境变量PATH里：此电脑-属性-高级系统设置-环境变量-PATH-添加D:\\app\\mingw-w64\\bin ","date":"2021-12-12","objectID":"/learn-opengl-env/:1:1","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#mingw-w64"},{"categories":["program"],"content":" cmakec++在编译的时候，需要引用各种头文件，链接这个那个的各种动态库、静态库。项目复杂的时候编译会很麻烦，cmake相当于一个构建系统，用不怎么简洁的语法，描述如何编译目标，帮我们生成makefile文件，自动编译项目。 下载地址：https://cmake.org/download/，选择.msi安装 一路点next，安装路径无所谓，记得加入PATH就行 完事检查下安装成功 ","date":"2021-12-12","objectID":"/learn-opengl-env/:1:2","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#cmake"},{"categories":["program"],"content":" 依赖库安装需要用到以下库： GLFW - 负责创建OpenGL上下文并显示窗口 GLAD - 查找openGL函数指针 ","date":"2021-12-12","objectID":"/learn-opengl-env/:2:0","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#依赖库安装"},{"categories":["program"],"content":" GLFW 在画出出色的效果之前，首先要做的就是创建一个OpenGL上下文(Context)和一个用于显示的窗口。然而，这些操作在每个系统上都是不一样的，OpenGL有目的地从这些操作抽象(Abstract)出去。这意味着我们不得不自己处理创建窗口，定义OpenGL上下文以及处理用户输入。 GLFW就是帮我们在不同平台做这个事情 获取源代码：www.glfw.org/download.html，下载source package 记得看看官方编译指南https://www.glfw.org/docs/latest/compile.html 解压后进入目录 在此目录执行cmake -S . -B build -G \"MinGW Makefiles\" -DBUILD_SHARED_LIBS=ON，其中-S指定源码所在目录，-B指定构建/输出目录，-G指定我们是给MinGW生产makefile，最后一个参数是告诉CMake，我们要动态库 最后，进入build/目录，执行mingw32-make.exe -j4，-j4指定我们用4个cpu核心，注意由于我们装的mingw，所以make命令变成了mingw32-make.exe 完事后我们就得到了lib文件 GLFW就编译完了，关键目录只有两个 头文件path\\to\\glfw-3.3.6\\include lib文件path\\to\\glfw-3.3.6\\build\\src 在path\\to\\glfw-3.3.6\\build目录执行mingw32-make.exe install(需要管理员权限)，文件会被安装到C:/Program Files (x86)/GLFW/下 最后手动复制glfw3.dll到C:\\Windows\\System32下，不然运行程序会报找不到dll，其他库类似 ","date":"2021-12-12","objectID":"/learn-opengl-env/:2:1","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#glfw"},{"categories":["program"],"content":" GLAD OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。 GLAD会帮我们找到函数位置 使用在线服务定制我们需要的源代码：https://glad.dav1d.de/ 下载解压后，include目录里是俩头文件，src目录里面就一个glad.c 这个glad.c后面会直接和程序一起参与编译 到这里就可以创建项目了 ","date":"2021-12-12","objectID":"/learn-opengl-env/:2:2","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#glad"},{"categories":["program"],"content":" 创建项目建立一个名为LearnOpenGL的文件夹作为项目根目录。整个项目结构是这样的： root(LearnOpenGL) CMakeLists.txt - cmake构建文件 cmake/modules/ - 存放cmake自动查找库的find文件 include/ - 存放头文件 src/ - 存放源代码 可以参考：https://github.com/kirito41dd/LearnOpenGL ","date":"2021-12-12","objectID":"/learn-opengl-env/:3:0","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#创建项目"},{"categories":["program"],"content":" 创建窗口先给出目录细节再详细说，所有参与文件如下： CMakeLists.txt - cmake构建文件 cmake/modules/ - 存放cmake自动查找库的find文件 FindGLFW3.cmake - 负责自动查找glfw的头文件路径和lib路径 include/ - 存放头文件 glad.c - 把安装GLAD时的文件复制过来 glad/ - 安装GLAD时的头文件目录，复制过来 glad.h KHR/ - 安装GLAD时的头文件目录，复制过来 khrplatform.h src/ - 存放源代码 start/ - 存放LearnOpenGL教程第一部分源码 CMakeLists.txt - 子目录构建文件 HelloWindow.cpp - 创建窗口示例程序 1.主CMakeLists.txt根目录下的CMakeLists.txt文件是引导cmake的入口，主要做一些项目设置，和头文件，lib等查找工作，详细如下： cmake cmake_minimum_required(VERSION 2.9) # 指定cmake最小版本 project(learnopengl) # 设置项目名 # 依赖环境 # ------------------------------------------------------------------------------ set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_SOURCE_DIR}/cmake/modules/\") find_package(GLFW3 REQUIRED) include_directories(${GLFW3_INCLUDE_DIR}) add_library(glad include/glad.c) # ------------------------------------------------------------------------------ include_directories(./include) # 添加头文件搜索目录 # 子目录 add_subdirectory(src/start) # 子目录也会有CMakeLists.txt文件，环境是相通的 主要来看依赖环境部分： set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_SOURCE_DIR}/cmake/modules/\") 这句是往CMAKE_MODULE_PATH里追加一个目录， 这些目录里存放着各种find文件，命名为Find${LIB}.cmake find_package(GLFW3 REQUIRED)表示调用FindGLFW3.cmake查找GLFW3的头文件和lib，而且是必须找到，否则构建终止。 如果找到了，会设置GLFW3_XXX等一系列变量 include_directories(${GLFW3_INCLUDE_DIR})，find执行成功才会执行这句，变量GLFW3_INCLUDE_DIR里存放着GLFW头文件的路径，然后添加头文件搜索目录 add_library(glad include/glad.c)声明一个名为glad的lib，后面可以指定链接它，glad.c就会参与编译 2.FindGLFW.cmake看下项目里GLFW的搜索文件cmake/modules/FindGLFW3.cmake，这个文件可以在网上找到很多例子，cmake本身也会预装很多find文件。 cmake set( _glfw3_HEADER_SEARCH_DIRS \"/usr/include\" \"/usr/local/include\" \"${CMAKE_SOURCE_DIR}/includes\" \"C:/Program Files (x86)/glfw/include\" \"C:/Program Files (x86)/GLFW/include\") # 注意这里，就是我们安装的目录 set( _glfw3_LIB_SEARCH_DIRS \"/usr/lib\" \"/usr/local/lib\" \"${CMAKE_SOURCE_DIR}/lib\" \"C:/Program Files (x86)/glfw/lib-msvc110\" \"C:/Program Files (x86)/GLFW/lib\") # 注意这里 # Check environment for root search directory set( _glfw3_ENV_ROOT $ENV{GLFW3_ROOT} ) if( NOT GLFW3_ROOT AND _glfw3_ENV_ROOT ) set(GLFW3_ROOT ${_glfw3_ENV_ROOT} ) endif() # Put user specified location at beginning of search if( GLFW3_ROOT ) list( INSERT _glfw3_HEADER_SEARCH_DIRS 0 \"${GLFW3_ROOT}/include\" ) list( INSERT _glfw3_LIB_SEARCH_DIRS 0 \"${GLFW3_ROOT}/lib\" ) endif() # Search for the header FIND_PATH(GLFW3_INCLUDE_DIR \"GLFW/glfw3.h\" # 头文件目录的变量 PATHS ${_glfw3_HEADER_SEARCH_DIRS} ) # Search for the library FIND_LIBRARY(GLFW3_LIBRARY NAMES glfw3 glfw glfw3dll PATHS ${_glfw3_LIB_SEARCH_DIRS} ) INCLUDE(FindPackageHandleStandardArgs) FIND_PACKAGE_HANDLE_STANDARD_ARGS(GLFW3 DEFAULT_MSG GLFW3_LIBRARY GLFW3_INCLUDE_DIR) # 注意这里 IF(GLFW3_FOUND) IF(NOT GLFW3_FIND_QUIETLY) MESSAGE(STATUS \"Found ASSIMP: ${GLFW3_LIBRARY}\") ENDIF(NOT GLFW3_FIND_QUIETLY) ELSE(GLFW3_FOUND) IF(GLFW3_FIND_REQUIRED) MESSAGE(FATAL_ERROR \"Could not find GLFW3\") ENDIF(GLFW3_FIND_REQUIRED) ENDIF(GLFW3_FOUND) 3.创建窗口这里和LearnOpenGL里教的一样了就，src/start/HelloWindow.cpp cpp // 你好，窗口 #include \u003ciostream\u003e #include \u003cglad/glad.h\u003e #include \u003cGLFW/glfw3.h\u003e #include \u003cstdlib.h\u003e using namespace std; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow *window); int main() { cout \u003c\u003c \"hellow\" \u003c\u003c endl; glfwInit(); // 初始化库 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // 配置主版本号 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); // 配置次版本号 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 使用核心模式 //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // Mac OS X 使用 // 创建一个窗口 GLFWwindow* window = glfwCreateWindow(800, 600, \"LearnOpenGL\", NULL, NULL); if (window == NULL) { std::cout \u003c\u003c \"Failed to create GLFW window\" \u003c\u003c std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // 设置为当前上下文 // glad // GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。 if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout \u003c\u003c \"Failed to initialize GLAD\" \u003c\u003c std::endl; return -1; } // 设置窗口的维度 // glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。 glViewport(0, 0, 800, 600); // 设置一个回调","date":"2021-12-12","objectID":"/learn-opengl-env/:3:1","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#创建窗口"},{"categories":["program"],"content":" 创建窗口先给出目录细节再详细说，所有参与文件如下： CMakeLists.txt - cmake构建文件 cmake/modules/ - 存放cmake自动查找库的find文件 FindGLFW3.cmake - 负责自动查找glfw的头文件路径和lib路径 include/ - 存放头文件 glad.c - 把安装GLAD时的文件复制过来 glad/ - 安装GLAD时的头文件目录，复制过来 glad.h KHR/ - 安装GLAD时的头文件目录，复制过来 khrplatform.h src/ - 存放源代码 start/ - 存放LearnOpenGL教程第一部分源码 CMakeLists.txt - 子目录构建文件 HelloWindow.cpp - 创建窗口示例程序 1.主CMakeLists.txt根目录下的CMakeLists.txt文件是引导cmake的入口，主要做一些项目设置，和头文件，lib等查找工作，详细如下： cmake cmake_minimum_required(VERSION 2.9) # 指定cmake最小版本 project(learnopengl) # 设置项目名 # 依赖环境 # ------------------------------------------------------------------------------ set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_SOURCE_DIR}/cmake/modules/\") find_package(GLFW3 REQUIRED) include_directories(${GLFW3_INCLUDE_DIR}) add_library(glad include/glad.c) # ------------------------------------------------------------------------------ include_directories(./include) # 添加头文件搜索目录 # 子目录 add_subdirectory(src/start) # 子目录也会有CMakeLists.txt文件，环境是相通的 主要来看依赖环境部分： set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_SOURCE_DIR}/cmake/modules/\") 这句是往CMAKE_MODULE_PATH里追加一个目录， 这些目录里存放着各种find文件，命名为Find${LIB}.cmake find_package(GLFW3 REQUIRED)表示调用FindGLFW3.cmake查找GLFW3的头文件和lib，而且是必须找到，否则构建终止。 如果找到了，会设置GLFW3_XXX等一系列变量 include_directories(${GLFW3_INCLUDE_DIR})，find执行成功才会执行这句，变量GLFW3_INCLUDE_DIR里存放着GLFW头文件的路径，然后添加头文件搜索目录 add_library(glad include/glad.c)声明一个名为glad的lib，后面可以指定链接它，glad.c就会参与编译 2.FindGLFW.cmake看下项目里GLFW的搜索文件cmake/modules/FindGLFW3.cmake，这个文件可以在网上找到很多例子，cmake本身也会预装很多find文件。 cmake set( _glfw3_HEADER_SEARCH_DIRS \"/usr/include\" \"/usr/local/include\" \"${CMAKE_SOURCE_DIR}/includes\" \"C:/Program Files (x86)/glfw/include\" \"C:/Program Files (x86)/GLFW/include\") # 注意这里，就是我们安装的目录 set( _glfw3_LIB_SEARCH_DIRS \"/usr/lib\" \"/usr/local/lib\" \"${CMAKE_SOURCE_DIR}/lib\" \"C:/Program Files (x86)/glfw/lib-msvc110\" \"C:/Program Files (x86)/GLFW/lib\") # 注意这里 # Check environment for root search directory set( _glfw3_ENV_ROOT $ENV{GLFW3_ROOT} ) if( NOT GLFW3_ROOT AND _glfw3_ENV_ROOT ) set(GLFW3_ROOT ${_glfw3_ENV_ROOT} ) endif() # Put user specified location at beginning of search if( GLFW3_ROOT ) list( INSERT _glfw3_HEADER_SEARCH_DIRS 0 \"${GLFW3_ROOT}/include\" ) list( INSERT _glfw3_LIB_SEARCH_DIRS 0 \"${GLFW3_ROOT}/lib\" ) endif() # Search for the header FIND_PATH(GLFW3_INCLUDE_DIR \"GLFW/glfw3.h\" # 头文件目录的变量 PATHS ${_glfw3_HEADER_SEARCH_DIRS} ) # Search for the library FIND_LIBRARY(GLFW3_LIBRARY NAMES glfw3 glfw glfw3dll PATHS ${_glfw3_LIB_SEARCH_DIRS} ) INCLUDE(FindPackageHandleStandardArgs) FIND_PACKAGE_HANDLE_STANDARD_ARGS(GLFW3 DEFAULT_MSG GLFW3_LIBRARY GLFW3_INCLUDE_DIR) # 注意这里 IF(GLFW3_FOUND) IF(NOT GLFW3_FIND_QUIETLY) MESSAGE(STATUS \"Found ASSIMP: ${GLFW3_LIBRARY}\") ENDIF(NOT GLFW3_FIND_QUIETLY) ELSE(GLFW3_FOUND) IF(GLFW3_FIND_REQUIRED) MESSAGE(FATAL_ERROR \"Could not find GLFW3\") ENDIF(GLFW3_FIND_REQUIRED) ENDIF(GLFW3_FOUND) 3.创建窗口这里和LearnOpenGL里教的一样了就，src/start/HelloWindow.cpp cpp // 你好，窗口 #include #include #include #include using namespace std; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow *window); int main() { cout \u003c\u003c \"hellow\" \u003c\u003c endl; glfwInit(); // 初始化库 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // 配置主版本号 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); // 配置次版本号 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 使用核心模式 //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // Mac OS X 使用 // 创建一个窗口 GLFWwindow* window = glfwCreateWindow(800, 600, \"LearnOpenGL\", NULL, NULL); if (window == NULL) { std::cout \u003c\u003c \"Failed to create GLFW window\" \u003c\u003c std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // 设置为当前上下文 // glad // GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。 if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout \u003c\u003c \"Failed to initialize GLAD\" \u003c\u003c std::endl; return -1; } // 设置窗口的维度 // glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。 glViewport(0, 0, 800, 600); // 设置一个回调","date":"2021-12-12","objectID":"/learn-opengl-env/:3:1","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#1主cmakeliststxt"},{"categories":["program"],"content":" 创建窗口先给出目录细节再详细说，所有参与文件如下： CMakeLists.txt - cmake构建文件 cmake/modules/ - 存放cmake自动查找库的find文件 FindGLFW3.cmake - 负责自动查找glfw的头文件路径和lib路径 include/ - 存放头文件 glad.c - 把安装GLAD时的文件复制过来 glad/ - 安装GLAD时的头文件目录，复制过来 glad.h KHR/ - 安装GLAD时的头文件目录，复制过来 khrplatform.h src/ - 存放源代码 start/ - 存放LearnOpenGL教程第一部分源码 CMakeLists.txt - 子目录构建文件 HelloWindow.cpp - 创建窗口示例程序 1.主CMakeLists.txt根目录下的CMakeLists.txt文件是引导cmake的入口，主要做一些项目设置，和头文件，lib等查找工作，详细如下： cmake cmake_minimum_required(VERSION 2.9) # 指定cmake最小版本 project(learnopengl) # 设置项目名 # 依赖环境 # ------------------------------------------------------------------------------ set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_SOURCE_DIR}/cmake/modules/\") find_package(GLFW3 REQUIRED) include_directories(${GLFW3_INCLUDE_DIR}) add_library(glad include/glad.c) # ------------------------------------------------------------------------------ include_directories(./include) # 添加头文件搜索目录 # 子目录 add_subdirectory(src/start) # 子目录也会有CMakeLists.txt文件，环境是相通的 主要来看依赖环境部分： set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_SOURCE_DIR}/cmake/modules/\") 这句是往CMAKE_MODULE_PATH里追加一个目录， 这些目录里存放着各种find文件，命名为Find${LIB}.cmake find_package(GLFW3 REQUIRED)表示调用FindGLFW3.cmake查找GLFW3的头文件和lib，而且是必须找到，否则构建终止。 如果找到了，会设置GLFW3_XXX等一系列变量 include_directories(${GLFW3_INCLUDE_DIR})，find执行成功才会执行这句，变量GLFW3_INCLUDE_DIR里存放着GLFW头文件的路径，然后添加头文件搜索目录 add_library(glad include/glad.c)声明一个名为glad的lib，后面可以指定链接它，glad.c就会参与编译 2.FindGLFW.cmake看下项目里GLFW的搜索文件cmake/modules/FindGLFW3.cmake，这个文件可以在网上找到很多例子，cmake本身也会预装很多find文件。 cmake set( _glfw3_HEADER_SEARCH_DIRS \"/usr/include\" \"/usr/local/include\" \"${CMAKE_SOURCE_DIR}/includes\" \"C:/Program Files (x86)/glfw/include\" \"C:/Program Files (x86)/GLFW/include\") # 注意这里，就是我们安装的目录 set( _glfw3_LIB_SEARCH_DIRS \"/usr/lib\" \"/usr/local/lib\" \"${CMAKE_SOURCE_DIR}/lib\" \"C:/Program Files (x86)/glfw/lib-msvc110\" \"C:/Program Files (x86)/GLFW/lib\") # 注意这里 # Check environment for root search directory set( _glfw3_ENV_ROOT $ENV{GLFW3_ROOT} ) if( NOT GLFW3_ROOT AND _glfw3_ENV_ROOT ) set(GLFW3_ROOT ${_glfw3_ENV_ROOT} ) endif() # Put user specified location at beginning of search if( GLFW3_ROOT ) list( INSERT _glfw3_HEADER_SEARCH_DIRS 0 \"${GLFW3_ROOT}/include\" ) list( INSERT _glfw3_LIB_SEARCH_DIRS 0 \"${GLFW3_ROOT}/lib\" ) endif() # Search for the header FIND_PATH(GLFW3_INCLUDE_DIR \"GLFW/glfw3.h\" # 头文件目录的变量 PATHS ${_glfw3_HEADER_SEARCH_DIRS} ) # Search for the library FIND_LIBRARY(GLFW3_LIBRARY NAMES glfw3 glfw glfw3dll PATHS ${_glfw3_LIB_SEARCH_DIRS} ) INCLUDE(FindPackageHandleStandardArgs) FIND_PACKAGE_HANDLE_STANDARD_ARGS(GLFW3 DEFAULT_MSG GLFW3_LIBRARY GLFW3_INCLUDE_DIR) # 注意这里 IF(GLFW3_FOUND) IF(NOT GLFW3_FIND_QUIETLY) MESSAGE(STATUS \"Found ASSIMP: ${GLFW3_LIBRARY}\") ENDIF(NOT GLFW3_FIND_QUIETLY) ELSE(GLFW3_FOUND) IF(GLFW3_FIND_REQUIRED) MESSAGE(FATAL_ERROR \"Could not find GLFW3\") ENDIF(GLFW3_FIND_REQUIRED) ENDIF(GLFW3_FOUND) 3.创建窗口这里和LearnOpenGL里教的一样了就，src/start/HelloWindow.cpp cpp // 你好，窗口 #include #include #include #include using namespace std; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow *window); int main() { cout \u003c\u003c \"hellow\" \u003c\u003c endl; glfwInit(); // 初始化库 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // 配置主版本号 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); // 配置次版本号 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 使用核心模式 //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // Mac OS X 使用 // 创建一个窗口 GLFWwindow* window = glfwCreateWindow(800, 600, \"LearnOpenGL\", NULL, NULL); if (window == NULL) { std::cout \u003c\u003c \"Failed to create GLFW window\" \u003c\u003c std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // 设置为当前上下文 // glad // GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。 if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout \u003c\u003c \"Failed to initialize GLAD\" \u003c\u003c std::endl; return -1; } // 设置窗口的维度 // glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。 glViewport(0, 0, 800, 600); // 设置一个回调","date":"2021-12-12","objectID":"/learn-opengl-env/:3:1","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#2findglfwcmake"},{"categories":["program"],"content":" 创建窗口先给出目录细节再详细说，所有参与文件如下： CMakeLists.txt - cmake构建文件 cmake/modules/ - 存放cmake自动查找库的find文件 FindGLFW3.cmake - 负责自动查找glfw的头文件路径和lib路径 include/ - 存放头文件 glad.c - 把安装GLAD时的文件复制过来 glad/ - 安装GLAD时的头文件目录，复制过来 glad.h KHR/ - 安装GLAD时的头文件目录，复制过来 khrplatform.h src/ - 存放源代码 start/ - 存放LearnOpenGL教程第一部分源码 CMakeLists.txt - 子目录构建文件 HelloWindow.cpp - 创建窗口示例程序 1.主CMakeLists.txt根目录下的CMakeLists.txt文件是引导cmake的入口，主要做一些项目设置，和头文件，lib等查找工作，详细如下： cmake cmake_minimum_required(VERSION 2.9) # 指定cmake最小版本 project(learnopengl) # 设置项目名 # 依赖环境 # ------------------------------------------------------------------------------ set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_SOURCE_DIR}/cmake/modules/\") find_package(GLFW3 REQUIRED) include_directories(${GLFW3_INCLUDE_DIR}) add_library(glad include/glad.c) # ------------------------------------------------------------------------------ include_directories(./include) # 添加头文件搜索目录 # 子目录 add_subdirectory(src/start) # 子目录也会有CMakeLists.txt文件，环境是相通的 主要来看依赖环境部分： set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_SOURCE_DIR}/cmake/modules/\") 这句是往CMAKE_MODULE_PATH里追加一个目录， 这些目录里存放着各种find文件，命名为Find${LIB}.cmake find_package(GLFW3 REQUIRED)表示调用FindGLFW3.cmake查找GLFW3的头文件和lib，而且是必须找到，否则构建终止。 如果找到了，会设置GLFW3_XXX等一系列变量 include_directories(${GLFW3_INCLUDE_DIR})，find执行成功才会执行这句，变量GLFW3_INCLUDE_DIR里存放着GLFW头文件的路径，然后添加头文件搜索目录 add_library(glad include/glad.c)声明一个名为glad的lib，后面可以指定链接它，glad.c就会参与编译 2.FindGLFW.cmake看下项目里GLFW的搜索文件cmake/modules/FindGLFW3.cmake，这个文件可以在网上找到很多例子，cmake本身也会预装很多find文件。 cmake set( _glfw3_HEADER_SEARCH_DIRS \"/usr/include\" \"/usr/local/include\" \"${CMAKE_SOURCE_DIR}/includes\" \"C:/Program Files (x86)/glfw/include\" \"C:/Program Files (x86)/GLFW/include\") # 注意这里，就是我们安装的目录 set( _glfw3_LIB_SEARCH_DIRS \"/usr/lib\" \"/usr/local/lib\" \"${CMAKE_SOURCE_DIR}/lib\" \"C:/Program Files (x86)/glfw/lib-msvc110\" \"C:/Program Files (x86)/GLFW/lib\") # 注意这里 # Check environment for root search directory set( _glfw3_ENV_ROOT $ENV{GLFW3_ROOT} ) if( NOT GLFW3_ROOT AND _glfw3_ENV_ROOT ) set(GLFW3_ROOT ${_glfw3_ENV_ROOT} ) endif() # Put user specified location at beginning of search if( GLFW3_ROOT ) list( INSERT _glfw3_HEADER_SEARCH_DIRS 0 \"${GLFW3_ROOT}/include\" ) list( INSERT _glfw3_LIB_SEARCH_DIRS 0 \"${GLFW3_ROOT}/lib\" ) endif() # Search for the header FIND_PATH(GLFW3_INCLUDE_DIR \"GLFW/glfw3.h\" # 头文件目录的变量 PATHS ${_glfw3_HEADER_SEARCH_DIRS} ) # Search for the library FIND_LIBRARY(GLFW3_LIBRARY NAMES glfw3 glfw glfw3dll PATHS ${_glfw3_LIB_SEARCH_DIRS} ) INCLUDE(FindPackageHandleStandardArgs) FIND_PACKAGE_HANDLE_STANDARD_ARGS(GLFW3 DEFAULT_MSG GLFW3_LIBRARY GLFW3_INCLUDE_DIR) # 注意这里 IF(GLFW3_FOUND) IF(NOT GLFW3_FIND_QUIETLY) MESSAGE(STATUS \"Found ASSIMP: ${GLFW3_LIBRARY}\") ENDIF(NOT GLFW3_FIND_QUIETLY) ELSE(GLFW3_FOUND) IF(GLFW3_FIND_REQUIRED) MESSAGE(FATAL_ERROR \"Could not find GLFW3\") ENDIF(GLFW3_FIND_REQUIRED) ENDIF(GLFW3_FOUND) 3.创建窗口这里和LearnOpenGL里教的一样了就，src/start/HelloWindow.cpp cpp // 你好，窗口 #include #include #include #include using namespace std; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow *window); int main() { cout \u003c\u003c \"hellow\" \u003c\u003c endl; glfwInit(); // 初始化库 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // 配置主版本号 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); // 配置次版本号 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 使用核心模式 //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // Mac OS X 使用 // 创建一个窗口 GLFWwindow* window = glfwCreateWindow(800, 600, \"LearnOpenGL\", NULL, NULL); if (window == NULL) { std::cout \u003c\u003c \"Failed to create GLFW window\" \u003c\u003c std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // 设置为当前上下文 // glad // GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。 if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout \u003c\u003c \"Failed to initialize GLAD\" \u003c\u003c std::endl; return -1; } // 设置窗口的维度 // glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。 glViewport(0, 0, 800, 600); // 设置一个回调","date":"2021-12-12","objectID":"/learn-opengl-env/:3:1","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#3创建窗口"},{"categories":["program"],"content":" 创建窗口先给出目录细节再详细说，所有参与文件如下： CMakeLists.txt - cmake构建文件 cmake/modules/ - 存放cmake自动查找库的find文件 FindGLFW3.cmake - 负责自动查找glfw的头文件路径和lib路径 include/ - 存放头文件 glad.c - 把安装GLAD时的文件复制过来 glad/ - 安装GLAD时的头文件目录，复制过来 glad.h KHR/ - 安装GLAD时的头文件目录，复制过来 khrplatform.h src/ - 存放源代码 start/ - 存放LearnOpenGL教程第一部分源码 CMakeLists.txt - 子目录构建文件 HelloWindow.cpp - 创建窗口示例程序 1.主CMakeLists.txt根目录下的CMakeLists.txt文件是引导cmake的入口，主要做一些项目设置，和头文件，lib等查找工作，详细如下： cmake cmake_minimum_required(VERSION 2.9) # 指定cmake最小版本 project(learnopengl) # 设置项目名 # 依赖环境 # ------------------------------------------------------------------------------ set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_SOURCE_DIR}/cmake/modules/\") find_package(GLFW3 REQUIRED) include_directories(${GLFW3_INCLUDE_DIR}) add_library(glad include/glad.c) # ------------------------------------------------------------------------------ include_directories(./include) # 添加头文件搜索目录 # 子目录 add_subdirectory(src/start) # 子目录也会有CMakeLists.txt文件，环境是相通的 主要来看依赖环境部分： set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_SOURCE_DIR}/cmake/modules/\") 这句是往CMAKE_MODULE_PATH里追加一个目录， 这些目录里存放着各种find文件，命名为Find${LIB}.cmake find_package(GLFW3 REQUIRED)表示调用FindGLFW3.cmake查找GLFW3的头文件和lib，而且是必须找到，否则构建终止。 如果找到了，会设置GLFW3_XXX等一系列变量 include_directories(${GLFW3_INCLUDE_DIR})，find执行成功才会执行这句，变量GLFW3_INCLUDE_DIR里存放着GLFW头文件的路径，然后添加头文件搜索目录 add_library(glad include/glad.c)声明一个名为glad的lib，后面可以指定链接它，glad.c就会参与编译 2.FindGLFW.cmake看下项目里GLFW的搜索文件cmake/modules/FindGLFW3.cmake，这个文件可以在网上找到很多例子，cmake本身也会预装很多find文件。 cmake set( _glfw3_HEADER_SEARCH_DIRS \"/usr/include\" \"/usr/local/include\" \"${CMAKE_SOURCE_DIR}/includes\" \"C:/Program Files (x86)/glfw/include\" \"C:/Program Files (x86)/GLFW/include\") # 注意这里，就是我们安装的目录 set( _glfw3_LIB_SEARCH_DIRS \"/usr/lib\" \"/usr/local/lib\" \"${CMAKE_SOURCE_DIR}/lib\" \"C:/Program Files (x86)/glfw/lib-msvc110\" \"C:/Program Files (x86)/GLFW/lib\") # 注意这里 # Check environment for root search directory set( _glfw3_ENV_ROOT $ENV{GLFW3_ROOT} ) if( NOT GLFW3_ROOT AND _glfw3_ENV_ROOT ) set(GLFW3_ROOT ${_glfw3_ENV_ROOT} ) endif() # Put user specified location at beginning of search if( GLFW3_ROOT ) list( INSERT _glfw3_HEADER_SEARCH_DIRS 0 \"${GLFW3_ROOT}/include\" ) list( INSERT _glfw3_LIB_SEARCH_DIRS 0 \"${GLFW3_ROOT}/lib\" ) endif() # Search for the header FIND_PATH(GLFW3_INCLUDE_DIR \"GLFW/glfw3.h\" # 头文件目录的变量 PATHS ${_glfw3_HEADER_SEARCH_DIRS} ) # Search for the library FIND_LIBRARY(GLFW3_LIBRARY NAMES glfw3 glfw glfw3dll PATHS ${_glfw3_LIB_SEARCH_DIRS} ) INCLUDE(FindPackageHandleStandardArgs) FIND_PACKAGE_HANDLE_STANDARD_ARGS(GLFW3 DEFAULT_MSG GLFW3_LIBRARY GLFW3_INCLUDE_DIR) # 注意这里 IF(GLFW3_FOUND) IF(NOT GLFW3_FIND_QUIETLY) MESSAGE(STATUS \"Found ASSIMP: ${GLFW3_LIBRARY}\") ENDIF(NOT GLFW3_FIND_QUIETLY) ELSE(GLFW3_FOUND) IF(GLFW3_FIND_REQUIRED) MESSAGE(FATAL_ERROR \"Could not find GLFW3\") ENDIF(GLFW3_FIND_REQUIRED) ENDIF(GLFW3_FOUND) 3.创建窗口这里和LearnOpenGL里教的一样了就，src/start/HelloWindow.cpp cpp // 你好，窗口 #include #include #include #include using namespace std; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow *window); int main() { cout \u003c\u003c \"hellow\" \u003c\u003c endl; glfwInit(); // 初始化库 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // 配置主版本号 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); // 配置次版本号 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 使用核心模式 //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // Mac OS X 使用 // 创建一个窗口 GLFWwindow* window = glfwCreateWindow(800, 600, \"LearnOpenGL\", NULL, NULL); if (window == NULL) { std::cout \u003c\u003c \"Failed to create GLFW window\" \u003c\u003c std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // 设置为当前上下文 // glad // GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。 if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout \u003c\u003c \"Failed to initialize GLAD\" \u003c\u003c std::endl; return -1; } // 设置窗口的维度 // glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。 glViewport(0, 0, 800, 600); // 设置一个回调","date":"2021-12-12","objectID":"/learn-opengl-env/:3:1","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#4子cmakeliststxt"},{"categories":["program"],"content":" 创建窗口先给出目录细节再详细说，所有参与文件如下： CMakeLists.txt - cmake构建文件 cmake/modules/ - 存放cmake自动查找库的find文件 FindGLFW3.cmake - 负责自动查找glfw的头文件路径和lib路径 include/ - 存放头文件 glad.c - 把安装GLAD时的文件复制过来 glad/ - 安装GLAD时的头文件目录，复制过来 glad.h KHR/ - 安装GLAD时的头文件目录，复制过来 khrplatform.h src/ - 存放源代码 start/ - 存放LearnOpenGL教程第一部分源码 CMakeLists.txt - 子目录构建文件 HelloWindow.cpp - 创建窗口示例程序 1.主CMakeLists.txt根目录下的CMakeLists.txt文件是引导cmake的入口，主要做一些项目设置，和头文件，lib等查找工作，详细如下： cmake cmake_minimum_required(VERSION 2.9) # 指定cmake最小版本 project(learnopengl) # 设置项目名 # 依赖环境 # ------------------------------------------------------------------------------ set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_SOURCE_DIR}/cmake/modules/\") find_package(GLFW3 REQUIRED) include_directories(${GLFW3_INCLUDE_DIR}) add_library(glad include/glad.c) # ------------------------------------------------------------------------------ include_directories(./include) # 添加头文件搜索目录 # 子目录 add_subdirectory(src/start) # 子目录也会有CMakeLists.txt文件，环境是相通的 主要来看依赖环境部分： set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \"${CMAKE_SOURCE_DIR}/cmake/modules/\") 这句是往CMAKE_MODULE_PATH里追加一个目录， 这些目录里存放着各种find文件，命名为Find${LIB}.cmake find_package(GLFW3 REQUIRED)表示调用FindGLFW3.cmake查找GLFW3的头文件和lib，而且是必须找到，否则构建终止。 如果找到了，会设置GLFW3_XXX等一系列变量 include_directories(${GLFW3_INCLUDE_DIR})，find执行成功才会执行这句，变量GLFW3_INCLUDE_DIR里存放着GLFW头文件的路径，然后添加头文件搜索目录 add_library(glad include/glad.c)声明一个名为glad的lib，后面可以指定链接它，glad.c就会参与编译 2.FindGLFW.cmake看下项目里GLFW的搜索文件cmake/modules/FindGLFW3.cmake，这个文件可以在网上找到很多例子，cmake本身也会预装很多find文件。 cmake set( _glfw3_HEADER_SEARCH_DIRS \"/usr/include\" \"/usr/local/include\" \"${CMAKE_SOURCE_DIR}/includes\" \"C:/Program Files (x86)/glfw/include\" \"C:/Program Files (x86)/GLFW/include\") # 注意这里，就是我们安装的目录 set( _glfw3_LIB_SEARCH_DIRS \"/usr/lib\" \"/usr/local/lib\" \"${CMAKE_SOURCE_DIR}/lib\" \"C:/Program Files (x86)/glfw/lib-msvc110\" \"C:/Program Files (x86)/GLFW/lib\") # 注意这里 # Check environment for root search directory set( _glfw3_ENV_ROOT $ENV{GLFW3_ROOT} ) if( NOT GLFW3_ROOT AND _glfw3_ENV_ROOT ) set(GLFW3_ROOT ${_glfw3_ENV_ROOT} ) endif() # Put user specified location at beginning of search if( GLFW3_ROOT ) list( INSERT _glfw3_HEADER_SEARCH_DIRS 0 \"${GLFW3_ROOT}/include\" ) list( INSERT _glfw3_LIB_SEARCH_DIRS 0 \"${GLFW3_ROOT}/lib\" ) endif() # Search for the header FIND_PATH(GLFW3_INCLUDE_DIR \"GLFW/glfw3.h\" # 头文件目录的变量 PATHS ${_glfw3_HEADER_SEARCH_DIRS} ) # Search for the library FIND_LIBRARY(GLFW3_LIBRARY NAMES glfw3 glfw glfw3dll PATHS ${_glfw3_LIB_SEARCH_DIRS} ) INCLUDE(FindPackageHandleStandardArgs) FIND_PACKAGE_HANDLE_STANDARD_ARGS(GLFW3 DEFAULT_MSG GLFW3_LIBRARY GLFW3_INCLUDE_DIR) # 注意这里 IF(GLFW3_FOUND) IF(NOT GLFW3_FIND_QUIETLY) MESSAGE(STATUS \"Found ASSIMP: ${GLFW3_LIBRARY}\") ENDIF(NOT GLFW3_FIND_QUIETLY) ELSE(GLFW3_FOUND) IF(GLFW3_FIND_REQUIRED) MESSAGE(FATAL_ERROR \"Could not find GLFW3\") ENDIF(GLFW3_FIND_REQUIRED) ENDIF(GLFW3_FOUND) 3.创建窗口这里和LearnOpenGL里教的一样了就，src/start/HelloWindow.cpp cpp // 你好，窗口 #include #include #include #include using namespace std; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow *window); int main() { cout \u003c\u003c \"hellow\" \u003c\u003c endl; glfwInit(); // 初始化库 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // 配置主版本号 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); // 配置次版本号 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 使用核心模式 //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // Mac OS X 使用 // 创建一个窗口 GLFWwindow* window = glfwCreateWindow(800, 600, \"LearnOpenGL\", NULL, NULL); if (window == NULL) { std::cout \u003c\u003c \"Failed to create GLFW window\" \u003c\u003c std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // 设置为当前上下文 // glad // GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。 if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout \u003c\u003c \"Failed to initialize GLAD\" \u003c\u003c std::endl; return -1; } // 设置窗口的维度 // glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。 glViewport(0, 0, 800, 600); // 设置一个回调","date":"2021-12-12","objectID":"/learn-opengl-env/:3:1","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#5编译"},{"categories":["program"],"content":" 终 LearnOpenGL 我的通关记录github 希望你也能通关，终点等你。 （依赖库安装还没写完，待续。。。 ","date":"2021-12-12","objectID":"/learn-opengl-env/:4:0","series":null,"tags":["openGL"],"title":"LearnOpenGL环境搭建","uri":"/learn-opengl-env/#终"},{"categories":["compiler"],"content":" 简介Pratt Parsing 是一种在手写递归下降解析器时处理表达式解析的好方法，通过给算符定义优先级，可以处理左递归的语法定义，写起来非常简单。 我学到这个方法是在这本书里：《Writing An Interpreter In Go》，作者用手写递归下降的方式实现了一个名为 Monky 的语言，其中解析表达式的部分就是用 Pratt Parsing 实现的。 整一个解析器无非就两种方法：手写、使用parser generator工具生成。 如果选择手写，那肯定是采用自顶向下的方式。 选择生成器，也有两个流派：自顶向下、自底向上。比如： 自顶向下：ANTLR - ALL(*) 自底向上：Yacc/Bison - LALR 我更喜欢年轻的ANTLR，甚至都没用过Yacc/Bison，自顶向下的方式更符合人类思维，而LALR算法生成的代码很难懂(不光生成的代码难懂，算法思想本身也难懂)。还有就是手写递归下降很流行，Go的编译器就是这么干的。 自顶向下的方式缺点是无法处理左递归，但ANTLR允许定义直接左递归，它会帮你自动改写。在《ANTRL4权威指南》14章 移除直接左递归中提到了左递归规则转换的方法，和Pratt Parsing 的方式非常相似！ ","date":"2021-08-15","objectID":"/pratt-parsing/:1:0","series":null,"tags":["compiler","parser"],"title":"Pratt Parsing - 自顶向下的算符优先级","uri":"/pratt-parsing/#简介"},{"categories":["compiler"],"content":" Pratt Parsing 解决什么问题写一个parser，最困难的地方可能就是解析表达式了，不同于其他语法结构，表达式涉及运算符优先级问题，并且在定义上也是递归的。 比如这样一个表达式： text 1 + 2 * 3 乘法运算的优先级应该更高，所以parser在得到1+2的输入时，并不能直接构造一个算术表达式返回，我们希望的返回是 1+(2*3) 而不是 (1+2)*3。 另外，一般语言中都支持分组，来自定义运算顺序： text 3 * (1 + 2) 即使乘法的优先级最高，parser在读入3*之后也不能从分组中把1抢过来构造(3*1)+2，正确的返回应该是3*(1+2) 再复杂一点，函数调用也可以参与表达式运算： text 5 * (add(2,3) + 1) 函数的参数也可以是更复杂的表达式，函数也可以嵌套： text add(3 * (1 + 2), add(1,2)) * 100 很明显表达式的定义是递归的，对于上面所有case，给出表达式的定义： antlr expr: expr ('+'|'-'|'*'|'/') expr | ('-') expr | '(' expr ')' | literal; literal: IDENTIFIER // 标识别符 | integer // 整数字面量 | '(' ( expr (',' expr)* )? ')'; //参数列表 如何在手写递归下降解释器中，正确解析这样一个表达式，就是Pratt Parsing所解决的问题。 ","date":"2021-08-15","objectID":"/pratt-parsing/:2:0","series":null,"tags":["compiler","parser"],"title":"Pratt Parsing - 自顶向下的算符优先级","uri":"/pratt-parsing/#pratt-parsing-解决什么问题"},{"categories":["compiler"],"content":" 如何做Pratt Parsing 的基本思想是：为每一个算符定义一个优先级。算符会被分为两类，一类称为前缀prefix算符，另一类称为中缀infix算符。-5中的负号就是一个前缀算符，特别的是一个字面量或标识符也被划分为一个前缀算符，如5、add，因为他们都是一元的；像1+2中的加号是中缀算符，同样比较特别的是函数调用add(1,2)，函数名后面的(也被归类为中缀算符，因为函数名必须要与参数列表结合。前缀算符和后缀算符都会有关联函数，关联函数负责构造具体的子表达式，过程中会递归的调用主解析函数。通过算符优先级，来决定如何构造AST。 一个算符既可以是前缀算符，也可以是中缀算符，如何定义取决于它们在表达式中所处的位置。在定义过算符之后，最重要的事情是定义算符优先级： go // 优先级从低到高排列 const ( _ int = iota LOWEST // 最低的 SUM // + - PRODUCT // * / PREFIX // -1 CALL // 函数调用，最高 ) 可以发现并没有关于分组的优先级，稍后会看到分组在解析过程中是如何巧妙处理的。 ","date":"2021-08-15","objectID":"/pratt-parsing/:3:0","series":null,"tags":["compiler","parser"],"title":"Pratt Parsing - 自顶向下的算符优先级","uri":"/pratt-parsing/#如何做"},{"categories":["compiler"],"content":" 主流程先给出解析表达式的入口方法（下文都省略词法分析器）： go // pratt parsing 的主要逻辑 func (p *Parser) parseExpr(precedence int) ast.Expr { prefix := p.prefixParseFns[p.curToken.Type] if prefix == nil { p.noPrefixParseFnError(p.curToken.Type) return nil } leftExpr := prefix() // 如果外部算符优先级没有后面遇到的的高，会循环下去 for !p.peekTokenIs(token.SEMICOLON) \u0026\u0026 precedence \u003c p.peekPrecedence() { infix := p.infixParseFns[p.peek_Tok.Type] if infix == nil { return leftExpr } p.nextToken() leftExpr = infix(leftExpr) // 合并中缀表达式 } return leftExpr } 解析开始时，传入的优先级参数一定是LOWEST，第一个遇到的算符一定是前缀算符。 去预定好的map中查找该算符作为前缀算符的关联函数，就是代码中的prefix，在prefix函数中构建子表达式(prefix中可能会递归调用parseExpr函数)。 得到prefix返回的子表达式后，窥探下一个算符的优先级。 如果下个算符优先级更高，就在map中查找该算符作为中缀算符的关联函数infix 如果没有说明这不是一个中缀算符，把当前构造好的leftExpr返回。 如果有，就读入这个算符，调用infix函数构造中缀表达式(infix同样可能递归调用parseExpr)。 函数返回 算符关联函数的签名如下： go type prefixParseFn func() ast.Expr type infixParseFn func(ast.Expr) ast.Expr 各算符作为前缀、中缀算符的关联函数如下： go // 前缀算符关联函数 p.prefixParseFns = make(map[token.Type]prefixParseFn) // 标识符：变量名、函数名 p.registerPrefix(token.IDENT, p.parseIdentifier) // 整数字面量：5、10 p.registerPrefix(token.INT, p.parseIntLiteral) // 负号：-5 p.registerPrefix(token.MINUS, p.parsePrefixExpression) // 分组(左括号)：3*(1+2) p.registerPrefix(token.LPAREN, p.parseGroupExpr) // 中缀算符关联函数 p.infixParseFns = make(map[token.Type]infixParseFn) // 二元算术运算：+ - * / p.registerInfix(token.PLUS, p.parseInfixExpr) p.registerInfix(token.MINUS, p.parseInfixExpr) p.registerInfix(token.ASTERISK, p.parseInfixExpr) p.registerInfix(token.SLASH, p.parseInfixExpr) // 函数调用(左括号)： add(1,2) p.registerInfix(token.LPAREN, p.parseCallExpr) 然后看下各算符关联函数的实现(parser在解析过程中的原则是尽可能不要推进当前算符)。 ","date":"2021-08-15","objectID":"/pratt-parsing/:3:1","series":null,"tags":["compiler","parser"],"title":"Pratt Parsing - 自顶向下的算符优先级","uri":"/pratt-parsing/#主流程"},{"categories":["compiler"],"content":" 前缀算符关联函数 标识符 go func (p *Parser) parseIdentifier() ast.Expr { // 注意这里不调用 nextToken, 这很重要 return \u0026ast.Identifier{ Token: p.curToken, Value: p.curToken.Literal, } } 很简单，就直接把单个token构造成AST上的Identifier节点返回。 整型字面量 go // int 作为prefix的关联函数 func (p *Parser) parseIntLiteral() ast.Expr { lit := \u0026ast.Int_Literal{Token: p.curToken} v, err := strconv.ParseInt(p.curToken.Literal, 0, 64) if err != nil { p.errs = append(p.errs, fmt.Sprintf(\"无法将%s转换为int\", p.curToken.Literal)) return nil } lit.Value = v return lit } 也很简单，就是把源码中的字符串转换为int并构造节点。 负号 go func (p *Parser) parsePrefixExpression() ast.Expr { expression := \u0026ast.PrefixExpression{ Token: p.curToken, Operator: p.curToken.Literal, } p.nextToken() // 注意这里，是pratt parsing的关键 // 传入优先级为 PREFIX, -3*5 , -add(1,2) 只有CALL大于此优先级 expression.Right = p.parseExpr(PREFIX) return expression } 这里开始递归了，直接递归调用parseExpr(注意传入优先级参数是PREFIX)得到负号后面跟的子表达式。PREFIX优先级很大，仅次于CALL: text -3*5 =\u003e (-3)*5 -add(1,2) =\u003e -(add(1,2)) 分组 go func (p *Parser) parseGroupExpr() ast.Expr { p.nextToken() exp := p.parseExpr(LOWEST) if !p.expectPeek(token.RPAREN) { // 吃掉 ) return nil } return exp } 分组的实现很简单，也很奇妙。读入(后，直接把优先级降到LOWEST，这样相当于屏蔽了前面的优先级，不管前面优先级多高，后面都看不见，思考：3*(1+2)。结束后读出)到curToken，如果下个字符不是)就说明输入语法错误。 ","date":"2021-08-15","objectID":"/pratt-parsing/:3:2","series":null,"tags":["compiler","parser"],"title":"Pratt Parsing - 自顶向下的算符优先级","uri":"/pratt-parsing/#前缀算符关联函数"},{"categories":["compiler"],"content":" 前缀算符关联函数 标识符 go func (p *Parser) parseIdentifier() ast.Expr { // 注意这里不调用 nextToken, 这很重要 return \u0026ast.Identifier{ Token: p.curToken, Value: p.curToken.Literal, } } 很简单，就直接把单个token构造成AST上的Identifier节点返回。 整型字面量 go // int 作为prefix的关联函数 func (p *Parser) parseIntLiteral() ast.Expr { lit := \u0026ast.Int_Literal{Token: p.curToken} v, err := strconv.ParseInt(p.curToken.Literal, 0, 64) if err != nil { p.errs = append(p.errs, fmt.Sprintf(\"无法将%s转换为int\", p.curToken.Literal)) return nil } lit.Value = v return lit } 也很简单，就是把源码中的字符串转换为int并构造节点。 负号 go func (p *Parser) parsePrefixExpression() ast.Expr { expression := \u0026ast.PrefixExpression{ Token: p.curToken, Operator: p.curToken.Literal, } p.nextToken() // 注意这里，是pratt parsing的关键 // 传入优先级为 PREFIX, -3*5 , -add(1,2) 只有CALL大于此优先级 expression.Right = p.parseExpr(PREFIX) return expression } 这里开始递归了，直接递归调用parseExpr(注意传入优先级参数是PREFIX)得到负号后面跟的子表达式。PREFIX优先级很大，仅次于CALL: text -3*5 =\u003e (-3)*5 -add(1,2) =\u003e -(add(1,2)) 分组 go func (p *Parser) parseGroupExpr() ast.Expr { p.nextToken() exp := p.parseExpr(LOWEST) if !p.expectPeek(token.RPAREN) { // 吃掉 ) return nil } return exp } 分组的实现很简单，也很奇妙。读入(后，直接把优先级降到LOWEST，这样相当于屏蔽了前面的优先级，不管前面优先级多高，后面都看不见，思考：3*(1+2)。结束后读出)到curToken，如果下个字符不是)就说明输入语法错误。 ","date":"2021-08-15","objectID":"/pratt-parsing/:3:2","series":null,"tags":["compiler","parser"],"title":"Pratt Parsing - 自顶向下的算符优先级","uri":"/pratt-parsing/#标识符"},{"categories":["compiler"],"content":" 前缀算符关联函数 标识符 go func (p *Parser) parseIdentifier() ast.Expr { // 注意这里不调用 nextToken, 这很重要 return \u0026ast.Identifier{ Token: p.curToken, Value: p.curToken.Literal, } } 很简单，就直接把单个token构造成AST上的Identifier节点返回。 整型字面量 go // int 作为prefix的关联函数 func (p *Parser) parseIntLiteral() ast.Expr { lit := \u0026ast.Int_Literal{Token: p.curToken} v, err := strconv.ParseInt(p.curToken.Literal, 0, 64) if err != nil { p.errs = append(p.errs, fmt.Sprintf(\"无法将%s转换为int\", p.curToken.Literal)) return nil } lit.Value = v return lit } 也很简单，就是把源码中的字符串转换为int并构造节点。 负号 go func (p *Parser) parsePrefixExpression() ast.Expr { expression := \u0026ast.PrefixExpression{ Token: p.curToken, Operator: p.curToken.Literal, } p.nextToken() // 注意这里，是pratt parsing的关键 // 传入优先级为 PREFIX, -3*5 , -add(1,2) 只有CALL大于此优先级 expression.Right = p.parseExpr(PREFIX) return expression } 这里开始递归了，直接递归调用parseExpr(注意传入优先级参数是PREFIX)得到负号后面跟的子表达式。PREFIX优先级很大，仅次于CALL: text -3*5 =\u003e (-3)*5 -add(1,2) =\u003e -(add(1,2)) 分组 go func (p *Parser) parseGroupExpr() ast.Expr { p.nextToken() exp := p.parseExpr(LOWEST) if !p.expectPeek(token.RPAREN) { // 吃掉 ) return nil } return exp } 分组的实现很简单，也很奇妙。读入(后，直接把优先级降到LOWEST，这样相当于屏蔽了前面的优先级，不管前面优先级多高，后面都看不见，思考：3*(1+2)。结束后读出)到curToken，如果下个字符不是)就说明输入语法错误。 ","date":"2021-08-15","objectID":"/pratt-parsing/:3:2","series":null,"tags":["compiler","parser"],"title":"Pratt Parsing - 自顶向下的算符优先级","uri":"/pratt-parsing/#整型字面量"},{"categories":["compiler"],"content":" 前缀算符关联函数 标识符 go func (p *Parser) parseIdentifier() ast.Expr { // 注意这里不调用 nextToken, 这很重要 return \u0026ast.Identifier{ Token: p.curToken, Value: p.curToken.Literal, } } 很简单，就直接把单个token构造成AST上的Identifier节点返回。 整型字面量 go // int 作为prefix的关联函数 func (p *Parser) parseIntLiteral() ast.Expr { lit := \u0026ast.Int_Literal{Token: p.curToken} v, err := strconv.ParseInt(p.curToken.Literal, 0, 64) if err != nil { p.errs = append(p.errs, fmt.Sprintf(\"无法将%s转换为int\", p.curToken.Literal)) return nil } lit.Value = v return lit } 也很简单，就是把源码中的字符串转换为int并构造节点。 负号 go func (p *Parser) parsePrefixExpression() ast.Expr { expression := \u0026ast.PrefixExpression{ Token: p.curToken, Operator: p.curToken.Literal, } p.nextToken() // 注意这里，是pratt parsing的关键 // 传入优先级为 PREFIX, -3*5 , -add(1,2) 只有CALL大于此优先级 expression.Right = p.parseExpr(PREFIX) return expression } 这里开始递归了，直接递归调用parseExpr(注意传入优先级参数是PREFIX)得到负号后面跟的子表达式。PREFIX优先级很大，仅次于CALL: text -3*5 =\u003e (-3)*5 -add(1,2) =\u003e -(add(1,2)) 分组 go func (p *Parser) parseGroupExpr() ast.Expr { p.nextToken() exp := p.parseExpr(LOWEST) if !p.expectPeek(token.RPAREN) { // 吃掉 ) return nil } return exp } 分组的实现很简单，也很奇妙。读入(后，直接把优先级降到LOWEST，这样相当于屏蔽了前面的优先级，不管前面优先级多高，后面都看不见，思考：3*(1+2)。结束后读出)到curToken，如果下个字符不是)就说明输入语法错误。 ","date":"2021-08-15","objectID":"/pratt-parsing/:3:2","series":null,"tags":["compiler","parser"],"title":"Pratt Parsing - 自顶向下的算符优先级","uri":"/pratt-parsing/#负号"},{"categories":["compiler"],"content":" 前缀算符关联函数 标识符 go func (p *Parser) parseIdentifier() ast.Expr { // 注意这里不调用 nextToken, 这很重要 return \u0026ast.Identifier{ Token: p.curToken, Value: p.curToken.Literal, } } 很简单，就直接把单个token构造成AST上的Identifier节点返回。 整型字面量 go // int 作为prefix的关联函数 func (p *Parser) parseIntLiteral() ast.Expr { lit := \u0026ast.Int_Literal{Token: p.curToken} v, err := strconv.ParseInt(p.curToken.Literal, 0, 64) if err != nil { p.errs = append(p.errs, fmt.Sprintf(\"无法将%s转换为int\", p.curToken.Literal)) return nil } lit.Value = v return lit } 也很简单，就是把源码中的字符串转换为int并构造节点。 负号 go func (p *Parser) parsePrefixExpression() ast.Expr { expression := \u0026ast.PrefixExpression{ Token: p.curToken, Operator: p.curToken.Literal, } p.nextToken() // 注意这里，是pratt parsing的关键 // 传入优先级为 PREFIX, -3*5 , -add(1,2) 只有CALL大于此优先级 expression.Right = p.parseExpr(PREFIX) return expression } 这里开始递归了，直接递归调用parseExpr(注意传入优先级参数是PREFIX)得到负号后面跟的子表达式。PREFIX优先级很大，仅次于CALL: text -3*5 =\u003e (-3)*5 -add(1,2) =\u003e -(add(1,2)) 分组 go func (p *Parser) parseGroupExpr() ast.Expr { p.nextToken() exp := p.parseExpr(LOWEST) if !p.expectPeek(token.RPAREN) { // 吃掉 ) return nil } return exp } 分组的实现很简单，也很奇妙。读入(后，直接把优先级降到LOWEST，这样相当于屏蔽了前面的优先级，不管前面优先级多高，后面都看不见，思考：3*(1+2)。结束后读出)到curToken，如果下个字符不是)就说明输入语法错误。 ","date":"2021-08-15","objectID":"/pratt-parsing/:3:2","series":null,"tags":["compiler","parser"],"title":"Pratt Parsing - 自顶向下的算符优先级","uri":"/pratt-parsing/#分组"},{"categories":["compiler"],"content":" 后缀算符关联函数 算术运算 go // 中缀算符的关联函数 + - * / func (p *Parser) parseInfixExpr(left ast.Expr) ast.Expr { expr := \u0026ast.Infix_Expr{ Token: p.curToken, Left: left, Operator: p.curToken.Literal, } precedence := p.curPrecedence() p.nextToken() expr.Right = p.parseExpr(precedence) return expr } 最终构造的节点有三部分：left、op、right，读取当前算符的优先级(SUM/PRODUCT)，传入parseExpr解析得到right部分，构造结束。 函数调用 go func (p *Parser) parseCallExpr(fn ast.Expr) ast.Expr { exp := \u0026ast.Call_Expr{Token: p.curToken, Function: fn} exp.Arguments = p.parseCallArgs() return exp } func (p *Parser) parseCallArgs() []ast.Expr { args := []ast.Expr{} // 没有参数的情况 if p.peekTokenIs(token.RPAREN) { p.nextToken() return args } // 解析参数 p.nextToken() args = append(args, p.parseExpr(LOWEST)) for p.peekTokenIs(token.COMMA) { p.nextToken() p.nextToken() args = append(args, p.parseExpr(LOWEST)) } if !p.expectPeek(token.RPAREN) { return nil } return args } 主要是解析参数列表，有多个参数情况下，都是逗号分割，直接循环处理，每次递归调用parseExpr传入的优先级都是LOWEST，因为每个参数都是独立的expr。 ","date":"2021-08-15","objectID":"/pratt-parsing/:3:3","series":null,"tags":["compiler","parser"],"title":"Pratt Parsing - 自顶向下的算符优先级","uri":"/pratt-parsing/#后缀算符关联函数"},{"categories":["compiler"],"content":" 后缀算符关联函数 算术运算 go // 中缀算符的关联函数 + - * / func (p *Parser) parseInfixExpr(left ast.Expr) ast.Expr { expr := \u0026ast.Infix_Expr{ Token: p.curToken, Left: left, Operator: p.curToken.Literal, } precedence := p.curPrecedence() p.nextToken() expr.Right = p.parseExpr(precedence) return expr } 最终构造的节点有三部分：left、op、right，读取当前算符的优先级(SUM/PRODUCT)，传入parseExpr解析得到right部分，构造结束。 函数调用 go func (p *Parser) parseCallExpr(fn ast.Expr) ast.Expr { exp := \u0026ast.Call_Expr{Token: p.curToken, Function: fn} exp.Arguments = p.parseCallArgs() return exp } func (p *Parser) parseCallArgs() []ast.Expr { args := []ast.Expr{} // 没有参数的情况 if p.peekTokenIs(token.RPAREN) { p.nextToken() return args } // 解析参数 p.nextToken() args = append(args, p.parseExpr(LOWEST)) for p.peekTokenIs(token.COMMA) { p.nextToken() p.nextToken() args = append(args, p.parseExpr(LOWEST)) } if !p.expectPeek(token.RPAREN) { return nil } return args } 主要是解析参数列表，有多个参数情况下，都是逗号分割，直接循环处理，每次递归调用parseExpr传入的优先级都是LOWEST，因为每个参数都是独立的expr。 ","date":"2021-08-15","objectID":"/pratt-parsing/:3:3","series":null,"tags":["compiler","parser"],"title":"Pratt Parsing - 自顶向下的算符优先级","uri":"/pratt-parsing/#算术运算"},{"categories":["compiler"],"content":" 后缀算符关联函数 算术运算 go // 中缀算符的关联函数 + - * / func (p *Parser) parseInfixExpr(left ast.Expr) ast.Expr { expr := \u0026ast.Infix_Expr{ Token: p.curToken, Left: left, Operator: p.curToken.Literal, } precedence := p.curPrecedence() p.nextToken() expr.Right = p.parseExpr(precedence) return expr } 最终构造的节点有三部分：left、op、right，读取当前算符的优先级(SUM/PRODUCT)，传入parseExpr解析得到right部分，构造结束。 函数调用 go func (p *Parser) parseCallExpr(fn ast.Expr) ast.Expr { exp := \u0026ast.Call_Expr{Token: p.curToken, Function: fn} exp.Arguments = p.parseCallArgs() return exp } func (p *Parser) parseCallArgs() []ast.Expr { args := []ast.Expr{} // 没有参数的情况 if p.peekTokenIs(token.RPAREN) { p.nextToken() return args } // 解析参数 p.nextToken() args = append(args, p.parseExpr(LOWEST)) for p.peekTokenIs(token.COMMA) { p.nextToken() p.nextToken() args = append(args, p.parseExpr(LOWEST)) } if !p.expectPeek(token.RPAREN) { return nil } return args } 主要是解析参数列表，有多个参数情况下，都是逗号分割，直接循环处理，每次递归调用parseExpr传入的优先级都是LOWEST，因为每个参数都是独立的expr。 ","date":"2021-08-15","objectID":"/pratt-parsing/:3:3","series":null,"tags":["compiler","parser"],"title":"Pratt Parsing - 自顶向下的算符优先级","uri":"/pratt-parsing/#函数调用"},{"categories":["compiler"],"content":" 总结整个算法的核心思想是使用优先级，来控制当前应该返回已构造的expr，还是继续解析。再贴一遍主流程： go func (p *Parser) parseExpr(precedence int) ast.Expr { prefix := p.prefixParseFns[p.curToken.Type] if prefix == nil { p.noPrefixParseFnError(p.curToken.Type) return nil } leftExpr := prefix() // 如果当前算符优先级没有后面的高，会循环下去 for !p.peekTokenIs(token.SEMICOLON) \u0026\u0026 precedence \u003c p.peekPrecedence() { infix := p.infixParseFns[p.peek_Tok.Type] if infix == nil { return leftExpr } p.nextToken() leftExpr = infix(leftExpr) // 合并中缀表达式 } return leftExpr } 用一个例子来演示下整个执行流程： 假设要解析1 + 2 * 5 id 剩余算符 当前算符 执行操作 说明 局部AST构造stack 0 1+2*5 parseExpr(LOWEST) 开始解析，传入最低优先级 1 +2*5 1 parserIntLiteral() 从映射中找到当前算符的prefix关联函数，执行后得到ast节点 1 2 2*5 + parseInfixExpr(left) 窥探得知+的算符优先级SUM大于LOWEST，执行+的关联函数 1+ 3 2*5 + parseExpr(SUM) 在2中递归调用了解析，并且传入优先级为SUM 4 *5 2 parserIntLiteral() 解析函数发现算符还是整数，继续调用关联函数 2 5 5 * parseInfixExpr(left) 发现的优先级PRODUCT大于当前优先级SUM，调用的关联函数 2* 6 5 * parseExpr(PRODUCT) 在5中递归调用解析，并传入优先级为PRODUCT 7 5 parserIntLiteral 算符还是整数，继续调用关联函数 5 8 7-\u003e6 输入结束，7返回到6，并得到ast {5} 9 6-\u003e3 6返回到3，并得到ast {2*{5}} 10 3-\u003e0 6返回到0，并得到ast {1+{2*{5}}} 基本上是对简介中那本书中实现内容的裁剪，强烈建议读一读。 ","date":"2021-08-15","objectID":"/pratt-parsing/:4:0","series":null,"tags":["compiler","parser"],"title":"Pratt Parsing - 自顶向下的算符优先级","uri":"/pratt-parsing/#总结"},{"categories":["default"],"content":"FaaS即Function as a service，云函数，用来托管一些无状态服务，好处是可以动态扩缩，非常灵活。 vercel是一个非常良心的免费的前端托管平台，我的博客目前也托管在这里。 得知vercel还支持云函数，这里是文档，而且runtime还支持Go，这不白嫖一下说不过去 简单用Go在上面部署了一个http服务，路由使用的是gin框架，成果：https://faas.kirito41dd.cn/api/1 ","date":"2021-07-24","objectID":"/use-vercel-as-free-faas/:0:0","series":null,"tags":["vercel","blog","FaaS"],"title":"白嫖vercel当FaaS用","uri":"/use-vercel-as-free-faas/#"},{"categories":["default"],"content":" 开始 首先安装vercel的cli工具，方便本地调试 直接 npm i -g vercel 新建个文件夹，初始化一个go项目 mkdir vercel-faas \u0026\u0026 cd vercel-faas \u0026\u0026 git init . go mod init xxx.github.com/vercel-faas mkdir api - 代码必须放在api/目录下 cli工具本地部署下 vercel dev - 跟着引导一路输入y就行 部署成功会出现Ready! Available at http://localhost:3000 这时就可以本地浏览器调试了，由于目录下没有静态网页，所以会404 不用关心，我们只使用云函数功能 ","date":"2021-07-24","objectID":"/use-vercel-as-free-faas/:1:0","series":null,"tags":["vercel","blog","FaaS"],"title":"白嫖vercel当FaaS用","uri":"/use-vercel-as-free-faas/#开始"},{"categories":["default"],"content":" 写代码根据vercel的文档，处理http请求的代码必须放在api/目录下，并且可以按文件名路由。 比如：请求/api/date就会默认去找api/date.go文件执行代码，文件里必须写一个函数作为入口 go func Handler(w http.ResponseWriter, r *http.Request) { // do ... } 但是在每个文件里都写一个这样的函数好像很重复劳动，而且不好和框架配合，所以我只在api/目录下放了一个文件当作入口，再加上路由，然后在handler/下放处理每个路由的具体实现。 完整代码见https://github.com/kirito41dd/vercel-faas 分解： 首先是在api/目录下提供一个入口 创建文件entrypoint.go，写上处理函数，请求交由gin框架处理 go func Handler(w http.ResponseWriter, r *http.Request) { app.ServeHTTP(w, r) } 引入gin框架，创建实例，并初始化 go import \"github.com/gin-gonic/gin\" var ( app *gin.Engine ) // 初始化逻辑 func init() { app = gin.New() // 创建路由 must /api/xxx r := app.Group(\"/api\") // 注册路由 registerRouter(r) } 注册路由，简单实现个ping go func registerRouter(r *gin.RouterGroup) { r.GET(\"/ping\", handler.Ping) } handler/handler.go里写具体的路由处理函数 go func Ping(c *gin.Context) { c.String(http.StatusOK, \"pong\") } 本地验证下，在项目根目录执行 vercel dev https://faas.kirito41dd.cn/api/ping 网页返回 pong 简单的ping/pong接口实现了，其他接口也是一个套路，塞更多的路由就行了 ","date":"2021-07-24","objectID":"/use-vercel-as-free-faas/:2:0","series":null,"tags":["vercel","blog","FaaS"],"title":"白嫖vercel当FaaS用","uri":"/use-vercel-as-free-faas/#写代码"},{"categories":["default"],"content":" 部署 首先将本地项目随便推送到一个github仓库 进入vercel主页 点击 New Project 在 Import Git Repository 那里关联你的github账号，授权仓库访问权限 找到你的仓库，点 Import 跳转到配置页面 Create a Team 可以跳过 Configure Project 这里 Project Name 随便填 Framework Preset 我们只用云函数可以选other 剩下的默认即可，点 Deploy 如图 部署完成后会给你分配个域名，可以用域名来访问你的云函数，也可以绑定自己的域名 完 ","date":"2021-07-24","objectID":"/use-vercel-as-free-faas/:3:0","series":null,"tags":["vercel","blog","FaaS"],"title":"白嫖vercel当FaaS用","uri":"/use-vercel-as-free-faas/#部署"},{"categories":["program"],"content":" 背景在写代码过程中，有时候需要做一些批量 查询/操作，往往会涉及将一个很大的数组或切片进行分块。 比如我们有一个存着id的数组，要根据id请求某个接口查询信息，这个接口支持批量查询，但是每次查询的数量上限是100。最好的做法是每次从数组中取最多100个id，进行批量查询，直到遍历完数组。 这个操作不复杂，可以简单的用循环实现，但是每次遇到这种场景都需要写一次代码，有点写吐了。所以就想写一个函数，可以将[]T按需求拆分成[][]T。 但是go的泛型还没有来，所以只能用反射来搞了。 献祭我的周六饭后时光 ","date":"2021-07-17","objectID":"/slice-chunking-in-go/:1:0","series":null,"tags":["go","reflect"],"title":"Go反射: 将切片按指定大小分块","uri":"/slice-chunking-in-go/#背景"},{"categories":["program"],"content":" 成果传入[]T，T可以是任意类型，按指定大小分块，返回[][]T。 例子中将[0,1,2,3,4,5,6,7,8,9]划分成了[0,1,2]、[3,4,5]、[6,7,8]、[9] https://github.com/kirito41dd/xslice go package main import ( \"fmt\" \"github.com/kirito41dd/xslice\" ) func main() { s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} i := xslice.SplitToChunks(s, 3) ss := i.([][]int) fmt.Println(ss) // [[0 1 2] [3 4 5] [6 7 8] [9]] } ","date":"2021-07-17","objectID":"/slice-chunking-in-go/:2:0","series":null,"tags":["go","reflect"],"title":"Go反射: 将切片按指定大小分块","uri":"/slice-chunking-in-go/#成果"},{"categories":["program"],"content":" 代码实现反射一把梭，自然离不了可爱的interface{} 欢迎复制或引包github.com/kirito41dd/xslice使用，如果以后搬砖遇到其他场景，也会继续扩充。 还是期待go泛型早点到来（那时候我rust应该已经很6了吧 go func SplitToChunks(slice interface{}, chunkSize int) interface{} { sliceType := reflect.TypeOf(slice) sliceVal := reflect.ValueOf(slice) length := sliceVal.Len() if sliceType.Kind() != reflect.Slice { panic(\"parameter must be []T\") } n := 0 if length%chunkSize \u003e 0 { n = 1 } SST := reflect.MakeSlice(reflect.SliceOf(sliceType), 0, length/chunkSize+n) st, ed := 0, 0 for st \u003c length { ed = st + chunkSize if ed \u003e length { ed = length } SST = reflect.Append(SST, sliceVal.Slice(st, ed)) st = ed } return SST.Interface() } ","date":"2021-07-17","objectID":"/slice-chunking-in-go/:3:0","series":null,"tags":["go","reflect"],"title":"Go反射: 将切片按指定大小分块","uri":"/slice-chunking-in-go/#代码实现"},{"categories":["default"],"content":"最近给IDE装了vim插件(ideaVim)，因为觉得写代码时候老是要去按上下左右，效率很低，更主要是low，不够装逼（ 但不建议独立使用vim，因为要大量练习才行，和IDE配合使用，可以把重点放在光标移动上，其余功能让IDE来负责。低成本装逼 ","date":"2021-07-14","objectID":"/zhuangbi-with-vim/:0:0","series":null,"tags":["vim"],"title":"vim装逼要点","uri":"/zhuangbi-with-vim/#"},{"categories":["default"],"content":" moveh j k l - ⬅️ ⬇️ ⬆️ ➡️ w/e - 跳转到下一个词 开头/末尾（按符号或空白分词） 助记 word / end W/E - 同上（按空白分词） b/ge - 跳转到上一个词 开头/末尾（按符号或空白分词） B/gE - 同上（按空白分词） f\u003c?\u003e/t\u003c?\u003e - 跳转到光标位置后指定 字符上/字符前，不跨行 比如 12345，使用f4后变为 12345，使用t4则为 12345 助记 find / to，;可以重复执行 F\u003c?\u003e/T\u003c?\u003e - 跳转到光标位置前指定 字符上/字符前，不夸行 % - 当前行如果有括号，移动到它的另一半 gg/G - 跳转到文件 开头/结尾 \u003cn\u003egg/\u003cn\u003eG - 跳转到指定行号 0/\u0026 - 移动到 行开头/末尾 ^、_/g_ - 移动到 行开头/末尾 第一个非空白字符 \u003cCtrl+b\u003e/\u003cCtrl+f\u003e - 向 上/下 滚一个屏幕 助记 back front \u003cCtrl+u\u003e/\u003cCtrl+d\u003e - 向 上/下 滚半个屏幕 助记 up down zz/zt/zb - 令光标行处于屏幕 中间/顶部/底部 助记 zoom zoom/top/bottom \u003cCtrl+o\u003e/\u003cCtrl+i\u003e - 光标跳转到jump list的 上一个位置/下一个位置 jump list里只记录跳转历史，简单移动光标不会被记录 :jump可以查看所有位置 m\u003ca-zA-Z\u003e - 如ma，标记当前光标位置，并起名为a 小写的名字只在当前缓冲区可见，大写可以跨缓冲区 :marks查看所有标记位置，你也会看到其他非字母的标记 '\u003ca-zA-Z\u003e/ `\u003ca-zA-Z\u003e - 如'a回到a位置所在在行首/ `a回到a位置 一个是单引号，一个是反引号，''永远返回上一个位置 zo/zc - 打开折叠/关闭折叠 zO/zC - 打开折叠/关闭折叠，递归 zM/zR - 关闭/打开 所有折叠 gd、\u003cCtrl+]\u003e - 跳转到定义，\u003cCtrl+t\u003e返回(用的是tag stack) Crtl+t 与 Ctrl+o 区别 ","date":"2021-07-14","objectID":"/zhuangbi-with-vim/:1:0","series":null,"tags":["vim"],"title":"vim装逼要点","uri":"/zhuangbi-with-vim/#move"},{"categories":["default"],"content":" 编辑dd/ \u003cn\u003edd - 删除当前行 / 删除n行 df\u003c?\u003e/dt\u003c?\u003e - 向后删除光标位置到指定字符 / 删除到指定字符前，不跨行 dF\u003c?\u003e/dT\u003c?\u003e - 反向，向前删除，同上 d$/d^ - 从光标删除到 行尾/行开头，用其他位置符也行 yy/\u003cn\u003eyy - 复制当前行/复制n行 p/P - 粘贴到当前 行后/行前，\u003cn\u003ep就是重复做n次 \"\u003creg\u003ey/\"\u003creg\u003ep - 复制到指定寄存器/从指定寄存器粘贴 命令模式:reg 可以看各个寄存器的内容 +寄存器通常与系统剪切板互通 di\"/da\" - 删除引号内的内容/连引号一起删，必须单行 助记 delete in \"\" / delete all \"\" 还有di(、di{等 x - 删除光标字符 r\u003c?\u003e - 用指定字符替换光标字符 ","date":"2021-07-14","objectID":"/zhuangbi-with-vim/:2:0","series":null,"tags":["vim"],"title":"vim装逼要点","uri":"/zhuangbi-with-vim/#编辑"},{"categories":["default"],"content":" 入场三连入场，神清气爽。从normal模式进入编辑模式 i/a - 在当前光标字符 前/后 插入 I/A - 在当前行 开头第一非空白字符前插入/结尾最后一个非空白字符后插入 o/O - 当前行 下面/上面 起新行 s - 删除当前字符并从该位置插入 ","date":"2021-07-14","objectID":"/zhuangbi-with-vim/:3:0","series":null,"tags":["vim"],"title":"vim装逼要点","uri":"/zhuangbi-with-vim/#入场"},{"categories":["program"],"content":"学习笔记，对标cpp理解下rust所有权以及借用的概念，顺便提下比较特殊的切片(DST) ","date":"2021-07-10","objectID":"/rust-ownership-and-borrowing/:0:0","series":null,"tags":["rust","ownership","DST"],"title":"Rust所有权与借用","uri":"/rust-ownership-and-borrowing/#"},{"categories":["program"],"content":" 所有权Ownershiprust中每个值都有一个所有者变量，并且同一时间只有能一个所有者，当值的所有者变量超出作用域，值的内存会被释放。 下面的代码String的所有权从s1转移到了s2，发生了Move，此时再访问s1是非法的。参考 rust let s1 = String::from(\"hello\"); let s2 = s1; 下面的代码i32的所有权没有从x转移到y，而是y复制了x，发生了Copy rust let x: i32 = 1; let y = x; Move本质上也是浅拷贝：比如String内部实现是有一个指针指向了保存的字符串，所有权转移，其实只是拷贝了这个指针的值，并没有拷贝这个字符串。这时s1和s2的内存空间都保存着这个指针地址，由于所有权的存在，编译器保证了访问s1是非法的，所以s1虽然还指向字符串，但是什么都做不了，保证了安全。 关于内存释放：由于只有在所有者生命完结后，才会发生释放，所有权保证同一时间只有一个所有者，所以字符串所在地址并不会被释放两次double free。 这里我想对标cpp：cpp实现类似高效转移使用的是右值引用与移动构造函数。在s2的移动构造函数中把s1的指针偷过来，然后把s1的指针指向一个空字符串的地址或标记其无效。s1是作为右值引用传过来的，在语义上是将亡值，所以可以修改s1内部结构。但是，cpp没有所有权概念，编译器不会阻止你继续访问s1。这很安全（个屁 rust在什么情况下Move什么情况下Copy，取决于类型是否实现了CopyTrait。上面i32本来已经很小了，也没东西可以浅拷贝（就4个字节折腾啥），所以i32是拷贝语义。 rust基本类型几乎都实现了CopyTrait： rust pub trait Copy: Clone { // Empty. 只是个Marker } 对于tuple、array，如果元素都实现了Copy，也会传拷贝。对于复杂类型，如果一个类型的某个部分实现了DropTrait，那么这个类型无法实现Copy；如果组成部分都实现了Copy，复杂类型也可以实现Copy。 所有权转移可以发生在赋值、传参、函数返回。 ","date":"2021-07-10","objectID":"/rust-ownership-and-borrowing/:1:0","series":null,"tags":["rust","ownership","DST"],"title":"Rust所有权与借用","uri":"/rust-ownership-and-borrowing/#所有权ownership"},{"categories":["program"],"content":" 引用references\u0026借用borrowing下面的代码中b并没有拿走所有权，而是通过\u0026取得了a的引用。 rust let a = String::from(\"123\"); let b = \u0026a; b是对a的引用也可以描述为b借用了a，rust引用的底层可以对标为其他语言中的指针，只不过rust的引用带了生命周期和借用检查所以很安全。如cpp中的指针只是记录值了一个内存地址，与一个整型并没有啥差别，可以被保存被带到任何地方，容易发生内存泄漏。而rust编译器会保证引用的生命周期不会超过其指向的值的生命周期。 引用分为不可变引用immutable references与可变引用mutable references，获取可变引用使用let b = \u0026mut a，前提是a是可变的才能获取可变引用，可变引用与不可变引用的关系类似读写锁： 可以同时存在多个不可变引用(读锁) 可变引用与不可变引用不能同时存在(读、写锁互斥) 只能同时有一个可变引用(写锁) ","date":"2021-07-10","objectID":"/rust-ownership-and-borrowing/:2:0","series":null,"tags":["rust","ownership","DST"],"title":"Rust所有权与借用","uri":"/rust-ownership-and-borrowing/#引用references借用borrowing"},{"categories":["program"],"content":" 切片slice切片很特殊，用来引用数组中的连续元素序列。 字符串切片string slices - \u0026str let s = String::from(\"hello world\"); let hello = \u0026s[0..5]; let s: \u0026str = \"xxx\"; let s2: \u0026str = \u0026s[..]; 字符串切片特殊点是范围只能取有效的utf8字符边界 数组切片 - \u0026[T] let a = [1, 2, 3, 4, 5]; let slice = \u0026a[1..3]; 切片用[start..end]来确定引用范围，区间左闭右开[start,end)。范围还可以简写为[..2]、[3..]、[..]，省略表示取边界。 切片是个胖指针，会保存目标集合的指针，与引用范围。 切片之所以特殊，需要说下rust的动态大小类型Dynamic Sized Type,DST，DST表示编译期无法获取大小的类型。 从数组说起，数组的类型表示为[T; N]，T是元素类型而N是元素个数，所以数组的大小编译期是可以确定的，数组不是DST。注意\u0026[i32; 3]是一个普通的数组引用，而\u0026[i32]才是一个数组切片。 切片是DST，准确来说[i32]才叫做切片，[T]这种类型表示由T组成的切片，这个切片的长度在编译期是不确定的（DST），编译器无法为一个不确定大小的类型分配空间，所以也无法声明DST类型的变量，只能用胖指针\u0026[T]来引用。 \u0026[T]的大小是固定的，里面有用于存储数据地址和长度的空间，这样就可以在运行时获取长度信息。比如要制造切片[1..n]，n的大小是编译期间无法得到的，所以只能在运行期间计算n的值，然后初始化胖指针完成引用。 字符串切片str也是DST，对应胖指针是\u0026str，可以把str理解为[T]的特殊形式，主要是用来表示utf8字符串。 除了切片，dyn Trait(Trait对象)也是DST，对应的胖指针是\u0026dyn Trait。（只要是DST类型，就无法声明对应类型变量 ","date":"2021-07-10","objectID":"/rust-ownership-and-borrowing/:2:1","series":null,"tags":["rust","ownership","DST"],"title":"Rust所有权与借用","uri":"/rust-ownership-and-borrowing/#切片slice"},{"categories":["program"],"content":"RCURead Copy Update这个词最近才听到，是在公司一位老哥的直播分享里听到的。那天在群里没事乱划，突然看到一个直播分享，原本就想进去嫖一眼，结果内容异常硬核，从头看到尾。 topic是用类似JITJust In Time的方式加速Go的json解析，这里顺便给他们打个广告，这个库开源了：https://github.com/bytedance/sonic 分享里提到了RCU这种技术，RCU原本是Linux内核中的一种同步机制，并且其针对的场景是读多写少。分享里他们遇到的场景是需要实现一个buffer，特性是： 读操作远多于写操作 希望读操作无锁、无等待 这样的场景非常适合使用RCU这种技术，RCU的基本实现是： 读使用原子操作读取数据指针，无锁、无等待 写/更新操作用互斥锁防护 不直接写/更新，而是先复制一份，对复制的数据进行写/更新 通过原子操作将数据指针指向刚修改过的副本 注：由于可能涉及资源释放，所以在有GC的语言上更容易实现 本质上就是牺牲写性能，提升读性能 代码也非常简单，只用互斥锁和一个原子变量就可以实现： go type RCU struct { m sync.Mutex p unsafe.Pointer } func (r *RCU) Get(key K) V { return (*Map[K]V)(atomic.LoadPointer(\u0026r.p))[key] } func (r *RCU) Put(key K, val V) { r.m.Lock() defer r.m.Unlock() newm := new(Map[K]V) atomic.StorePointer(\u0026r.p, unsafe.Pointer(newm)) } 简单说一下，代码中Map、K、V都是虚拟的，可以根据需要更换（也不局限于KV）。 主要思想是通过原子操作，来更换指针指向的地址。 对于读，每次都会读出一个安全的数据地址，不会有其他线程修改这段数据，所以无需同步手段。 对于写，同时只能有一个写，否则存在丢失更新，所以加互斥锁防护。 由于写都是在拷贝上进行，所以不会影响读的性能 NICE！！！ ","date":"2021-06-28","objectID":"/read-copy-update/:0:0","series":null,"tags":["RCU","sync"],"title":"Read Copy Update","uri":"/read-copy-update/#"},{"categories":["default"],"content":"明德新民 止于至善 感觉校歌是真滴好听！ 嵩岳苍苍 河水泱泱， 中原文化悠且长， 济济多士 风雨一堂， 继往开来扬辉光， 四郊多垒 国仇难忘， 民主是式 科学允张， 猗欤吾校永无疆！ 猗欤吾校永无疆！ 从2017到2021，由于疫情的关系整整一年半没有呆在学校，就感觉四年过的非常快。大三下学期在被窝中完成课业，大四还没开学就顶着疫情去北京实习了。四年前的我还是个一无所知的少年，四年后蜕变成了一个一无所知的青年（ 学生的身份就此结束了，没有选择继续读研，原因有很多： 不会学习，对不感兴趣的课一点都听不进去 喜欢操代码，感觉可以直接工作（事实证明我确实可以 拿过一些奖项，但由于非专业课业成绩差点，还是离保研差了一步 考研是不可能考研的，很反感硕士考题。（看室友备考时来问我的题目，谭浩强年代的C，净考一些没有意义的玩意。 硕士了又怎样（ 希望以后不会对自己的选择后悔 大学四年也成长了很多，感谢我的两任女朋友(前任与现任) 照片🐎一下我sqdl，网络并非法外之地 最后，疾风亦有归途🐶 ","date":"2021-06-07","objectID":"/bi-ye-leee/:0:0","series":null,"tags":[],"title":"毕业了！！！","uri":"/bi-ye-leee/#"},{"categories":["program"],"content":"在linux系统中，通过bash中输入\u003cCtrl+C\u003e或者使用命令kill -9 $pid都可以杀死进程，但是它们有很大的不同。 先放结论：kill命令只会杀死目标进程，而bash快捷键则会杀死整个前台进程组！ ","date":"2021-05-07","objectID":"/different-from-ctrl-c-and-kill/:0:0","series":null,"tags":["bash","signal","linux"],"title":"Ctrl+C与Kill杀死进程的区别","uri":"/different-from-ctrl-c-and-kill/#"},{"categories":["program"],"content":" linux杀进程方式不管使用那种方式，杀死进程都是通过发送信号（signal）来完成的，kill命令其实就是向目标pid进程发送信号： kill -9 - 发送SIGKILL kill -2 - 发送SIGINT kill -15 - 发送SIGTERM 完整列表如下： bash # kill -l HUP INT QUIT ILL TRAP ABRT EMT FPE KILL BUS SEGV SYS PIPE ALRM TERM URG STOP TSTP CONT CHLD TTIN TTOU IO XCPU XFSZ VTALRM PROF WINCH INFO USR1 USR2 bash快捷键发送信号方式如下： INT - \u003cCtrl+C\u003e KILL - \u003cCtrl+\\\u003e ","date":"2021-05-07","objectID":"/different-from-ctrl-c-and-kill/:1:0","series":null,"tags":["bash","signal","linux"],"title":"Ctrl+C与Kill杀死进程的区别","uri":"/different-from-ctrl-c-and-kill/#linux杀进程方式"},{"categories":["program"],"content":" 前台进程组会话是一个或多个进程组的集合，每登陆一个终端就相当于一个新会话，一个会话可以有一个前台进程组和多个后台进程组。 默认通过bash启动的程序，都会放在前台进程组，包括这个程序的子进程。 如果要放在后台进行组，可以使用\u0026指定 bash echo 123 \u0026 （另外，只有前台启动才会绑定标准输入输出。） 在bash中通过\u003cCtrl+C\u003e或\u003cCtrl+\\\u003e杀死进程，信号会被发送至前台进程组中的每一个进程。 而通过kill杀死程序，信号只会发送给目标pid进程。 ","date":"2021-05-07","objectID":"/different-from-ctrl-c-and-kill/:2:0","series":null,"tags":["bash","signal","linux"],"title":"Ctrl+C与Kill杀死进程的区别","uri":"/different-from-ctrl-c-and-kill/#前台进程组"},{"categories":["program"],"content":" 验证程序1: go package main import ( \"time\" \"os/exec\" ) func main(){ cmd := exec.Command(\"sleep\", \"100000\") cmd.Start() time.Sleep(time.Second * 99999) return } 上面的程序启动子进程运行sleep命令，然后睡眠。 测试结果： 用 kill -9、-2、-15 分别杀死主进程，sleep子进程存活。 用 \u003cCtrl+C\u003e、\u003cCtrl+\\\u003e分别杀死主进程，sleep子进程被杀。 程序2 go package main import( \"time\" \"os/exec\" \"syscall\" ) func main(){ cmd := exec.Command(\"sleep\", \"100000\") // 将子进程放入新的进程组 cmd.SysProcAttr = \u0026syscall.SysProcAttr{Setpgid: true, Pgid: 0} cmd.Start() time.Sleep(time.Second * 99999) return } 上面的程序同程序1一样，区别是给子进程设置了单独的进程组（此时子进程就不在前台进程组中了）。 测试结果： 用 kill -9、-2、-15 分别杀死主进程，sleep子进程存活。 用 \u003cCtrl+C\u003e、\u003cCtrl+\\\u003e分别杀死主进程，sleep子进程存活！ ","date":"2021-05-07","objectID":"/different-from-ctrl-c-and-kill/:3:0","series":null,"tags":["bash","signal","linux"],"title":"Ctrl+C与Kill杀死进程的区别","uri":"/different-from-ctrl-c-and-kill/#验证"},{"categories":["program"],"content":"记录下日常搬砖过程中的踩坑和学到的骚操作，随缘更新。 ","date":"2021-04-01","objectID":"/crud-boy/:0:0","series":null,"tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/#"},{"categories":["program"],"content":" 无分类 给前端返回json时候，千万别用int64，老老实实string，不然浏览器parse后溢出，因为js的number表示不了int64 ","date":"2021-04-01","objectID":"/crud-boy/:1:0","series":null,"tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/#无分类"},{"categories":["program"],"content":" MySQL mysql中字符串类型索引查询时必须加引号，不然不会使用索引。原因是不支持函数索引，不加引号会使用了cast函数做隐式类型转换。(这里一般是int到string的cast 有时候写子查询嵌套非常多，可以使用with as优化可读性，装逼点这玩意叫公用表表达式common table expression,CTE sql with t1 as (select * from xxx) select * from t1; -- 必须紧跟着就使用,不用就销毁了 ","date":"2021-04-01","objectID":"/crud-boy/:2:0","series":null,"tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/#mysql"},{"categories":["program"],"content":" On Conflict遇到的场景是去优化有大量的数据需要upsert的场景：数据不存在就插入，数据存在就更新。接手时的实现是每次都做两次网络io，先判断是否存在，然后做更新操作。为了节省大量的io时间，我开始寻求更好的解决方案。 刚开始的思路是找类似redis pipline的方式：构造一个pipline，往里面赛语句，然后exec，才会发生网络io，redis服务器会按顺序执行所有语句。这和在mysql里用拼接多条语句很类似，发现只能实现批量插入，因为upsert还有一个判断逻辑。 最终开始求助公司大佬：得出的结论是使用Conflict. https://gorm.io/docs/create.html#Upsert-On-Conflict sql -- MERGE INTO \"users\" USING *** WHEN NOT MATCHED THEN INSERT *** WHEN MATCHED THEN UPDATE SET \"name\"=\"excluded\".\"name\"; SQL \u003e Server -- INSERT INTO \"users\" *** ON CONFLICT (\"id\") DO UPDATE SET \"name\"=\"excluded\".\"name\", \"age\"=\"excluded\".\"age\"; PostgreSQL INSERT INTO `users` *** ON DUPLICATE KEY UPDATE `name`=VALUES(name),`age=VALUES(age); 原理是利用唯一键的冲突，在发生冲突时做更新操作。 利用冲突做大批量upsert操作 拼sql,尝试一次插入多列，定义冲突时更新的字段 表中必须存在唯一键(primary key 或 unique key)才能使用 sql INSERT INTO `users` (id, name) VALUES (1, \"jinzhu1\"), (2, \"jinzhu2\") ON DUPLICATE KEY UPDATE `name` = VALUES(name) ","date":"2021-04-01","objectID":"/crud-boy/:2:1","series":null,"tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/#on-conflict"},{"categories":["program"],"content":" ES es创建mapping踩坑,text会把索引字段分词，搜索用match而不能用term，keyword不会进行分词 ","date":"2021-04-01","objectID":"/crud-boy/:3:0","series":null,"tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/#es"},{"categories":["program"],"content":" TotalHits != Hitses查询结果，searchResult.TotalHits()与len(searchResult.Hits.Hits)不一致，原因 下面的代码panic了，以为TotalHits \u003e 0就肯定Hits里有数据，结果数组长度是0，访问越界。 TotalHits是本次查询命中了多少记录，Hits里是实际返回的数据，由于分片的查询队列满了，所以没有查询到任何数据。 searchResult.Shards.Failures里有报错信息： txt rejected execution of org.elasticsearch.transport.TcpTransport$RequestHandler@xxx on EsThreadPoolExecutor [ search, queue capacity = 1000, org.elasticsearch.common.util.concurrent.EsThreadPoolExecutor@xxx [ Running, pool size = 13, active threads = 13, queued tasks = 1000, completed tasks = 919466345 ] ] ","date":"2021-04-01","objectID":"/crud-boy/:3:1","series":null,"tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/#totalhits--hits"},{"categories":["program"],"content":" Hive hive里也可以使用with as，注意区分和临时表的区别，临时表储存在磁盘的临时区中，只有数据库连接断开，或者drop掉才会消失 ","date":"2021-04-01","objectID":"/crud-boy/:4:0","series":null,"tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/#hive"},{"categories":["program"],"content":" 创建变量在mysql创建和使用变量可以这样： sql set @id = 1; select * from xxx where id = @id; 在hive里可以这样： sql set date = 'xxx'; select * from xxx where date = ${hiveconf:date} ","date":"2021-04-01","objectID":"/crud-boy/:4:1","series":null,"tags":["crud","mysql"],"title":"crud boy","uri":"/crud-boy/#创建变量"},{"categories":["default"],"content":" RSA 算法原理","date":"2021-01-31","objectID":"/rsa/:0:0","series":null,"tags":["RSA"],"title":"RSA算法原理","uri":"/rsa/#rsa-算法原理"},{"categories":["default"],"content":" 数论知识质数 ​ 大于1的自然数中，只能被1和它本身的数整除，如 2、3、5、7 互质关系： ​ 如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系 1与任何数都互质 任意两个质数都互质 质数与小于它的每一个数，都构成互质关系。如5与1、2、3、4都构成互质关系 欧拉函数： ​ 任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？计算这个值的方法就叫做欧拉函数，以符号$\\phi(n)$表示 $\\phi(1)=1$ 如果n为质数，则 $\\phi(n)=n-1$ 如果n是两个互质的整数之积 $n=p_1\\times p_2$ 则 $\\phi(n)=\\phi(p_1)\\times \\phi(p_2)$ 欧拉定理： ​ 如果两个正整数a和n互质，则下面的公式成立： $$ a^{\\phi(n)} \\equiv 1 \\pmod n $$ 模反元素： ​ 如果两个正整数a和n互质，那么一定可以找到b，使得下面的公式成立： $$ ab\\equiv1\\pmod n $$ ​ 证明模反元素必然存在，把欧拉定理拆开，$a\\times a^{\\phi(n)-1} \\equiv 1 \\pmod n$, $a^{\\phi(n)-1} + kn$ 全都是模反元素 ","date":"2021-01-31","objectID":"/rsa/:1:0","series":null,"tags":["RSA"],"title":"RSA算法原理","uri":"/rsa/#数论知识"},{"categories":["default"],"content":" 密钥生成步骤随机选择两个不相等的质数p和q (越大越好) 计算p和q的乘积 $n=p\\times q$ 计算n的欧拉函数 $\\phi(n)=(p-1)(q-1)$ 随机选择一个整数e, $1\u003ce\u003c\\phi(n) 且 e与\\phi(n)互质$ 计算e对于$\\phi(n)$的模反元素d（知道e和$\\phi(n)$就可以计算出模反元素，使用扩展欧几里德算法） 公布(n,e)为公钥、(n,d)为私钥 ","date":"2021-01-31","objectID":"/rsa/:2:0","series":null,"tags":["RSA"],"title":"RSA算法原理","uri":"/rsa/#密钥生成步骤"},{"categories":["default"],"content":" 加密和解密加密：公钥(n,e) 加密信息为m, m必须是整数，且m必须小于n 加密就是算出下面式子中的c: $$ m^e\\equiv c \\pmod n $$ 即密文 $c=m^e\\bmod n$ 解密： 私钥(n,d) 下面的等式一定成立: $$ c^d \\equiv m \\pmod n $$ 即明文 $m = c^d\\bmod n$ ","date":"2021-01-31","objectID":"/rsa/:3:0","series":null,"tags":["RSA"],"title":"RSA算法原理","uri":"/rsa/#加密和解密"},{"categories":["default"],"content":" 证明 $$ 为什么\\ \\ c^d \\equiv m \\pmod n \\ \\ \\ (1) \\\\ \\because m^e\\equiv c \\pmod n\\\\ \\therefore c = m^e-kn\\\\ c带入(1)得 \\ (m^e - kn)^d \\equiv m \\pmod n\\\\ 等同与\\ m^{ed}\\equiv m \\pmod n \\ \\ (2)\\\\ (比如(a+b)^2 = a^2 + 2ab + b2，只有a得最高项不带b) \\\\ \\because ed \\equiv 1 \\pmod{\\phi(n)}\\\\ \\therefore ed = h\\phi(n) +1 \\\\ 将ed带入(2)得 \\ m^{h\\phi(n)+1} \\equiv m \\pmod n \\ \\ \\ (3)\\\\ $$ 证明(1)就是证明（3）： 如果 m 和 n 互质 $$ 由欧拉定理得\\ m^{\\phi(n)}\\equiv 1 \\pmod n \\ \\\\ \\because m\\equiv m \\pmod n \\\\ 同余式相乘性质：若a≡b(mod\\ n)，c≡d(mod\\ n)，则ac≡bd(mod\\ n)。\\\\ (m^{\\phi(n)})^h\\times m \\equiv m \\times1^h \\pmod n \\\\ m^{h\\phi(n)+1} \\equiv m \\pmod n\\\\ 证明完成 $$ 如果 m 和 n 不互质 $$ \\because n = pq\\ (质因子)\\\\\\therefore 必然有\\ m = kp\\ 或\\ m=kq\\ (公因子只能是p或q)\\\\以\\ m=kp\\ 为例，k与q必然互质,因为m和n只可能有一个公因子\\\\kp与q也互质（m，n不互质，n失去与m唯一的公因子后肯定互质）\\\\根据欧拉定理\\ (kp)^{q-1} \\equiv 1 \\pmod q \\ (自己多次乘上自己，再两边同时乘kp)\\\\进一步得到\\ [(kp)^{q-1}]^{h(p-1)} \\times kp \\equiv kp \\pmod q\\\\\\because ed = h\\phi(n) +1 \\\\化简\\ (kp)^{ed} \\equiv kp \\pmod q\\\\改写成\\ (kp)^{ed} = kp + tq\\\\这时t必然能被p整除,即\\ t=t'p\\ (因为(kp)^{ed}一定是p的整倍数)\\\\(kp)^{ed} = kp+t'pq\\\\\\because m=kp, n=pq\\\\\\therefore m^{ed}=m+t'n\\\\\\therefore m^{ed} \\equiv m \\pmod n\\\\证明完成 $$ ","date":"2021-01-31","objectID":"/rsa/:4:0","series":null,"tags":["RSA"],"title":"RSA算法原理","uri":"/rsa/#证明"},{"categories":["default"],"content":" 参考https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html ","date":"2021-01-31","objectID":"/rsa/:5:0","series":null,"tags":["RSA"],"title":"RSA算法原理","uri":"/rsa/#参考"},{"categories":["btc"],"content":" 说明推荐下我使用过的钱包，来给你提供建议。 太长不看: 桌面端用 Electrum 移动端 BlueWallet 其他交易所推出的钱包不推荐，夹私货太多… ","date":"2021-01-05","objectID":"/btc-wallet/:1:0","series":null,"tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/#说明"},{"categories":["btc"],"content":" Bitcoin Core 关键信息： 平台：Windows、Linux、MacOS 获取：https://bitcoin.org/zh_CN/download 源代码：https://github.com/bitcoin/bitcoin 全节点：是 核心钱包是全节点钱包，意味着你需要同步并存储所有区块数据。截止到2021年，区块数据约350GB，你至少需要保证500GB的存储空间以应对未来的数据增长。虽然全节点能够使区块链更安全，但不建议小白同步。因为如果你的全节点不能以服务的形式存在（通常需要一个公网IP），那么别人并不能主动和你建立链接，意义不大。提供全节点服务以保障区块链安全的使命请交给其他有情怀的专业人士。对于非专业人士（特指不是程序员）操作过于繁琐，不建议使用。 优点： 开源，意味着更安全，开发者不受任何人控制。 支持HD钱包: bip32「分层确定性(Hierarchical Deterministic)钱包」 有强大的命令行，不过需要大量学习 缺点： 新版本不支持生成1开头的地址（我平时不用的理由 要时常备份钱包文件（找零机制，外部导入私钥 这些都需要备份才行） 学习成本高 ","date":"2021-01-05","objectID":"/btc-wallet/:2:0","series":null,"tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/#bitcoin-core"},{"categories":["btc"],"content":" Electrum 关键信息： 平台：Windows、Linux、MacOS、Android（超难看） 获取：https://electrum.org 源代码：https://github.com/spesmilo/electrum 全节点：否 Electrum是一个轻节点钱包，你不用同步节点数据，而是由别人提供的服务器来帮你广播、查询交易。这些服务器不会存储你的私钥（也做不到）。你只需要连接一些服务器，就能够安全的完成交易。 优点： 使用方便 支持HD钱包，支持助记词（但不是bip39） 功能强大，兼容所有地址类型 支持闪电网络! 缺点： 不支持导出bip39助记词，使用的是自定义版本，但可以导入bip39 只能使用桌面版本，移动端不支持（Android版本做的太垃圾了 除了上面，我觉得完美 ","date":"2021-01-05","objectID":"/btc-wallet/:3:0","series":null,"tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/#electrum"},{"categories":["btc"],"content":" Imtoken 关键信息： 平台：Android、iOS 获取：谷歌商店、App Store、https://token.im 部分源代码：https://github.com/consenlabs/token-core 全节点：否 Imtoken是一个主打移动端的轻节点钱包，并且支持多币种，能满足日常使用。 优点： HD钱包，支持导出bip39助记词 同时支持隔离见证地址和普通地址 对地址私钥控制方便，可以任意导出 缺点： 多币种钱包（我只需要btc，有支持山寨币的精力不如好好搞闪电网络 有官方的一些推送内容 夹私货，推销自己的平台币 ","date":"2021-01-05","objectID":"/btc-wallet/:4:0","series":null,"tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/#imtoken"},{"categories":["btc"],"content":" Bither 关键信息： 平台：Android、iOS、(桌面不推荐) 获取：谷歌商店、App Store、https://bither.net 源代码：https://github.com/bither 全节点：否(SVP) Bither是一个SVP钱包，需要同步节点数据，但无需存储全量数据。 优点： SVP钱包，同时支持冷热两种模式（第一次启动时断网，可以看到冷钱包选项） 完全开源，移动端最可信的钱包 钱包上生成的私钥随机性很强 缺点： 私钥导入不支持bip39，只能明文、加密后、或二维码 功能上不是很强（但我主力使用这个，imtoken上都是零头 只推荐有一定基础的玩家使用 ","date":"2021-01-05","objectID":"/btc-wallet/:5:0","series":null,"tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/#bither"},{"categories":["btc"],"content":" Onekey 关键信息： 平台：Android、iOS、Windows、Linux、MacOS 获取：谷歌商店、App Store、https://www.onekey.so 源代码：https://github.com/OneKeyHQ/app-monorepo 全节点：否 我2023年刚开始使用的钱包，支持多币种，还有配套硬件 优点： HD钱包，支持导出bip39助记词 同时支持隔离见证地址和普通地址 完全开源(比imtoken更透明) 活跃，直接在discord上反映问题回复很快 缺点： 多币种钱包（我只需要btc，有支持山寨币的精力不如好好搞闪电网络 ","date":"2021-01-05","objectID":"/btc-wallet/:6:0","series":null,"tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/#onekey"},{"categories":["btc"],"content":" BlueWallet 关键信息： 平台：Android、iOS 获取：谷歌商店、App Store、https://bluewallet.io 源代码：https://github.com/bluewallet/bluewallet 全节点：否 2023年才发现，相见恨晚 优点： HD钱包，支持导出bip39助记词 同时支持隔离见证地址和普通地址，还支持多签账户 完全开源(比imtoken更透明) 支持闪电网络，基于LndHub 够纯粹，只有比特币和闪电网络，没有其他一堆垃圾币塞在里面。支持一些硬件钱包 缺点： 官方关闭了自己维护的LndHub节点，为了推动去中心，所以闪电网络功能得使用门槛提高了，可能要自己搭节点 ","date":"2021-01-05","objectID":"/btc-wallet/:7:0","series":null,"tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/#bluewallet"},{"categories":["btc"],"content":" 闪电网络钱包Damus的出现简直就是闪电网络科普，小额支付就用闪电网络 桌面用Electrum即可，移动端高级用户可以自己搭节点用BlueWallet ","date":"2021-01-05","objectID":"/btc-wallet/:8:0","series":null,"tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/#闪电网络钱包"},{"categories":["btc"],"content":" Phoenix 关键信息： 平台：Android、iOS 获取：谷歌商店、App Store、https://phoenix.acinq.co 源代码：https://github.com/ACINQ/phoenix 类型：非托管 优点： 非托管，助记词掌握在自己手中 缺点： 需要自己开辟闪电通道，有时和别人转账会出现没有通路的情况 ","date":"2021-01-05","objectID":"/btc-wallet/:8:1","series":null,"tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/#phoenix"},{"categories":["btc"],"content":" WalletOfSatoshi 关键信息： 平台：Android、iOS 获取：谷歌商店、App Store、https://www.walletofsatoshi.com 类型：托管 优点： 使用简单，不用担心闪电通道 缺点： 托管类钱包，你使用的是三方服务，安全性不如非托管钱包 ","date":"2021-01-05","objectID":"/btc-wallet/:8:2","series":null,"tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/#walletofsatoshi"},{"categories":["btc"],"content":" 推荐阅读 bip32、bip39、bip44 比特币闪电网络就是最牛，不接受反驳！ ","date":"2021-01-05","objectID":"/btc-wallet/:9:0","series":null,"tags":["btc"],"title":"比特币钱包推荐","uri":"/btc-wallet/#推荐阅读"},{"categories":["btc"],"content":" 说明为了给小白说清： 私钥 公钥 地址 钱包 交易所 咋获得比特币 简单粗暴，不讲原理，不讲原理，不讲原理 ","date":"2020-12-04","objectID":"/btc-start/:1:0","series":null,"tags":["btc"],"title":"写给小白的比特币入门","uri":"/btc-start/#说明"},{"categories":["btc"],"content":" 定理(雾说了不讲原理，就当这是定理 私钥 →公钥 → 地址 按箭头方向，知道前面的，就能计算出后面的，反过来不行 因此 私钥 最重要！ 他们长啥样： 私钥 - KwYC54hbaH6X5CrCfDK19oyJd2d1ivnSakbJxrW4ENbi2E2bJkbN 公钥 - 2f6e7sUQhP6z6mTMhh...(略)...16ME6Y18QSM 地址 - 16PXzomhwDovGRHaN6WGZXxk5BB1e78dn7 公钥很长不方便记忆，所以都用地址 ","date":"2020-12-04","objectID":"/btc-start/:2:0","series":null,"tags":["btc"],"title":"写给小白的比特币入门","uri":"/btc-start/#定理雾"},{"categories":["btc"],"content":" 比特币是如何交易的一个地址相当于一个账户，比特币通过地址互相转账 谁都可以向一个地址转账，但是要花地址里的钱，必须知道私钥 这就是为什么私钥最重要 比特币的区块链上记录的就是地址之间的转账记录 有转账记录，就能算出地址里有多少钱 ","date":"2020-12-04","objectID":"/btc-start/:3:0","series":null,"tags":["btc"],"title":"写给小白的比特币入门","uri":"/btc-start/#比特币是如何交易的"},{"categories":["btc"],"content":" 什么是钱包一个地址就是一个账户，每个人名下都可能有很多账户 但是有一个地址就肯定有一个私钥 钱包就是帮你管理私钥的 钱包一般都有一下功能： 帮你计算你拥有多少钱（就是从区块链上计算地的地址里有多少比特币） 备份，如果你手机或电脑丢了，有备份就能找回你的私钥 交易，给别的地址转账 帮你自动生成私钥（也就是地址） 为什么每个人要有很多地址，而不是一个： 谁都可以从区块链上计算出某个地址的交易记录，如果你一直使用一个地址，你的隐私可能就暴漏了 一般是不能从地址推算出拥有这个地址的人是谁的，但如果你用的时间长了，比如从某个网址买东西用这个地址转账了，就能吧地址和你这个人联系起来，就知道你是谁了 由于地址可以凭空产生，谁都可以轻易生成(后面讲) 所以转账都用很多不同地址，不过这些事情钱包帮你做了，小白可能感觉不到 你可能担心钱包安全性，但他们大多是安全的，前提是知名钱包，可以看钱包推荐 ","date":"2020-12-04","objectID":"/btc-start/:4:0","series":null,"tags":["btc"],"title":"写给小白的比特币入门","uri":"/btc-start/#什么是钱包"},{"categories":["btc"],"content":" 如何生成地址谁都可以生成一个私钥，从而生成地址 私钥本质上是256个0和1组成的二进制串，然后编码成字符串 这256个0和1是随机的，所以你连续抛256次硬币，就能得到一个地址 这里随机非常重要，如果你只是凭喜好写出了256个0和1，那和你有相同习惯的人也可能写出来跟你一样的0和1,等于你的私钥被别人知道了。 没人会去抛硬币吧应该，大家都用软件生成私钥，这些软件都有自己的随机方法 这是一个安全的网站：www.bitaddress.org 根据你的鼠标位置取样，生成随机的私钥 冷钱包： 在离线的安全的环境下生成一个私钥，这个私钥只有你知道。 如果还能在离线环境签名交易，这个操作就是冷钱包的功能 只要你不联网，就没有泄漏的可能(流氓软件太多)，冷钱包就是一套离线解决方案 当然发布交易还是需要网络，可以把签名后的信息生成二维码，让联网设备读取、发布。 （用市面上常见的钱包已经很安全了 ","date":"2020-12-04","objectID":"/btc-start/:5:0","series":null,"tags":["btc"],"title":"写给小白的比特币入门","uri":"/btc-start/#如何生成地址"},{"categories":["btc"],"content":" 交易所如果你在币圈没有熟人，可以到交易所买比特币 交易所和股票那个交易所的职能差不多 你在上面买的比特币都被存在交易所里，可以提出来，但有手续费 交易所不会吧私钥给你，也就是说你只能通过交易所把比特币提出来，如果交易所跑路了，你币就没了(概率极低、喜闻乐见) ","date":"2020-12-04","objectID":"/btc-start/:6:0","series":null,"tags":["btc"],"title":"写给小白的比特币入门","uri":"/btc-start/#交易所"},{"categories":["default"],"content":" 这个博客是怎么来的问就是白嫖github page，白嫖太爽了( 静态博客的生成器使用的是Hugo、主题使用的LoveIt、评论系统使用Disqus，LoveIt这个主题已经集成好了Disqus。 由于使用静态博客生成器，在每次改动后都需要重新运行一次生成命令，生成一大堆静态文件，再提交到gh-page，很麻烦。 为了让这个过程更加优雅，可以吧生成静态文件和部署这个过程放到CI里自动化完成。这里使用了github workflow的Action功能。 这样一来，只需要在本地编辑博客内容，然后push到github，就会自动触发CI流程，将生成的静态内容部署到XXX.github.io，也就是gh-page的仓库。 ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:1:0","series":null,"tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/#这个博客是怎么来的"},{"categories":["default"],"content":" 准备工作我一共新建了两个仓库： XXX.github.io， gh-page仓库,由CI负责提交 blog，存放博客文件 主要工作是都在blog这个仓库上进行，另一个仓库是自动化操作的。 blog存放了博客的主要骨架，还有一些脚本，方便在CI中做一些工作。 申请一个Github Application，如果你想使用Gitalk代替Disqus 申请一个Personal access tokens，CI流程中使用它来对XXX.github.io仓库进行提交，涉及到鉴权。 Github Application 和 Personal access tokens 都是需要保密的，不能直接写在配置文件里或这CI流程的脚本里。好在github的Workflow提供了在CI中访问仓库中配置的秘密环境变量的能力。 进入仓库-\u003eSettings-\u003eSecrets-\u003enew Secret，配置两个环境变量，如下： ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:2:0","series":null,"tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/#准备工作"},{"categories":["default"],"content":" 杂项使用了腾讯的对象存储来存图片，可有可无。 一个域名，可有可无。 阿里云的CDN，可有可无。 ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:3:0","series":null,"tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/#杂项"},{"categories":["default"],"content":" blog搭建过程首先看下我(本地)仓库的目录情况，github地址 sh . ├── .github │ └── workflows │ └── main.yml # github workflow 的action配置文件(CI脚本) ├── .gitmodules # git submodule 创建的，为了引入LoveIt ├── README.md ├── bin # 这个目录是脚本生成的，里面有hugo命令，不会被提交到仓库 ├── script │ └── get-hugo.sh # 本地 CI 都可以执行，用来获取hugo命令 └── site # 站点目录，存放hugo博客的骨架 ├── archetypes ├── config.toml ├── config.tomlconfig.toml ├── content # 存放博客内容的地方 ├── data ├── layouts ├── public # hugo生成的静态博客 ├── resources ├── static # static 目录在生产静态文件时，会被拷贝到public │ ├── .nojekyll # 两个文件最终都会出现在gh-page仓库的根目录 │ └── CNAME # 如过有域名需要这个 └── themes └── LoveIt # submodule方式引入，LoveIt主题 .gitignore忽略文件 text bin/ public/ ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:4:0","series":null,"tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/#blog搭建过程"},{"categories":["default"],"content":" 骨架初始化git仓库后，首先编写了一个脚本script/get-hugo.sh，这个脚本的功能是自动根据系统类型下载hugo,并解压到脚本所在位置的上级目录下的bin文件夹。脚本只支持mac或linux系统，CI也会用到这个脚本，windows用户可以手动安装。 bash # 此脚本安装hugo到脚本所在位置的../bin目录 CURDIR=$(cd $(dirname $0); pwd) cd $CURDIR echo \"执行目录 `pwd`\" # 判断环境是mac还是linux,决定hugo版本 if [ $(uname -s) = 'Darwin' ];then echo '当前环境为Darwin' HUGOURL='https://github.com/gohugoio/hugo/releases/download/v0.77.0/hugo_extended_0.77.0_macOS-64bit.tar.gz' else echo '当前环境为Linux' HUGOURL='https://github.com/gohugoio/hugo/releases/download/v0.77.0/hugo_extended_0.77.0_Linux-64bit.tar.gz' fi echo \"hugo 获取地址:$HUGOURL\" echo '开始下载' curl -sSL -o hugo.tar.gz $HUGOURL if [ $? -ne 0 ];then echo '下载失败' exit 1 fi # 解压文件 BINDIR=\"$CURDIR/../bin\" if [ ! -d \"$BINDIR\" ];then mkdir $CURDIR/../bin fi echo \"解压到 $BINDIR\" tar -xzf ./hugo.tar.gz -C $CURDIR/../bin rm ./hugo.tar.gz # 验证下解压安装成功 echo 'success' $BINDIR/hugo version 执行sh scrpit/get-hugo.sh，就可以使用hugo了，执行bin/hugo vesion打印hugo版本。 然后创建站点，执行： sh bin/hugo new site . 生成site目录。 sh tree ./site . ├── archetypes ├── config.toml # 配置文件 ├── content ├── data ├── layouts ├── static └── themes # 主题文件夹 下一步拉取主题，我使用的是LoveIt。 sh # 在site目录执行 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt # 注意有了submodules后，再从别的地方拉取仓库记得 # git submodule init # git submodule update 参考LoveIt的文档，配置好config.toml文件 我的配置中需要说明的只有下面几行： toml # 评论系统设置 [params.page.comment] enable = true # Disqus 评论系统设置 [params.page.comment.disqus] enable = true # Disqus 的 shortname shortname = \"kirito-blog\" 这是Disqus的配置，很简单。 博客编写的部分请直接去看hugo的文档 博客有内容后，本地看效果使用下面命令： sh cd site # 本地预览（不会展示gitalk） ../bin/hugo server # 本地预览，但是使用生产环境(会展示gitalk，但不建议) ../bin/hugo server -e production hugo生成静态站点的方式是直接在site目录执行： sh ../bin/hugo 完成后将生成public文件夹，注意不要提交到仓库中。 下面把生成的静态站点，提交到gh-page仓库，就能展示博客了，当然也可以使用其他静态托管服务。 ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:4:1","series":null,"tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/#骨架"},{"categories":["default"],"content":" 配置CI部署回到仓库根目录，创建Action文件： sh mkdir -p .github/workflows touch .github/workflows/main.yml CI配置参考文档 我的CI配置中需要说明的几行： yml - name: init blog run: | git submodule init git submodule update sh script/get-hugo.sh cd site ../bin/hugo # 部署blog - name: deploy blog env: GITHUB_REPO: github.com/zshorz/zshorz.github.io run: | cd site/public git init \u0026\u0026 git add . git config user.name \"xxxx\" git config user.email \"xxxx@mail.com\" git commit -m \"GitHub Actions Auto Builder at $(date +'%Y-%m-%d %H:%M:%S')\" git push --force --quiet \"https://${{ secrets.ACCESS_TOKEN }}@$GITHUB_REPO\" master:master 还记得在仓库中配置了secret环境变量，而在CI中访问那些环境变量的方法就是${{secrets.NAME}} CI的脚本有两部分，首先初始化blog，然后将生成的静态网站，部署到xxx.github.io 我把脚本抽出来单独注释（注意这是在CI的docker自动执行的，不是本地环境） 第一部分 bash # 初始化submodule，拉取LoveIt主题 git submodule init git submodule update # 执行脚本安装hugo环境 sh script/get-hugo.sh cd site # 生成站点，输出到public目录 ../bin/hugo 第二部分 bash # 进入生成的静态站点目录 cd site/public # 初始化为git仓库 git init \u0026\u0026 git add . git config user.name \"xxxx\" git config user.email \"xxxx@qq.com\" # 本地提交 git commit -m \"GitHub Actions Auto Builder at $(date +'%Y-%m-%d %H:%M:%S')\" # 强制推送到远端仓库 git push --force --quiet \"https://${{ secrets.ACCESS_TOKEN }}@$GITHUB_REPO\" master:master 到此CI就配置好了。 ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:4:2","series":null,"tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/#配置ci部署"},{"categories":["default"],"content":" push仓库直接将你的仓库push到远端，会自动触发CI，你可以在这里查看执行情况 待CI执行成功后，打开在浏览器中输入xxx.github.io查看博客站点，就是你现在看到的样子了。 ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:4:3","series":null,"tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/#push仓库"},{"categories":["default"],"content":" 可选项目","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:5:0","series":null,"tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/#可选项目"},{"categories":["default"],"content":" 配置域名比如域名是kirito41dd.cn，你想当你访问www.kirito41dd.cn的时候，就是你的博客站点。 添加文件site/static/CNAME，在里面写上www.kirito41dd.cn，push让CI再次构建 然后打开你的域名控制台，为www.kirito41dd.cn添加一个CNAME记录，记录值为xxx.github.io 稍后浏览器输入域名网址，你就又看到这个页面了 ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:5:1","series":null,"tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/#配置域名"},{"categories":["default"],"content":" CDN加速我用的阿里云的cdn，不知道为啥还没收我钱( ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:5:2","series":null,"tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/#cdn加速"},{"categories":["default"],"content":" 最后git push 享受下 CI 部署的丝滑( ","date":"2020-11-01","objectID":"/blog-with-gitpage-and-ci/:6:0","series":null,"tags":["blog","github page","CI","hugo"],"title":"使用github page和CI(github action)创建博客","uri":"/blog-with-gitpage-and-ci/#最后"},{"categories":null,"content":" 开个博客记录下自己的东西，随便写写 都是网络垃圾，舍不得扔，留个纪念 kirito，原名xxx，xx xx 人 现在是全职rust开发工程师 ","date":"2020-11-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于","uri":"/about/#"},{"categories":null,"content":" kirito 时光似海 雨临Lewis的博客 不想当写手的码农不是好咸鱼_(xз」∠)_ Sanzo Mug-9 Stay Hungry, Stay Foolish 糖菓·部落 𝕹𝖊𝖛𝖊𝖗 𝖉𝖗𝖔𝖜𝖓 𝖙𝖍𝖊 𝖋𝖑𝖆𝖒𝖊 𝖔𝖋 𝖍𝖔𝖕𝖊 交换友链🉑️评论如下信息 toml name=\"kirito\" url=\"https://www.kirito.info\" logo=\"https://gravatar.com/userimage/233561364/5e4a3c3ac6c7c5342d9a6ff360895297.png?size=512\" word=\"时光似海\" ","date":"2020-11-01","objectID":"/friends/:0:0","series":null,"tags":null,"title":"友链墙","uri":"/friends/#"},{"categories":["algorithm"],"content":" cpp #include \u003ciostream\u003e #include \u003cstdio.h\u003e #include \u003calgorithm\u003e #include \u003cfloat.h\u003e #include \u003cmath.h\u003e #include \u003cstring.h\u003e #define EPS FLT_EPSILON #define ios_no_sync do{ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}while(0) //#define DEBUG #ifdef DEBUG #define DBG(x) do{cout \u003c\u003c__FUNCTION__\u003c\u003c \":\" \u003c\u003c __LINE__ \u003c\u003c \": \" \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c (x) \u003c\u003c endl;}while(0) #else #define DBG(x) do{}while(0) #endif #define mset(a,b) memset(a,b,sizeof(a)) using namespace std; typedef long long ll; typedef long double ld; template\u003ctypename T\u003e T GCD(T a, T b) { return b==0?a:GCD(b,a%b); } const int INF = 0x3f3f3f3f; const double PI=acos(-1.0); int main() { ios_no_sync; DBG(INF); cout \u003c\u003c \"ac\" \u003c\u003c endl; return 0; } ","date":"2020-08-17","objectID":"/template/:0:0","series":null,"tags":[],"title":"板子","uri":"/template/#"},{"categories":["compiler"],"content":" 代码生成(Code Generation)的任务中端和后端： 最简单的结构： 简单的结构在早期非常流行，现代编译器很少用，而是分成多个阶段向目标代码靠近。 代码生成的任务： 负责把源程序翻译成“目标机器”上的代码 目标机器可以是真是物理机 可以实虚拟机，jvm… 两个重要的子任务 给源程序的数据分配计算资源 数据 全局变量、局部变量、动态分配 还要考虑变量放在内存还是寄存器之类的问题 计算机资源 寄存器、数据区、代码区、栈区、堆区 给源程序的代码选择指令 源程序的代码 表达式运算、语句、函数等 机器指令 算数运算、比较、跳转、函数调用返回 需要熟悉指令集体系结构(ISA) 下面研究两种不同的ISA上的代码生成技术 栈计算机Stack 寄存器计算机Reg ","date":"2020-06-14","objectID":"/compiler5-code-generation/:1:0","series":null,"tags":["compiler"],"title":"Compiler5_代码生成","uri":"/compiler5-code-generation/#代码生成code-generation的任务"},{"categories":["compiler"],"content":" 栈式计算机 效率低，基本已经退出历史舞台，现在没有物理机用这个结构 栈式计算机生成代码是最容易的 仍然有许多栈式虚拟机 Pascal P code java virtual machine (JVM) Postscript … 一个简单的栈式计算机： 指令集： $$ s\\to\\ push\\ NUM\\\\ |\\ load\\ x\\\\ |\\ store\\ x\\\\ |\\ add\\\\ |\\ sub\\\\ |\\ times\\\\ |\\ div $$ text push NUM 压入立即数 stack[++top]=NUM; load x 从内存读入到栈顶 stack[++top]=x; store x 弹出栈顶变量，并赋值给内存 x=stack[top--]; add + temp=stack[top-1]+stack[top]; top-=2; push temp; sub - times * div / 变量内存分配的伪指令(只支持整形) .int x 为变量x分配内存单元 示例 int x; int y; int z; x = 10; y = 5; z = x + y; y = z * x; 指令 .int x .int y .int z push 10 store x push 5 store y push x push y add store z load z load x times store y ","date":"2020-06-14","objectID":"/compiler5-code-generation/:2:0","series":null,"tags":["compiler"],"title":"Compiler5_代码生成","uri":"/compiler5-code-generation/#栈式计算机"},{"categories":["compiler"],"content":" 递归下降代码生成算法从c–到stack 会发现这是对抽象语法树的后序遍历，和语义分析差不多，所以很多编译器把语义分析和代码生成（或中间代码生成）和二为一 不变式：表达式的值总在栈顶 text Gen_E(E e) switch (e) calse n: emit(\"push n\"); break; calse id: emit(\"load id\"); break; case true: emit(\"push 1\"); break; case false: emit(\"push 0\"); break; case e1+e2: Gen_E (e1); Gen_E (e2); emit(\"add\"); break case ...: ... // ... 不变式：执行后，栈的规模不变 text Gen_S(S s) switch (s) case id=e: Gen_E(e); emit(\"store id\"); break; case printi(e): Gen_E(e); emit(\"printi\"); break; case printb(e): Gen_(e); emit(\"printb\"); break; 不变式：只生产.int类型 text Gen_T(T t) switch (t) case int: emit(\".int\"); break; case bool: emit(\".int\"); break; Gen_D (T id; D) Gen_T(T); emit(\"id\"); Gen_D(D); Gen_P(D S) Gen_D(D); Gen_S(S); ","date":"2020-06-14","objectID":"/compiler5-code-generation/:2:1","series":null,"tags":["compiler"],"title":"Compiler5_代码生成","uri":"/compiler5-code-generation/#递归下降代码生成算法"},{"categories":["compiler"],"content":" 寄存器计算机 寄存器计算机是目前最流行的机器体系结构之一 效率很高 机器体系结构很工整 机器基于寄存器架构 典型的有16、32或更多寄存器，所有操作都在寄存器中进行 访存都通过 load/store 进行，内存不能直接运算 text movn n, r 把n放入寄存器r mov r1, r2 把r1赋值r2 load [x], r 把内存的值读入寄存器r store r, [x] 把r的值存入内存 add r1, r2, r3 r3=r1+r2 sub r1, r2, r3 times r1, r2, r3 dive r1, r2, r3 为变量分配寄存器的伪指令 .int x 因为假设有无限多个寄存器(真实机器不可能) 因此每个声明变量和临时变量都会占用一个（虚拟）寄存器 把虚拟寄存器分配到物理寄存器的过程称为寄存器分配 ","date":"2020-06-14","objectID":"/compiler5-code-generation/:3:0","series":null,"tags":["compiler"],"title":"Compiler5_代码生成","uri":"/compiler5-code-generation/#寄存器计算机"},{"categories":["compiler"],"content":" 递归下降代码生成算法 略 ","date":"2020-06-14","objectID":"/compiler5-code-generation/:3:1","series":null,"tags":["compiler"],"title":"Compiler5_代码生成","uri":"/compiler5-code-generation/#递归下降代码生成算法-1"},{"categories":["compiler"],"content":" 中间代码(Intermediate Code Generation)的地位和作用中间代码/中间表示: 树和有向无环图（DAG） 高层表示，适用于程序源代码。抽象语法树就是个树 三地址码（3-address code） 低层表示，靠近目标机器 控制流图（CFG） 更精细的三地址码，程序的图状表示 适合做程序分析、程序优化等 静态单赋值形式（SSA） 更精细的控制流图 同时编码控制流信息和数据流信息 gcc4.0之后用了这个 连续传递风格（CPS） 更一般的SSA SSA一般是函数内，CPS可以表示跨函数或跨模块 … 等等 为什么要划分成这么多中间表示？ 编译器工程上的考虑 阶段划分：把整个编译过程划分成不同的阶段 任务分解 代码工程：代码更容易实现、维护、演进 程序分析和代码优化的需要 许多优化在特定的中间表示上才可以或才容易进行 更通用 ","date":"2020-06-14","objectID":"/compiler5-code-generation/:4:0","series":null,"tags":["compiler"],"title":"Compiler5_代码生成","uri":"/compiler5-code-generation/#中间代码intermediate-code-generation的地位和作用"},{"categories":["compiler"],"content":" 三地址码 三地址码基本思想 给每个中间变量和计算结果命名 没有复合表达式 只有最基本的控制流 没有各种控制结构 只有goto, call等 所以三地址码可以看成是抽象的指令集 通用的RISC 示例 text a = 3 + 4 * 5; if(x \u003c y) z = 6; else z = 7; /*****************************/ x_1 = 4; x_2 = 5; x_3 = x_1 * x_2; x_4 = 3; x_5 = x_4 + x_3; a = x_5; Cjmp (x\u003cy, L_1, L_2); L_1: z = 6; jmp L_3; L_2: z = 7; jmp L_3; L_3: ... 一个简单的三地址码定义 ","date":"2020-06-14","objectID":"/compiler5-code-generation/:5:0","series":null,"tags":["compiler"],"title":"Compiler5_代码生成","uri":"/compiler5-code-generation/#三地址码"},{"categories":["compiler"],"content":" 控制流图好处： 控制流分析 典型问题，”程序中是否存在循环？“ 数据流分析 “某个变量的值可能是什么” 基本块：是语句的一个序列，从第一条执行到最后一条 不能从中间进入 不能从中间退出 即跳转指令只能出现在最后 控制流图：有向图$G=(V,E)$ 节点：基本块 边：基本块之间的跳转关系 如何生成控制流图： 直接从抽象语法树生成 如果高层语言的控制流结构比较工整的话，比较容易 先生成三地址码，然后继续生成控制流图 像包含goto语句的语言，更合适 更通用，阶段划分 控制流图应用之一：死基本块删除 ","date":"2020-06-14","objectID":"/compiler5-code-generation/:6:0","series":null,"tags":["compiler"],"title":"Compiler5_代码生成","uri":"/compiler5-code-generation/#控制流图"},{"categories":["compiler"],"content":" 数据流分析优化的一般模式： 两种具体的数据流分析： 到达定义分析 活性分析 ","date":"2020-06-14","objectID":"/compiler5-code-generation/:7:0","series":null,"tags":["compiler"],"title":"Compiler5_代码生成","uri":"/compiler5-code-generation/#数据流分析"},{"categories":["compiler"],"content":" 语义分析(Semantic Analysis)的任务编译器前端： 语义分析的任务就是输出图中的中间表示。早期编译器语义分析往往直接生成目标代码，现代编译器需要对代码做优化或其他分析，所以生成中间表示（中间代码）。 语义分析也称为类型检查(Type Checking)、上下文相关分析 负责检查程序（抽象语法树）的上下文相关的属性，这是具体语言相关的，如： 变量在使用前先进行声明 每个表达式都有合适的类型 函数调用和函数的定义一致 … c void f(int *p) { x += 4; // ? p(123); // ? \"hello\" + \"world\"; // ? } int main() { f() + 5; // ? break; // ? return; // ? } 上面的C程序，对语法分析器来说是合法的，但是它明显有许多错误，找出这些错误是语义分析的任务。 程序的语义： 传统上，大部分程序设计语言的语义都采用自然语言来表达程序语言的语义 编译器的实现者必须对语言中的语义规定有全面的理解 ","date":"2020-06-13","objectID":"/compiler4-semantic-analysis/:1:0","series":null,"tags":["compiler"],"title":"Compiler4_语义分析or类型检查","uri":"/compiler4-semantic-analysis/#语义分析semantic-analysis的任务"},{"categories":["compiler"],"content":" 语义规则及实现","date":"2020-06-13","objectID":"/compiler4-semantic-analysis/:2:0","series":null,"tags":["compiler"],"title":"Compiler4_语义分析or类型检查","uri":"/compiler4-semantic-analysis/#语义规则及实现"},{"categories":["compiler"],"content":" 类型检查定义一个c–语言： $$ E\\to n\\\\ \\ |\\ true\\\\ \\ |\\ false\\\\ \\ |\\ E+E\\\\ \\ |\\ E\\ \\\u0026\\\u0026\\ E $$ c // 类型合法的程序： 3+4 false \u0026\u0026 true // 类型不合法的程序 3 + true true + false // 注意在文法上,他们都是合法的 // 语义分析的任务是，对于一个给定的表达式e而言，写一个函数 type check(e); // 返回表达式e的类型，不合法则报错 ","date":"2020-06-13","objectID":"/compiler4-semantic-analysis/:2:1","series":null,"tags":["compiler"],"title":"Compiler4_语义分析or类型检查","uri":"/compiler4-semantic-analysis/#类型检查"},{"categories":["compiler"],"content":" 变量声明的处理扩充语言，必须有声明和表达式。 $$ P\\to D\\ E\\\\ \\ \\\\ D\\to T\\ id;\\ D\\ |\\ \\varepsilon\\\\ \\ \\\\ T\\to int\\\\ \\ |\\ bool\\\\ \\ \\\\ E\\to n\\\\ \\ |\\ true\\\\ \\ |\\ false\\\\ \\ |\\ E+E\\\\ \\ |\\ E\\ \\\u0026\\\u0026\\ E $$ c // 合法 int x; x+4 // 不合法 bool y; false \u0026\u0026 y // 不合法 x + 3 // 不合法 int x; x + false 检查算法： table是符号表 ","date":"2020-06-13","objectID":"/compiler4-semantic-analysis/:2:2","series":null,"tags":["compiler"],"title":"Compiler4_语义分析or类型检查","uri":"/compiler4-semantic-analysis/#变量声明的处理"},{"categories":["compiler"],"content":" 语句的处理 ","date":"2020-06-13","objectID":"/compiler4-semantic-analysis/:2:3","series":null,"tags":["compiler"],"title":"Compiler4_语义分析or类型检查","uri":"/compiler4-semantic-analysis/#语句的处理"},{"categories":["compiler"],"content":" 符号表 用来存储程序中的变量相关信息 类型 作用域 访问控制信息 必须非常高效，因为程序中变量规模会很大 符号表是典型的字典结构：symbolTable: key -\u003e value 变量/映射 type scope … x INT 0 … y BOOL 1 … 为了高效，可以使用hash表(O(1))，或者红黑树(O(logN)更小) 处理作用域的方法 一张表 进入作用域时，插入元素 离开作用域时，删除元素 采用符号表构成的栈 进入作用域时，插入新的符号表 离开作用域时，删除栈顶符号表 名称空间 每个名字空间用一个表来表示 ","date":"2020-06-13","objectID":"/compiler4-semantic-analysis/:2:4","series":null,"tags":["compiler"],"title":"Compiler4_语义分析or类型检查","uri":"/compiler4-semantic-analysis/#符号表"},{"categories":["compiler"],"content":" 其他问题 类型相容性 错误诊断 代码翻译 现代编译器的语义分析模块，除了做语义分析外，还要负责生成中间代码或目标代码 因此语义分析模块往往是编译器中最庞大复杂的模块 ","date":"2020-06-13","objectID":"/compiler4-semantic-analysis/:3:0","series":null,"tags":["compiler"],"title":"Compiler4_语义分析or类型检查","uri":"/compiler4-semantic-analysis/#其他问题"},{"categories":["compiler"],"content":" 语法制导翻译(Syntax Directed Translation)的任务解析输入的字符串时，在特定位置执行指定的动作。 基本思想 ","date":"2020-06-13","objectID":"/compiler3-syntax-directed-translation-and-ast/:1:0","series":null,"tags":["compiler"],"title":"Compiler3_语法制导翻译\u0026AST","uri":"/compiler3-syntax-directed-translation-and-ast/#语法制导翻译syntax-directed-translation的任务"},{"categories":["compiler"],"content":" 抽象语法树","date":"2020-06-13","objectID":"/compiler3-syntax-directed-translation-and-ast/:2:0","series":null,"tags":["compiler"],"title":"Compiler3_语法制导翻译\u0026AST","uri":"/compiler3-syntax-directed-translation-and-ast/#抽象语法树"},{"categories":["compiler"],"content":" 分析树与抽象语法树 分析树： 编码了句子的推导过程 但是包含很多不必要的信息，节点占用存储空间 需要知道那些信息是重要的 对于表达式而言，只需要知道运算符和运算数 优先级，结合性等已经在语法分析部分处理掉了 对于语句，函数等其他构造而言也一样 比如，编译器不关心赋值符号是=还是:= 具体语法和抽象语法： 具体语法是语法分析器使用的语法 必须适合于语法分析，如各种分隔符，消除左递归，提取公因子等 抽象语法是用来表达语法结构的内部表示 现代编译器一般采用抽象语法作为前端（词法/语法分析器）和后端（代码生成）的接口 早期的编译器有的不采用抽象语法树数据结构 直接在语法制导翻译中生成代码 现代编译器一般都采用抽象语法树作为语法分析器的输出 更好的系统的支持 简化编译器的设计 ","date":"2020-06-13","objectID":"/compiler3-syntax-directed-translation-and-ast/:2:1","series":null,"tags":["compiler"],"title":"Compiler3_语法制导翻译\u0026AST","uri":"/compiler3-syntax-directed-translation-and-ast/#分析树与抽象语法树"},{"categories":["compiler"],"content":" 抽象语法树的自动生成 在语法动作中，加入生成语法树的代码片段 片段一般是语法树的构造函数 在产生式规约的时候，会自底向上构造整棵数 从叶子到根 抽象语法树是编译器前端和后端的接口 程序一旦被转换成抽象语法树，则源代码即被丢弃 后续阶段只处理抽象语法树 所以抽象语法树必须编码足够多的源代码信息 例如，语法结构所在位置（文件、行号、列号等） ps：我觉得自动生成方面LL比LR好，自顶向下更符合人类认知，代表生成器：antlr ","date":"2020-06-13","objectID":"/compiler3-syntax-directed-translation-and-ast/:2:2","series":null,"tags":["compiler"],"title":"Compiler3_语法制导翻译\u0026AST","uri":"/compiler3-syntax-directed-translation-and-ast/#抽象语法树的自动生成"},{"categories":["default"],"content":"简单记录下自己的2020春招 2021届双非网络工程，拿过几个水奖，成绩中上。目前拿到了字节跳动的实习offer，其余的进度都很悲观。写这些之前都处于极度自闭状态，好在字节跳动已经尘埃落定，重新拾起精神。 因为只有字节跳动走完了所有流程，所以就主要记录下字节跳动的面试经历。由于没有考研打算，很早就用学长的内推码投了暑期实习生的一个后端岗位，但简历一直是评估中，后来学长说让我试试投其他岗位，又投了一个后端开发。在简历评估中的这段时间，我除了字节和阿里以外没有投其他简历，投这俩是因为有学长内推。我是没想到简历评估了两个月。。。感觉实在不行了，开始海投，这时候已经4月下旬了。。。 ","date":"2020-05-30","objectID":"/2020-spring-recruits/:0:0","series":null,"tags":[],"title":"2020春招记录","uri":"/2020-spring-recruits/#"},{"categories":["default"],"content":" 字节字节跳动的面试体验还是不错的： 4.23日 一面·技术面·1小时 问了问简历里写的项目相关 网络相关，tcp，udp, tcp拥塞控制 对http的了解，还问了http头里面的字段，cookie和session区别什么的 进程间通讯 死锁 最长连续子序列，最长子序列(代码题 普通的dp 当时没说清是否连续，俩都写了，就改改转移方程就行了) 链表找环(代码题 要求空间复杂度为1，就是不让记录访问过的状态，当时不知道咋写，后来问同学，双指针) 二叉查找树(平衡树，红黑树，我忘记是不是在这里问的了，记不清了) 聊天 可以问面试官一个问题（我问了下一面面啥，白问） 4.23日 二面·技术面·1小时 问简历项目 问我以后的职业规划，问我为啥不考研(本来就没有计划考研，又因为保研没我啥事，除非天上掉下来个研究生，我考虑考虑 雾) 大数加法(代码题 还是挺简单的) 问我下楼梯问题(题还没描述完我就知道是递推了，当时我们acm学长宣讲例题就是这种。。。我反手给面试官推荐了这种Fibonacci类的递推怎么用矩阵快速幂来恶心别人，哈哈，聊的挺high，也没让我再写代码了) 计算机，网络相关题，记不清了，这场聊的比较轻松，没记住（后来我ld说这场她旁听了） linux命令问了几个，inode，硬链软链什么的 非对称加密的了解，https、ssl握手机制(网络安全课上刚学完这部分，甚至我们反转课堂我就负责的rsa这部分，反手一个超级加倍，哈哈，欧拉定理，永远滴神) 让我聊聊比赛场景(引起了我对我们三人赛场上被中学生虐飞的悲惨回忆) 说支持云入职(我说后面没有了？他说有。。。让我白高兴) 可以问面试官一个问题（我又问了下一面面啥，白问） 4.28日 三面·技术交叉面·1小时 基础题忘记了（当时面完让我等通知，我以为凉了，也没心情记） 求二叉树深度(代码题，直接dfs找最深没再问了) 打印集合子集(代码题，回溯遍历) 排序算法了解啥(说了常用排序算法，问我快速排序时间复杂度，最坏情况呢？大概知道要问啥，说了随机选取哨兵，避开恶意数据) malloc的一些问题，他写代码我来看 malloc free new delete 区别 什么是内存泄漏，如何防止(举了几个例子，还回答了share_ptr 又问会有什么问题？ 循环引用 weak_ptr配合 ) 可以问面试官一个问题（问了点工作细节相关） 4.28日 四面·技术面·1小时 用c写个字符串拼接(三面完让我等通知以为凉了，面完一会四面面试官就给我打电话问我人去哪了，来房间面试) 设计一个多线程下的异步日志打印 linux c内存空间布局 linux线程从创建到运行，进程，线程，协程区别（协程看过腾讯的libco，还特意扯了点它是如何汇编切换上下文，以及hook系统调用的） 问项目细节(中途延申，聊了聊比特币，linux2.6新加入的timerfd、eventfd、signalfd如何如何方便，socks5握手协议) 聊天，也是技术相关，没记住 时间忘了 hr面 给我介绍部门相关 闲聊，学校，经历，为什么选这个专业 acm收获 缺点 优点 入职时间 一面二面是连着面，三面四面也是连着面，期间一面完等二面面试官的时候，接到了阿里的面试电话，说在面试推到隔天了。 四面结束我ld就微信联系我了，聊了聊，五一假期放假，等的可煎熬，假期结束就收到实习offer了。 字节说完了，说说自闭的 ","date":"2020-05-30","objectID":"/2020-spring-recruits/:1:0","series":null,"tags":[],"title":"2020春招记录","uri":"/2020-spring-recruits/#字节"},{"categories":["default"],"content":" 其他 阿里电话面试挂了，基础题都答上来了，从比特币聊到分布式一致性，只知道比特币是工作量证明和hash，其他方面不了解。还问了我为啥简历偏c++却投了java岗，数据库隔离级别，当时对脏读幻读什么的有概念，但是问我怎么实现的，这里没准备，答不上来(问问b树啥的不就行了吗，没想到还会有这个，后来问同学说好多面经有，后悔没多看看)，一通电话给人整自闭了。 腾讯投了，也笔试了，后续没动静 百度投了，没动静 网易雷火，笔试了，没动静 EA,笔试了，没动静，后来给我打电话了，但是我已经接了字节的offer了，面试就拒了 美团，通知笔试 西山居，笔试了，没动静 途游，笔试了，没动静 快手京东，投了，没动静 可能都太晚了，极度自闭。。。 5.29日 奇虎360 一面·技术面·1小时 c/c++区别，类，多态，继承，重载，重写，隐藏，const，mutable 重要成员函数（构造，拷贝，移动，析构） c++11新特性，lambda（如何实现)，auto，右值，move，forward tcp握手，挥手(详细状态，如timewait），拥塞控制 osi七层协议，ip,icmp等，掩码与子网划分 进程状态，进程间通信，线程，协程，进程间通讯，各种锁（把APUE里的都答上） 字节序，IO多路复用，网络API（问linux的c函数，就是看有没有用过） shared_prt如何实现 acm比赛回忆（感觉就是凑时长） 聊很开心，真就互相练手呗 ","date":"2020-05-30","objectID":"/2020-spring-recruits/:2:0","series":null,"tags":[],"title":"2020春招记录","uri":"/2020-spring-recruits/#其他"},{"categories":["program"],"content":" 1 安装 bash $ go get github.com/gin-gonic/gin 使用http.StatusOK之类的常量，要引入net/http包 ","date":"2020-05-29","objectID":"/gin/:1:0","series":null,"tags":["gin","go"],"title":"gin框架分析","uri":"/gin/#1-安装"},{"categories":["program"],"content":" 2 使用官方文档：https://gin-gonic.com/zh-cn/docs 官方例子：https://github.com/gin-gonic/examples ","date":"2020-05-29","objectID":"/gin/:2:0","series":null,"tags":["gin","go"],"title":"gin框架分析","uri":"/gin/#2-使用"},{"categories":["program"],"content":" 3 框架分析 go r := gin.New() ","date":"2020-05-29","objectID":"/gin/:3:0","series":null,"tags":["gin","go"],"title":"gin框架分析","uri":"/gin/#3-框架分析"},{"categories":["program"],"content":" 3.1 从r.Run()出发gin.Engine 就是整个框架的类： go r.Run(\":8080\") func (engine *Engine) Run(addr ...string) (err error) { // 参数是监听地址 defer func() { debugPrintError(err) }() address := resolveAddress(addr) debugPrint(\"Listening and serving HTTP on %s\\n\", address) err = http.ListenAndServe(address, engine) // 重点在这里 return } gin.Engine实现了net/http包的接口 go type Handler interface { ServeHTTP(ResponseWriter, *Request) } 跳转到gin.Engine.ServeHTTP函数： go func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) // 这个函数里实现了对具体请求的处理 engine.pool.Put(c) } gin.Context也是框架里一个重要的数据结构。 继续往里跳： go func (engine *Engine) handleHTTPRequest(c *Context) { // ... // Find root of the tree for the given HTTP method t := engine.trees for i, tl := 0, len(t); i \u003c tl; i++ { if t[i].method != httpMethod { continue } root := t[i].root // Find route in tree // getValue 返回给定路径上注册的handle 路由匹配算法在这个函数实现 value := root.getValue(rPath, c.Params, unescape) if value.handlers != nil { c.handlers = value.handlers c.Params = value.params c.fullPath = value.fullPath c.Next() // 注意这个函数一般只在中间件中调用，依次调用注册的函数 c.writermem.WriteHeaderNow() return } // 没匹配到路由的处理 ... // ... } root的类型是gin.node，跳到node.getValue方法： go func (n *node) getValue(path string, po Params, unescape bool) (value nodeValue){ //.. 这个函数通过path匹配路由，把路由上注册的方法通过 nodeValue 结构体返回 } 从这个方法返回到handleHTTPRequest后，把nodeValue的值给Context，然后调用Context.Next()执行用户注册的函数 ","date":"2020-05-29","objectID":"/gin/:3:1","series":null,"tags":["gin","go"],"title":"gin框架分析","uri":"/gin/#31-从rrun出发"},{"categories":["program"],"content":" 3.2 从r.GET()出发 go r.GET(\"/ping\", func(c *gin.Context) { c.String(http.StatusOK, \"pong\") }) func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes { return group.handle(http.MethodGet, relativePath, handlers) } 由此可见，gin.Engine继承了gin.RouterGroup go type RouterGroup struct { Handlers HandlersChain basePath string engine *Engine root bool } 而gin.RouterGroup又实现了IRouter接口，进而实现IRoutes接口： go type IRouter interface { IRoutes Group(string, ...HandlerFunc) *RouterGroup } type IRoutes interface { Use(...HandlerFunc) IRoutes Handle(string, string, ...HandlerFunc) IRoutes Any(string, ...HandlerFunc) IRoutes GET(string, ...HandlerFunc) IRoutes POST(string, ...HandlerFunc) IRoutes DELETE(string, ...HandlerFunc) IRoutes PATCH(string, ...HandlerFunc) IRoutes PUT(string, ...HandlerFunc) IRoutes OPTIONS(string, ...HandlerFunc) IRoutes HEAD(string, ...HandlerFunc) IRoutes StaticFile(string, string) IRoutes Static(string, string) IRoutes StaticFS(string, http.FileSystem) IRoutes } 继续看GET()做了什么，跳进去： go // 把handler注册到给定方法和路径的路由上 func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes { absolutePath := group.calculateAbsolutePath(relativePath) handlers = group.combineHandlers(handlers) group.engine.addRoute(httpMethod, absolutePath, handlers) // 重点 return group.returnObj() } 继续跳： go // 放到路由树上 func (engine *Engine) addRoute(method, path string, handlers HandlersChain) { // ... debugPrintRoute(method, path, handlers) root := engine.trees.get(method) if root == nil { root = new(node) root.fullPath = \"/\" engine.trees = append(engine.trees, methodTree{method: method, root: root}) } root.addRoute(path, handlers) } 至此成功注册了一个GET方法下的路由 ","date":"2020-05-29","objectID":"/gin/:3:2","series":null,"tags":["gin","go"],"title":"gin框架分析","uri":"/gin/#32-从rget出发"},{"categories":["program"],"content":" 3.3 从r.Group r.Use出发 go newGroup := r.Group(\"/\") func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup { return \u0026RouterGroup{ Handlers: group.combineHandlers(handlers), // 中间件 basePath: group.calculateAbsolutePath(relativePath), engine: group.engine, } } 很简单，就是创建了一个RouterGroup对象返回 再来看r.Use go r.Use(gin.Logger()) func (engine *Engine) Use(middleware ...HandlerFunc) IRoutes { engine.RouterGroup.Use(middleware...) // 中间件是被注册到 RouterGroup 对象上的 engine.rebuild404Handlers() engine.rebuild405Handlers() return engine } 继续跳： go func (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes { group.Handlers = append(group.Handlers, middleware...) return group.returnObj() } 由此可见，RouterGroup.Handlers 保存的就是中间件的handle 注册一个中间件非常简单，下面会说当请求来到时，中间件如何与用户注册的handle一起被执行 ","date":"2020-05-29","objectID":"/gin/:3:3","series":null,"tags":["gin","go"],"title":"gin框架分析","uri":"/gin/#33-从rgroup-ruse出发"},{"categories":["program"],"content":" 3.4 请求过程中间件和用户注册的路由handle是如何被执行的？ 现有RouterGroup，再有注册中间件，然后才有用户注册路由，前两个上面说了，代码很简单 所以还是从r.GET()出发，再看一遍 go r.GET(\"/ping\", func(c *gin.Context) { c.String(http.StatusOK, \"pong\") }) func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes { return group.handle(http.MethodGet, relativePath, handlers) } func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes { absolutePath := group.calculateAbsolutePath(relativePath) handlers = group.combineHandlers(handlers) // 重点 group.engine.addRoute(httpMethod, absolutePath, handlers) // 添加路由 return group.returnObj() } 一路跳到RouterGroup.handle 里的group.combineHandlers(handlers) go // 这个函数把用户注册的handle和中间件的handle组合起来并返回 func (group *RouterGroup) combineHandlers(handlers HandlersChain) HandlersChain { finalSize := len(group.Handlers) + len(handlers) if finalSize \u003e= int(abortIndex) { panic(\"too many handlers\") } mergedHandlers := make(HandlersChain, finalSize) copy(mergedHandlers, group.Handlers) copy(mergedHandlers[len(group.Handlers):], handlers) return mergedHandlers } 到这里就很明确了，中间件的handle和用户注册的handle被一起放进了路由树里，中间件在前，用户注册在后 然后再从r.Run来看： go func (engine *Engine) Run(addr ...string) (err error) { // ... err = http.ListenAndServe(address, engine) return } // Engine实现了http.Handler接口，当请求过来时，会调用如下函数 func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) engine.pool.Put(c) } func (engine *Engine) handleHTTPRequest(c *Context) { // ... // Find root of the tree for the given HTTP method t := engine.trees for i, tl := 0, len(t); i \u003c tl; i++ { if t[i].method != httpMethod { continue } root := t[i].root // Find route in tree value := root.getValue(rPath, c.Params, unescape) // 拿到路由上注册的函数 if value.handlers != nil { c.handlers = value.handlers c.Params = value.params c.fullPath = value.fullPath c.Next() // 调用所有 c.writermem.WriteHeaderNow() return } // ... } 中间件的handle和用户注册的handle被一起放进了路由树里，所以获取的时候也是一起被获取的 然后在Context.Next里被按照先后顺序调用 完 ","date":"2020-05-29","objectID":"/gin/:3:4","series":null,"tags":["gin","go"],"title":"gin框架分析","uri":"/gin/#34-请求过程"},{"categories":["compiler"],"content":" 语法分析(Syntax Analysis)的任务分析的任务是确定程序的语法，或称作结构，也正是这个原因，它又被称作语法分析（syntax analysis）。程序设计语言的语法通常是由上下文无关（context-free grammar）的文法规则（grammar rule）给出，其方式同扫描程序识别的由正则表达式提供的记号的词法结构相类似。上下文无关文法的确利用了与正则表达式中极为类似的命名惯例和运算。二者的主要区别在于上下文无关文法的规则是递归的（recursive）。例如一般来说，if 语句的结构应允许其中可嵌套其他的 if 语句，而在正则表达式中却不能这样做。这个区别造成的影响很大。由上下文无关文法识别的结构类比由正则表达式识别的结构类大大增多了。用作识别这些结构的算法也与扫描算法差别很大，这是因为它们必须使用递归调用或显式管理的分析栈。用作表示语言语义结构的数据结构现在也必须是递归的，而不再是线性的（如同用于词法和记号中的一样）了。经常使用的基本结构是一类树，称作分析树（parse tree）或语法树（syntax tree）。 输入记号流，语法规则，输出抽象语法树(分析语法错误也是这部分职责) ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:1:0","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#语法分析syntax-analysis的任务"},{"categories":["compiler"],"content":" 上下文无关文法context-free grammar，描述语法规则的数学工具 上下文无关文法说明程序设计语言的语法结构。除了上下文无关文法涉及到了递归规则之外，这样的说明与使用正则表达式的词法结构的说明十分类似： $$ exp \\to exp\\ op\\ exp |(exp)|number \\\\ op\\to +|-|* $$ 同正则表达式类似，文法规则是定义在一个字母表或符号集之上。在正则表达式中，这些符号通常就是字符，而在文法规则中，符号通常是表示字符串的记号。选择并置操作与正则表达式一样，但是重复操作使用递归表示，而不是像正则那样$a^*$表示。箭头符号“→”来表示名字的定义 4种文法——非限制的、上下文有关的、上下文无关的和正则的，分别被称为0型、 1型、 2型和 3型文法。 上下文无关文法是四元组$G(V_T,V_N,S,P)$： $V_T$：终结符集合 $V_N$：非终结符集合 $S$：开始符号，非终结符中的一个 $P$：产生式集合，产生式形式：$A\\to\\alpha$ ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:2:0","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#上下文无关文法"},{"categories":["compiler"],"content":" 推导 给定文法$G$，从G的开始符号S开始，用产生式的右部替换左侧的非终结符 不断重复，直到不出现非终结符为止 最终的串称为句子 最左推导：每次总是选择最左侧的符号进行替换 最右推导：每次总是选择最右侧的符号进行替换，又称为规范推导 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:2:1","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#推导"},{"categories":["compiler"],"content":" 分析树与抽象语法树推导 为 构造 来自一个初始的非终结符的特定终结符的串 提供了一个办法，但是推导并未唯一地表示出它们所构造的结构。总而言之，对于同一个串可有多个推导。 $$ exp \\to exp\\ op\\ exp |(exp)|number \\\\ op\\to +|-|* $$ 对于上面的文法，我们构造出记号串 $(numver\\ -\\ number)\\ *\\ number$，下面两种推导都可以 $$ exp \\Rightarrow exp\\ op\\ exp\\\\ \\Rightarrow exp\\ op\\ number\\\\ \\Rightarrow exp\\ *\\ number\\\\ \\Rightarrow (exp)\\ *\\ number\\\\ \\Rightarrow (exp\\ op\\ exp)\\ *\\ number\\\\ \\Rightarrow (exp\\ op\\ number)\\ *\\ nummber\\\\ \\Rightarrow (exp\\ -\\ number)\\ *\\ nummber\\\\ \\Rightarrow (number\\ -\\ number)\\ *\\ nummber\\\\ $$ $$ exp \\Rightarrow exp\\ op\\ exp\\\\ \\Rightarrow (exp)\\ op\\ exp\\\\ \\Rightarrow (exp\\ op\\ exp)\\ op\\ exp\\\\ \\Rightarrow (number\\ op\\ exp)\\ op\\ exp\\\\ \\Rightarrow (number\\ -\\ exp)\\ op\\ exp\\\\ \\Rightarrow (number\\ -\\ number)\\ op\\ exp\\\\ \\Rightarrow (number\\ -\\ number)\\ *\\ exp\\\\ \\Rightarrow (number\\ -\\ number)\\ *\\ number\\\\ $$ 二者唯一的差别在于提供的替换顺序，而这其实是一个很表面的差别。为了把它表示得更清楚一些，我们需要表示出终结符串的结构，而这些终结符将推导的主要特征抽取出来，同时却将表面的差别按顺序分解开来。这样的表示法就是树结构，它称作分析树。 一个例子：推导与分析树 抽象语法树： 分析树是表述记号串结构的一种十分有用的表示法。在分析树中，记号表现为分析树的树叶（自左至右），而分析树的内部节点则表示推导的各个步骤（按某种顺序）。但是，分析树却包括了比纯粹为编译生成可执行代码所需的更多的信息。为了看清这一点，可根据简单的表达式文法，考虑表达式 $3 + 4$ 的分析树： 实际上可将这个树看作：根代表两个孩子 $exp$子树的数值相加。而另一方面，每个子树又代表它的每个 $number$孩子的值。但是还有一个更为简单的方法能表示与这相同的信息，即如树： 例2：$(34-2)*42$ 在这个树中，括号记号实际已消失了，但它仍然准确地表达着从 34中减去3，然后再乘以42的语义内容。 这种树是真正的源代码记号序列的抽象表示。虽然不能从其中重新得到记号序列（不同于分析树），但是它们却包含了转换所需的所有信息，而且比分析树效率更高。这样的树称作抽象语法树（abstract syntax tree）或简称为语法树（syntax tree）。 一般树的含义取决于后序遍历，这会引出二义性文法 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:3:0","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#分析树与抽象语法树"},{"categories":["compiler"],"content":" 二义性文法给定文法 $G$，如果存在句子 $s$，他有两颗不同的分析树，那么称 $G$ 为二义性文法。（因为如果树结构不同，那么后续遍历结果肯定不同，产生歧义） 解决方案：重写，具体问题具体分析，没有统一方法 二义性文法认为是一种语言语法的不完善说明，而且也应避免它。产生根本原因是文法中缺少对文法符号优先级和结合性的规定。 改写二义性闻法得关键步骤 一如一个新的非终结符，增加一个子结构，并提高一级优先级 递归非终结符在终结符左边，使该终结符具有左结合性，反之是右结合 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:4:0","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#二义性文法"},{"categories":["compiler"],"content":" 自顶向下的分析语法分析：给定文法$G$和句子$s$，回答$s$能否从$G$推导出来？（也就是输入是否合法） 基本算法思想：从$G$的开始符号出发，随意推导出某个句子$t$，比较$t$和$s$，相等回答yes，否则?(回溯，继续)，其实就等同于在树上做回溯遍历(一般是后序) 因为这是从开始符号出发推导出句子，因此称为自顶向下分析 回溯非常费时，我们需要线性时间的算法 避免回溯 用前看符号避免回溯，选择产生式时候，看一眼输入的串当前该匹配哪个符号，找到准确路线(会有多个路线如何选择的问题) 引出递归下降分析算法和LL(1)分析算法 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:5:0","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#自顶向下的分析"},{"categories":["compiler"],"content":" 递归下降分析算法 也称为预测分析 分析高效(线性时间) 容易实现(方便手工编码) 错误定位和诊断信息准确 被很多编译器采用：GCC4.0，LLVM … 算法基本思想：分治 每个非终结符构造一个分析函数 用前看符号指导产生式规则的选择 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:5:1","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#递归下降分析算法"},{"categories":["compiler"],"content":" LL(1)分析算法分析算法规范后，可以利用算法自动生成语法分析器的代码，比如一些工具： ANTLR LL(1)分析算法： 从 左(L) 向右读入程序，最 左(L) 推导，采用 一个(1) 前看符号(用未读入的符号做辅助) 分析高效(线性时间) 错误定位和诊断信息准确 有很多开源或商业生成工具：ANTLR… 基本思想：表驱动的分析算法 缺点 能分析的文法类型受限 往往需要文法的改写 LL(1)分析的基本方法：LL(1)分析使用显式栈而不是递归调用来完成分析。 如文法：$S\\to(S)S|\\varepsilon$ ，一个匹配成对括号的文法，假设我们的输入串是\"()\" 分析栈 输入 动作 1 $ S ()$ $S\\to(S)S$ 2 $ S ) S ( ()$ 匹配 3 $ S ) S )$ $S\\to\\varepsilon$ 4 $ S ) )$ 匹配 5 $ S $ $S\\to\\varepsilon$ 6 $ $ 接受 分析栈里的$表示栈底部，输入里的$表示串结束 利用文法选择$A→α$将栈顶部的非终结符$A$替换成串$α$。 将栈顶部的记号与下一个输入记号匹配 对于上面的例子： 初始，栈顶为S，输入() 选择用来替换栈顶S的规则是$S\\to(S)S$，所以将串S)S(压入栈,，（注意顺序是反向的，这样出栈顺序是(S)S） 发现栈顶的(和输入串(匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 发现栈顶的)和输入串)匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 栈为空，接受 这个过程与串()最左推导的步骤完全对应： $$ S\\Rightarrow (S)S \\ ,\\ \\ [S\\to(S)S] \\\\ \\Rightarrow ()S\\ , \\ \\ [S\\to\\varepsilon]\\\\ \\Rightarrow ()\\ ,\\ \\ [S\\to\\varepsilon] $$ 如果要在分析进行时构造一个分析树，则可当将每个非终结符或终结符压入到栈中时添加节点来构造动作。 表驱动(分析表)当非终结符A位于分析栈的顶部时，根据当前的输入记号（前看），必须使用刚刚描述过的分析办法做出一个决定：当替换栈中的 A时应为A选择哪一个文法规则，相反地，当记号位于栈顶部时，就无需做出这样的决定。 通过构造一个LL(1)分析表(LL(1) parsing table)就可以表达出可能的选择。 这样的表格基本上是一个由非终结符和终结符索引的二维数组，其中非终结符和终结符包括了要在恰当的分析 步骤（包括代表输入结束的$）中使用的产生式选择。这个表被称为M[N, T]，这里的N是文法的非终结符的集合， T是终结符或记号的集合M可被认为是“运动的”表。 我们假设表 **M[N, T]**在开始时，它的所有项目均为空。任何在构造之后继续为空的项目都代表了在分析中可能发生的潜在错误。根据以下规则在这个表中添加产生式： 如果$A\\to\\alpha$是一个产生式选择,且有推导$\\alpha\\Rightarrow\\ ^*a\\beta$成立，其中$a$是一个记号，则添加到表中 如果$A→α$是一个产生式选择，且有推导$α ⇒ \\ ^*\\varepsilon$ 和 $S \\$ ⇒ \\ ^∗βAaγ $ 成立，其中S是开始符号， $a$是一个记号（或$），则添加到表中 在规则1中，在输入中给出了记号$a$，若$α$可为匹配生成一个$a$，则希望挑选规则$A→α$ 在规则2中，若A派生了空串（通过A→α），且如a 是一个在推导中可合法地出现在A之后的记号，则要挑选$A→α$以使A消失。 很难完成这些要求，需要First和Follow集合 上面例子中的M[N, T]: M[N, T] $($ $)$ $$$ $S$ $S\\to(S)S$ $S\\to \\varepsilon $ $S\\to \\varepsilon $ 定义：如果文法G相关的LL(1)分析表的每个项目中至多只有一个产生式，则该文法就是LL(1)文法 由于上面的定义暗示着利用L L ( 1 )文法表就能构造出一个无二义性的分析，所以 LL (1)文法不能是二义性的。 表驱动LL分析器架构： FIRST集定义：FIRST(N) = 从非终结符N开始推导得出的句子开头的所有可能终结符集合 计算公式，近似如下： 注意只关心开头符号 $$ 对\\ N\\to a \\ ...\\\\ FIRST(N)\\ \\cup=\\{a\\}\\\\ 对\\ N\\to M\\ ...\\\\ FIRST(N)\\ \\cup=FIRST(M) $$ 把FIRST扩展到任意串上： 构造LL(1)分析表：表中的数字是文法规则，当栈顶非终结符为N，下个处理符号是T，使用文法规则num 冲突：LL(1)分析表中每个表项，至多只能有一个产生式，如果出现多个选择，就是冲突 冲突检测,对N的两条产生式规则$N\\to\\beta$和$N\\to\\gamma$，要求$FIRST(\\beta)\\cap FIRST(\\gamma)={}$ 而上图中$FIRST(w)\\cap FIRST(wV)={w}$，所以冲突了，体现在表中，就是有两个选择 FOLLOW集对于如下例子：一般条件下的LL(1)分析表构造 $$ Z\\to d\\ |\\ X\\ Y\\ Z\\\\ Y\\to c\\ |\\ \\varepsilon\\\\ X\\to Y\\ |\\ a $$ $FIRST_(X\\ Y\\ Z)=?$ X由Y开头，但Y又可以是空串，那X也能是空串，又只能去看Y，Y可能是空串，看Z，最终Z取d，所以$FIRST_(X\\ Y\\ Z)=\\{a\\ c\\ d\\}$ 一般情况下需知道某个非终结符是否可以推出空串，NULLABLE集 并且一般需要知道在某个非终结符后面可以跟着什么符号，FOLLOW集 对于Y，当取空串的时候，直接弹出栈，没有串压入(空串)，但还要知道谁能跟在Y后面，不然没法向下走，只有知道谁能跟在后面，才能判断输入是否合法 NULLABLE集合：当非终结符X属于集合NULLABLE，当且仅当： $X\\to\\varepsilon$，可以直接推出空串 $X\\to Y_1,…,Y_n$，Y是n个非终结符，且全都属于NULLABLE集 FIRST集合完整计算公式： FOLLOW集算法： text foreach (非终结符 N) FOLLOW(N) = {} // 初始化为空集 while (第一次循环 或 有集合发生变化) foreach (每个产生式 p) // p的形式就是产生式 N -\u003e B1 ... Bn temp = FOLLOW(N) // 临时集合 foreach (Bn to B1) // 考虑每个符号，逆序处理 if (Bi == a ...) // 如果是个终结符 temp = {a} if (Bi == M ...) // 是个非终结符 FOLLOW(M) += temp if (M 不是 NULLABLE) temp = FIRST(M) else temp += FIRST(M) /* N -\u003e B1 B2 ... Bn temp */ $$ z\\ \\to\\ d\\ |\\ X\\ Y\\ Z\\\\ Y\\ \\to\\ c\\ |\\ \\varepsilon\\\\ X\\ \\to\\ Y\\ |\\ a $$ $NULLABLE={X,Y}$ X Y Z FIRST ${a,c}$ ${c}$ ${a,c,d}$ N-FOLLOW / 循环轮次 0 1 2 Z ${ }$ ${}$ Y ${}$ ${a,c,d}$ X ${}$ ${a,c,d}$ 计算FIRST_S集合： text foreach (考虑每个产生式 p) FIRST_S(p) = {} calculte_FIRST_S (考虑每个产生式 P) // p的形式就是产生式 N -\u003e B1 ... Bn foreach (B1 to Bn) if (Bi == a...) //终结符开头 FIRST_S(p) += {a} return if (Bi == M...) FIRST_S(p) += FIRST(M) if (M 不是 NULLABLE) return; FIRST_S(p) += FOLLOW(N) 数字代表的是对应的产生式 冲突处理: 消除左递归和提取左因子这两个技术无法保证可将一个文法变成 LL(1)文法，然而，在绝大多数情况下，它们都十分有用，并且具有可自动操作其应用程序的优点，因此，假设有一个成功的结果，利用它们就可自动地生成LL(1)分析程序 简单直接左递归： $$ A\\to A\\alpha|\\beta $$ 其中α和β是终结符和非终结符的串，而且 β不以A开头，为了消除左递归，将这个文法规则重写为两个规则：一个是首先生成 β，另一个是生成α的重复，它不用左递归却用右递归： $$ A\\to \\beta A'\\\\A'\\to \\alpha A'|\\varepsilon $$ 普遍直接左递归： $$ A → Aα_1 | Aα_2 | . . . | Aα_n | β_1 | β_2 | . . . | β_m $$ 其解法与简单情况类似，只需将选择相应地扩展: $$ A →β_1 A'| β_2 A'| . . . | β_m A' \\\\ A' →α_1 A' | α_2 A' | . . . | α_n A' |\\varepsilon $$ 提取左因子 当两个或更多文法规则选择共享一个通用前缀串时，需要提取左因子。如: $$ A→αβ | α γ $$ 这个简单情况的解法是将左边","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:5:2","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#ll1分析算法"},{"categories":["compiler"],"content":" LL(1)分析算法分析算法规范后，可以利用算法自动生成语法分析器的代码，比如一些工具： ANTLR LL(1)分析算法： 从 左(L) 向右读入程序，最 左(L) 推导，采用 一个(1) 前看符号(用未读入的符号做辅助) 分析高效(线性时间) 错误定位和诊断信息准确 有很多开源或商业生成工具：ANTLR… 基本思想：表驱动的分析算法 缺点 能分析的文法类型受限 往往需要文法的改写 LL(1)分析的基本方法：LL(1)分析使用显式栈而不是递归调用来完成分析。 如文法：$S\\to(S)S|\\varepsilon$ ，一个匹配成对括号的文法，假设我们的输入串是\"()\" 分析栈 输入 动作 1 $ S ()$ $S\\to(S)S$ 2 $ S ) S ( ()$ 匹配 3 $ S ) S )$ $S\\to\\varepsilon$ 4 $ S ) )$ 匹配 5 $ S $ $S\\to\\varepsilon$ 6 $ $ 接受 分析栈里的$表示栈底部，输入里的$表示串结束 利用文法选择$A→α$将栈顶部的非终结符$A$替换成串$α$。 将栈顶部的记号与下一个输入记号匹配 对于上面的例子： 初始，栈顶为S，输入() 选择用来替换栈顶S的规则是$S\\to(S)S$，所以将串S)S(压入栈,，（注意顺序是反向的，这样出栈顺序是(S)S） 发现栈顶的(和输入串(匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 发现栈顶的)和输入串)匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 栈为空，接受 这个过程与串()最左推导的步骤完全对应： $$ S\\Rightarrow (S)S \\ ,\\ \\ [S\\to(S)S] \\\\ \\Rightarrow ()S\\ , \\ \\ [S\\to\\varepsilon]\\\\ \\Rightarrow ()\\ ,\\ \\ [S\\to\\varepsilon] $$ 如果要在分析进行时构造一个分析树，则可当将每个非终结符或终结符压入到栈中时添加节点来构造动作。 表驱动(分析表)当非终结符A位于分析栈的顶部时，根据当前的输入记号（前看），必须使用刚刚描述过的分析办法做出一个决定：当替换栈中的 A时应为A选择哪一个文法规则，相反地，当记号位于栈顶部时，就无需做出这样的决定。 通过构造一个LL(1)分析表(LL(1) parsing table)就可以表达出可能的选择。 这样的表格基本上是一个由非终结符和终结符索引的二维数组，其中非终结符和终结符包括了要在恰当的分析 步骤（包括代表输入结束的$）中使用的产生式选择。这个表被称为M[N, T]，这里的N是文法的非终结符的集合， T是终结符或记号的集合M可被认为是“运动的”表。 我们假设表 **M[N, T]**在开始时，它的所有项目均为空。任何在构造之后继续为空的项目都代表了在分析中可能发生的潜在错误。根据以下规则在这个表中添加产生式： 如果$A\\to\\alpha$是一个产生式选择,且有推导$\\alpha\\Rightarrow\\ ^*a\\beta$成立，其中$a$是一个记号，则添加到表中 如果$A→α$是一个产生式选择，且有推导$α ⇒ \\ ^*\\varepsilon$ 和 $S \\$ ⇒ \\ ^∗βAaγ $ 成立，其中S是开始符号， $a$是一个记号（或$），则添加到表中 在规则1中，在输入中给出了记号$a$，若$α$可为匹配生成一个$a$，则希望挑选规则$A→α$ 在规则2中，若A派生了空串（通过A→α），且如a 是一个在推导中可合法地出现在A之后的记号，则要挑选$A→α$以使A消失。 很难完成这些要求，需要First和Follow集合 上面例子中的M[N, T]: M[N, T] $($ $)$ $$$ $S$ $S\\to(S)S$ $S\\to \\varepsilon $ $S\\to \\varepsilon $ 定义：如果文法G相关的LL(1)分析表的每个项目中至多只有一个产生式，则该文法就是LL(1)文法 由于上面的定义暗示着利用L L ( 1 )文法表就能构造出一个无二义性的分析，所以 LL (1)文法不能是二义性的。 表驱动LL分析器架构： FIRST集定义：FIRST(N) = 从非终结符N开始推导得出的句子开头的所有可能终结符集合 计算公式，近似如下： 注意只关心开头符号 $$ 对\\ N\\to a \\ ...\\\\ FIRST(N)\\ \\cup=\\{a\\}\\\\ 对\\ N\\to M\\ ...\\\\ FIRST(N)\\ \\cup=FIRST(M) $$ 把FIRST扩展到任意串上： 构造LL(1)分析表：表中的数字是文法规则，当栈顶非终结符为N，下个处理符号是T，使用文法规则num 冲突：LL(1)分析表中每个表项，至多只能有一个产生式，如果出现多个选择，就是冲突 冲突检测,对N的两条产生式规则$N\\to\\beta$和$N\\to\\gamma$，要求$FIRST(\\beta)\\cap FIRST(\\gamma)={}$ 而上图中$FIRST(w)\\cap FIRST(wV)={w}$，所以冲突了，体现在表中，就是有两个选择 FOLLOW集对于如下例子：一般条件下的LL(1)分析表构造 $$ Z\\to d\\ |\\ X\\ Y\\ Z\\\\ Y\\to c\\ |\\ \\varepsilon\\\\ X\\to Y\\ |\\ a $$ $FIRST_(X\\ Y\\ Z)=?$ X由Y开头，但Y又可以是空串，那X也能是空串，又只能去看Y，Y可能是空串，看Z，最终Z取d，所以$FIRST_(X\\ Y\\ Z)=\\{a\\ c\\ d\\}$ 一般情况下需知道某个非终结符是否可以推出空串，NULLABLE集 并且一般需要知道在某个非终结符后面可以跟着什么符号，FOLLOW集 对于Y，当取空串的时候，直接弹出栈，没有串压入(空串)，但还要知道谁能跟在Y后面，不然没法向下走，只有知道谁能跟在后面，才能判断输入是否合法 NULLABLE集合：当非终结符X属于集合NULLABLE，当且仅当： $X\\to\\varepsilon$，可以直接推出空串 $X\\to Y_1,…,Y_n$，Y是n个非终结符，且全都属于NULLABLE集 FIRST集合完整计算公式： FOLLOW集算法： text foreach (非终结符 N) FOLLOW(N) = {} // 初始化为空集 while (第一次循环 或 有集合发生变化) foreach (每个产生式 p) // p的形式就是产生式 N -\u003e B1 ... Bn temp = FOLLOW(N) // 临时集合 foreach (Bn to B1) // 考虑每个符号，逆序处理 if (Bi == a ...) // 如果是个终结符 temp = {a} if (Bi == M ...) // 是个非终结符 FOLLOW(M) += temp if (M 不是 NULLABLE) temp = FIRST(M) else temp += FIRST(M) /* N -\u003e B1 B2 ... Bn temp */ $$ z\\ \\to\\ d\\ |\\ X\\ Y\\ Z\\\\ Y\\ \\to\\ c\\ |\\ \\varepsilon\\\\ X\\ \\to\\ Y\\ |\\ a $$ $NULLABLE={X,Y}$ X Y Z FIRST ${a,c}$ ${c}$ ${a,c,d}$ N-FOLLOW / 循环轮次 0 1 2 Z ${ }$ ${}$ Y ${}$ ${a,c,d}$ X ${}$ ${a,c,d}$ 计算FIRST_S集合： text foreach (考虑每个产生式 p) FIRST_S(p) = {} calculte_FIRST_S (考虑每个产生式 P) // p的形式就是产生式 N -\u003e B1 ... Bn foreach (B1 to Bn) if (Bi == a...) //终结符开头 FIRST_S(p) += {a} return if (Bi == M...) FIRST_S(p) += FIRST(M) if (M 不是 NULLABLE) return; FIRST_S(p) += FOLLOW(N) 数字代表的是对应的产生式 冲突处理: 消除左递归和提取左因子这两个技术无法保证可将一个文法变成 LL(1)文法，然而，在绝大多数情况下，它们都十分有用，并且具有可自动操作其应用程序的优点，因此，假设有一个成功的结果，利用它们就可自动地生成LL(1)分析程序 简单直接左递归： $$ A\\to A\\alpha|\\beta $$ 其中α和β是终结符和非终结符的串，而且 β不以A开头，为了消除左递归，将这个文法规则重写为两个规则：一个是首先生成 β，另一个是生成α的重复，它不用左递归却用右递归： $$ A\\to \\beta A'\\\\A'\\to \\alpha A'|\\varepsilon $$ 普遍直接左递归： $$ A → Aα_1 | Aα_2 | . . . | Aα_n | β_1 | β_2 | . . . | β_m $$ 其解法与简单情况类似，只需将选择相应地扩展: $$ A →β_1 A'| β_2 A'| . . . | β_m A' \\\\ A' →α_1 A' | α_2 A' | . . . | α_n A' |\\varepsilon $$ 提取左因子 当两个或更多文法规则选择共享一个通用前缀串时，需要提取左因子。如: $$ A→αβ | α γ $$ 这个简单情况的解法是将左边","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:5:2","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#ll1分析的基本方法"},{"categories":["compiler"],"content":" LL(1)分析算法分析算法规范后，可以利用算法自动生成语法分析器的代码，比如一些工具： ANTLR LL(1)分析算法： 从 左(L) 向右读入程序，最 左(L) 推导，采用 一个(1) 前看符号(用未读入的符号做辅助) 分析高效(线性时间) 错误定位和诊断信息准确 有很多开源或商业生成工具：ANTLR… 基本思想：表驱动的分析算法 缺点 能分析的文法类型受限 往往需要文法的改写 LL(1)分析的基本方法：LL(1)分析使用显式栈而不是递归调用来完成分析。 如文法：$S\\to(S)S|\\varepsilon$ ，一个匹配成对括号的文法，假设我们的输入串是\"()\" 分析栈 输入 动作 1 $ S ()$ $S\\to(S)S$ 2 $ S ) S ( ()$ 匹配 3 $ S ) S )$ $S\\to\\varepsilon$ 4 $ S ) )$ 匹配 5 $ S $ $S\\to\\varepsilon$ 6 $ $ 接受 分析栈里的$表示栈底部，输入里的$表示串结束 利用文法选择$A→α$将栈顶部的非终结符$A$替换成串$α$。 将栈顶部的记号与下一个输入记号匹配 对于上面的例子： 初始，栈顶为S，输入() 选择用来替换栈顶S的规则是$S\\to(S)S$，所以将串S)S(压入栈,，（注意顺序是反向的，这样出栈顺序是(S)S） 发现栈顶的(和输入串(匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 发现栈顶的)和输入串)匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 栈为空，接受 这个过程与串()最左推导的步骤完全对应： $$ S\\Rightarrow (S)S \\ ,\\ \\ [S\\to(S)S] \\\\ \\Rightarrow ()S\\ , \\ \\ [S\\to\\varepsilon]\\\\ \\Rightarrow ()\\ ,\\ \\ [S\\to\\varepsilon] $$ 如果要在分析进行时构造一个分析树，则可当将每个非终结符或终结符压入到栈中时添加节点来构造动作。 表驱动(分析表)当非终结符A位于分析栈的顶部时，根据当前的输入记号（前看），必须使用刚刚描述过的分析办法做出一个决定：当替换栈中的 A时应为A选择哪一个文法规则，相反地，当记号位于栈顶部时，就无需做出这样的决定。 通过构造一个LL(1)分析表(LL(1) parsing table)就可以表达出可能的选择。 这样的表格基本上是一个由非终结符和终结符索引的二维数组，其中非终结符和终结符包括了要在恰当的分析 步骤（包括代表输入结束的$）中使用的产生式选择。这个表被称为M[N, T]，这里的N是文法的非终结符的集合， T是终结符或记号的集合M可被认为是“运动的”表。 我们假设表 **M[N, T]**在开始时，它的所有项目均为空。任何在构造之后继续为空的项目都代表了在分析中可能发生的潜在错误。根据以下规则在这个表中添加产生式： 如果$A\\to\\alpha$是一个产生式选择,且有推导$\\alpha\\Rightarrow\\ ^*a\\beta$成立，其中$a$是一个记号，则添加到表中 如果$A→α$是一个产生式选择，且有推导$α ⇒ \\ ^*\\varepsilon$ 和 $S \\$ ⇒ \\ ^∗βAaγ $ 成立，其中S是开始符号， $a$是一个记号（或$），则添加到表中 在规则1中，在输入中给出了记号$a$，若$α$可为匹配生成一个$a$，则希望挑选规则$A→α$ 在规则2中，若A派生了空串（通过A→α），且如a 是一个在推导中可合法地出现在A之后的记号，则要挑选$A→α$以使A消失。 很难完成这些要求，需要First和Follow集合 上面例子中的M[N, T]: M[N, T] $($ $)$ $$$ $S$ $S\\to(S)S$ $S\\to \\varepsilon $ $S\\to \\varepsilon $ 定义：如果文法G相关的LL(1)分析表的每个项目中至多只有一个产生式，则该文法就是LL(1)文法 由于上面的定义暗示着利用L L ( 1 )文法表就能构造出一个无二义性的分析，所以 LL (1)文法不能是二义性的。 表驱动LL分析器架构： FIRST集定义：FIRST(N) = 从非终结符N开始推导得出的句子开头的所有可能终结符集合 计算公式，近似如下： 注意只关心开头符号 $$ 对\\ N\\to a \\ ...\\\\ FIRST(N)\\ \\cup=\\{a\\}\\\\ 对\\ N\\to M\\ ...\\\\ FIRST(N)\\ \\cup=FIRST(M) $$ 把FIRST扩展到任意串上： 构造LL(1)分析表：表中的数字是文法规则，当栈顶非终结符为N，下个处理符号是T，使用文法规则num 冲突：LL(1)分析表中每个表项，至多只能有一个产生式，如果出现多个选择，就是冲突 冲突检测,对N的两条产生式规则$N\\to\\beta$和$N\\to\\gamma$，要求$FIRST(\\beta)\\cap FIRST(\\gamma)={}$ 而上图中$FIRST(w)\\cap FIRST(wV)={w}$，所以冲突了，体现在表中，就是有两个选择 FOLLOW集对于如下例子：一般条件下的LL(1)分析表构造 $$ Z\\to d\\ |\\ X\\ Y\\ Z\\\\ Y\\to c\\ |\\ \\varepsilon\\\\ X\\to Y\\ |\\ a $$ $FIRST_(X\\ Y\\ Z)=?$ X由Y开头，但Y又可以是空串，那X也能是空串，又只能去看Y，Y可能是空串，看Z，最终Z取d，所以$FIRST_(X\\ Y\\ Z)=\\{a\\ c\\ d\\}$ 一般情况下需知道某个非终结符是否可以推出空串，NULLABLE集 并且一般需要知道在某个非终结符后面可以跟着什么符号，FOLLOW集 对于Y，当取空串的时候，直接弹出栈，没有串压入(空串)，但还要知道谁能跟在Y后面，不然没法向下走，只有知道谁能跟在后面，才能判断输入是否合法 NULLABLE集合：当非终结符X属于集合NULLABLE，当且仅当： $X\\to\\varepsilon$，可以直接推出空串 $X\\to Y_1,…,Y_n$，Y是n个非终结符，且全都属于NULLABLE集 FIRST集合完整计算公式： FOLLOW集算法： text foreach (非终结符 N) FOLLOW(N) = {} // 初始化为空集 while (第一次循环 或 有集合发生变化) foreach (每个产生式 p) // p的形式就是产生式 N -\u003e B1 ... Bn temp = FOLLOW(N) // 临时集合 foreach (Bn to B1) // 考虑每个符号，逆序处理 if (Bi == a ...) // 如果是个终结符 temp = {a} if (Bi == M ...) // 是个非终结符 FOLLOW(M) += temp if (M 不是 NULLABLE) temp = FIRST(M) else temp += FIRST(M) /* N -\u003e B1 B2 ... Bn temp */ $$ z\\ \\to\\ d\\ |\\ X\\ Y\\ Z\\\\ Y\\ \\to\\ c\\ |\\ \\varepsilon\\\\ X\\ \\to\\ Y\\ |\\ a $$ $NULLABLE={X,Y}$ X Y Z FIRST ${a,c}$ ${c}$ ${a,c,d}$ N-FOLLOW / 循环轮次 0 1 2 Z ${ }$ ${}$ Y ${}$ ${a,c,d}$ X ${}$ ${a,c,d}$ 计算FIRST_S集合： text foreach (考虑每个产生式 p) FIRST_S(p) = {} calculte_FIRST_S (考虑每个产生式 P) // p的形式就是产生式 N -\u003e B1 ... Bn foreach (B1 to Bn) if (Bi == a...) //终结符开头 FIRST_S(p) += {a} return if (Bi == M...) FIRST_S(p) += FIRST(M) if (M 不是 NULLABLE) return; FIRST_S(p) += FOLLOW(N) 数字代表的是对应的产生式 冲突处理: 消除左递归和提取左因子这两个技术无法保证可将一个文法变成 LL(1)文法，然而，在绝大多数情况下，它们都十分有用，并且具有可自动操作其应用程序的优点，因此，假设有一个成功的结果，利用它们就可自动地生成LL(1)分析程序 简单直接左递归： $$ A\\to A\\alpha|\\beta $$ 其中α和β是终结符和非终结符的串，而且 β不以A开头，为了消除左递归，将这个文法规则重写为两个规则：一个是首先生成 β，另一个是生成α的重复，它不用左递归却用右递归： $$ A\\to \\beta A'\\\\A'\\to \\alpha A'|\\varepsilon $$ 普遍直接左递归： $$ A → Aα_1 | Aα_2 | . . . | Aα_n | β_1 | β_2 | . . . | β_m $$ 其解法与简单情况类似，只需将选择相应地扩展: $$ A →β_1 A'| β_2 A'| . . . | β_m A' \\\\ A' →α_1 A' | α_2 A' | . . . | α_n A' |\\varepsilon $$ 提取左因子 当两个或更多文法规则选择共享一个通用前缀串时，需要提取左因子。如: $$ A→αβ | α γ $$ 这个简单情况的解法是将左边","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:5:2","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#表驱动分析表"},{"categories":["compiler"],"content":" LL(1)分析算法分析算法规范后，可以利用算法自动生成语法分析器的代码，比如一些工具： ANTLR LL(1)分析算法： 从 左(L) 向右读入程序，最 左(L) 推导，采用 一个(1) 前看符号(用未读入的符号做辅助) 分析高效(线性时间) 错误定位和诊断信息准确 有很多开源或商业生成工具：ANTLR… 基本思想：表驱动的分析算法 缺点 能分析的文法类型受限 往往需要文法的改写 LL(1)分析的基本方法：LL(1)分析使用显式栈而不是递归调用来完成分析。 如文法：$S\\to(S)S|\\varepsilon$ ，一个匹配成对括号的文法，假设我们的输入串是\"()\" 分析栈 输入 动作 1 $ S ()$ $S\\to(S)S$ 2 $ S ) S ( ()$ 匹配 3 $ S ) S )$ $S\\to\\varepsilon$ 4 $ S ) )$ 匹配 5 $ S $ $S\\to\\varepsilon$ 6 $ $ 接受 分析栈里的$表示栈底部，输入里的$表示串结束 利用文法选择$A→α$将栈顶部的非终结符$A$替换成串$α$。 将栈顶部的记号与下一个输入记号匹配 对于上面的例子： 初始，栈顶为S，输入() 选择用来替换栈顶S的规则是$S\\to(S)S$，所以将串S)S(压入栈,，（注意顺序是反向的，这样出栈顺序是(S)S） 发现栈顶的(和输入串(匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 发现栈顶的)和输入串)匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 栈为空，接受 这个过程与串()最左推导的步骤完全对应： $$ S\\Rightarrow (S)S \\ ,\\ \\ [S\\to(S)S] \\\\ \\Rightarrow ()S\\ , \\ \\ [S\\to\\varepsilon]\\\\ \\Rightarrow ()\\ ,\\ \\ [S\\to\\varepsilon] $$ 如果要在分析进行时构造一个分析树，则可当将每个非终结符或终结符压入到栈中时添加节点来构造动作。 表驱动(分析表)当非终结符A位于分析栈的顶部时，根据当前的输入记号（前看），必须使用刚刚描述过的分析办法做出一个决定：当替换栈中的 A时应为A选择哪一个文法规则，相反地，当记号位于栈顶部时，就无需做出这样的决定。 通过构造一个LL(1)分析表(LL(1) parsing table)就可以表达出可能的选择。 这样的表格基本上是一个由非终结符和终结符索引的二维数组，其中非终结符和终结符包括了要在恰当的分析 步骤（包括代表输入结束的$）中使用的产生式选择。这个表被称为M[N, T]，这里的N是文法的非终结符的集合， T是终结符或记号的集合M可被认为是“运动的”表。 我们假设表 **M[N, T]**在开始时，它的所有项目均为空。任何在构造之后继续为空的项目都代表了在分析中可能发生的潜在错误。根据以下规则在这个表中添加产生式： 如果$A\\to\\alpha$是一个产生式选择,且有推导$\\alpha\\Rightarrow\\ ^*a\\beta$成立，其中$a$是一个记号，则添加到表中 如果$A→α$是一个产生式选择，且有推导$α ⇒ \\ ^*\\varepsilon$ 和 $S \\$ ⇒ \\ ^∗βAaγ $ 成立，其中S是开始符号， $a$是一个记号（或$），则添加到表中 在规则1中，在输入中给出了记号$a$，若$α$可为匹配生成一个$a$，则希望挑选规则$A→α$ 在规则2中，若A派生了空串（通过A→α），且如a 是一个在推导中可合法地出现在A之后的记号，则要挑选$A→α$以使A消失。 很难完成这些要求，需要First和Follow集合 上面例子中的M[N, T]: M[N, T] $($ $)$ $$$ $S$ $S\\to(S)S$ $S\\to \\varepsilon $ $S\\to \\varepsilon $ 定义：如果文法G相关的LL(1)分析表的每个项目中至多只有一个产生式，则该文法就是LL(1)文法 由于上面的定义暗示着利用L L ( 1 )文法表就能构造出一个无二义性的分析，所以 LL (1)文法不能是二义性的。 表驱动LL分析器架构： FIRST集定义：FIRST(N) = 从非终结符N开始推导得出的句子开头的所有可能终结符集合 计算公式，近似如下： 注意只关心开头符号 $$ 对\\ N\\to a \\ ...\\\\ FIRST(N)\\ \\cup=\\{a\\}\\\\ 对\\ N\\to M\\ ...\\\\ FIRST(N)\\ \\cup=FIRST(M) $$ 把FIRST扩展到任意串上： 构造LL(1)分析表：表中的数字是文法规则，当栈顶非终结符为N，下个处理符号是T，使用文法规则num 冲突：LL(1)分析表中每个表项，至多只能有一个产生式，如果出现多个选择，就是冲突 冲突检测,对N的两条产生式规则$N\\to\\beta$和$N\\to\\gamma$，要求$FIRST(\\beta)\\cap FIRST(\\gamma)={}$ 而上图中$FIRST(w)\\cap FIRST(wV)={w}$，所以冲突了，体现在表中，就是有两个选择 FOLLOW集对于如下例子：一般条件下的LL(1)分析表构造 $$ Z\\to d\\ |\\ X\\ Y\\ Z\\\\ Y\\to c\\ |\\ \\varepsilon\\\\ X\\to Y\\ |\\ a $$ $FIRST_(X\\ Y\\ Z)=?$ X由Y开头，但Y又可以是空串，那X也能是空串，又只能去看Y，Y可能是空串，看Z，最终Z取d，所以$FIRST_(X\\ Y\\ Z)=\\{a\\ c\\ d\\}$ 一般情况下需知道某个非终结符是否可以推出空串，NULLABLE集 并且一般需要知道在某个非终结符后面可以跟着什么符号，FOLLOW集 对于Y，当取空串的时候，直接弹出栈，没有串压入(空串)，但还要知道谁能跟在Y后面，不然没法向下走，只有知道谁能跟在后面，才能判断输入是否合法 NULLABLE集合：当非终结符X属于集合NULLABLE，当且仅当： $X\\to\\varepsilon$，可以直接推出空串 $X\\to Y_1,…,Y_n$，Y是n个非终结符，且全都属于NULLABLE集 FIRST集合完整计算公式： FOLLOW集算法： text foreach (非终结符 N) FOLLOW(N) = {} // 初始化为空集 while (第一次循环 或 有集合发生变化) foreach (每个产生式 p) // p的形式就是产生式 N -\u003e B1 ... Bn temp = FOLLOW(N) // 临时集合 foreach (Bn to B1) // 考虑每个符号，逆序处理 if (Bi == a ...) // 如果是个终结符 temp = {a} if (Bi == M ...) // 是个非终结符 FOLLOW(M) += temp if (M 不是 NULLABLE) temp = FIRST(M) else temp += FIRST(M) /* N -\u003e B1 B2 ... Bn temp */ $$ z\\ \\to\\ d\\ |\\ X\\ Y\\ Z\\\\ Y\\ \\to\\ c\\ |\\ \\varepsilon\\\\ X\\ \\to\\ Y\\ |\\ a $$ $NULLABLE={X,Y}$ X Y Z FIRST ${a,c}$ ${c}$ ${a,c,d}$ N-FOLLOW / 循环轮次 0 1 2 Z ${ }$ ${}$ Y ${}$ ${a,c,d}$ X ${}$ ${a,c,d}$ 计算FIRST_S集合： text foreach (考虑每个产生式 p) FIRST_S(p) = {} calculte_FIRST_S (考虑每个产生式 P) // p的形式就是产生式 N -\u003e B1 ... Bn foreach (B1 to Bn) if (Bi == a...) //终结符开头 FIRST_S(p) += {a} return if (Bi == M...) FIRST_S(p) += FIRST(M) if (M 不是 NULLABLE) return; FIRST_S(p) += FOLLOW(N) 数字代表的是对应的产生式 冲突处理: 消除左递归和提取左因子这两个技术无法保证可将一个文法变成 LL(1)文法，然而，在绝大多数情况下，它们都十分有用，并且具有可自动操作其应用程序的优点，因此，假设有一个成功的结果，利用它们就可自动地生成LL(1)分析程序 简单直接左递归： $$ A\\to A\\alpha|\\beta $$ 其中α和β是终结符和非终结符的串，而且 β不以A开头，为了消除左递归，将这个文法规则重写为两个规则：一个是首先生成 β，另一个是生成α的重复，它不用左递归却用右递归： $$ A\\to \\beta A'\\\\A'\\to \\alpha A'|\\varepsilon $$ 普遍直接左递归： $$ A → Aα_1 | Aα_2 | . . . | Aα_n | β_1 | β_2 | . . . | β_m $$ 其解法与简单情况类似，只需将选择相应地扩展: $$ A →β_1 A'| β_2 A'| . . . | β_m A' \\\\ A' →α_1 A' | α_2 A' | . . . | α_n A' |\\varepsilon $$ 提取左因子 当两个或更多文法规则选择共享一个通用前缀串时，需要提取左因子。如: $$ A→αβ | α γ $$ 这个简单情况的解法是将左边","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:5:2","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#first集"},{"categories":["compiler"],"content":" LL(1)分析算法分析算法规范后，可以利用算法自动生成语法分析器的代码，比如一些工具： ANTLR LL(1)分析算法： 从 左(L) 向右读入程序，最 左(L) 推导，采用 一个(1) 前看符号(用未读入的符号做辅助) 分析高效(线性时间) 错误定位和诊断信息准确 有很多开源或商业生成工具：ANTLR… 基本思想：表驱动的分析算法 缺点 能分析的文法类型受限 往往需要文法的改写 LL(1)分析的基本方法：LL(1)分析使用显式栈而不是递归调用来完成分析。 如文法：$S\\to(S)S|\\varepsilon$ ，一个匹配成对括号的文法，假设我们的输入串是\"()\" 分析栈 输入 动作 1 $ S ()$ $S\\to(S)S$ 2 $ S ) S ( ()$ 匹配 3 $ S ) S )$ $S\\to\\varepsilon$ 4 $ S ) )$ 匹配 5 $ S $ $S\\to\\varepsilon$ 6 $ $ 接受 分析栈里的$表示栈底部，输入里的$表示串结束 利用文法选择$A→α$将栈顶部的非终结符$A$替换成串$α$。 将栈顶部的记号与下一个输入记号匹配 对于上面的例子： 初始，栈顶为S，输入() 选择用来替换栈顶S的规则是$S\\to(S)S$，所以将串S)S(压入栈,，（注意顺序是反向的，这样出栈顺序是(S)S） 发现栈顶的(和输入串(匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 发现栈顶的)和输入串)匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 栈为空，接受 这个过程与串()最左推导的步骤完全对应： $$ S\\Rightarrow (S)S \\ ,\\ \\ [S\\to(S)S] \\\\ \\Rightarrow ()S\\ , \\ \\ [S\\to\\varepsilon]\\\\ \\Rightarrow ()\\ ,\\ \\ [S\\to\\varepsilon] $$ 如果要在分析进行时构造一个分析树，则可当将每个非终结符或终结符压入到栈中时添加节点来构造动作。 表驱动(分析表)当非终结符A位于分析栈的顶部时，根据当前的输入记号（前看），必须使用刚刚描述过的分析办法做出一个决定：当替换栈中的 A时应为A选择哪一个文法规则，相反地，当记号位于栈顶部时，就无需做出这样的决定。 通过构造一个LL(1)分析表(LL(1) parsing table)就可以表达出可能的选择。 这样的表格基本上是一个由非终结符和终结符索引的二维数组，其中非终结符和终结符包括了要在恰当的分析 步骤（包括代表输入结束的$）中使用的产生式选择。这个表被称为M[N, T]，这里的N是文法的非终结符的集合， T是终结符或记号的集合M可被认为是“运动的”表。 我们假设表 **M[N, T]**在开始时，它的所有项目均为空。任何在构造之后继续为空的项目都代表了在分析中可能发生的潜在错误。根据以下规则在这个表中添加产生式： 如果$A\\to\\alpha$是一个产生式选择,且有推导$\\alpha\\Rightarrow\\ ^*a\\beta$成立，其中$a$是一个记号，则添加到表中 如果$A→α$是一个产生式选择，且有推导$α ⇒ \\ ^*\\varepsilon$ 和 $S \\$ ⇒ \\ ^∗βAaγ $ 成立，其中S是开始符号， $a$是一个记号（或$），则添加到表中 在规则1中，在输入中给出了记号$a$，若$α$可为匹配生成一个$a$，则希望挑选规则$A→α$ 在规则2中，若A派生了空串（通过A→α），且如a 是一个在推导中可合法地出现在A之后的记号，则要挑选$A→α$以使A消失。 很难完成这些要求，需要First和Follow集合 上面例子中的M[N, T]: M[N, T] $($ $)$ $$$ $S$ $S\\to(S)S$ $S\\to \\varepsilon $ $S\\to \\varepsilon $ 定义：如果文法G相关的LL(1)分析表的每个项目中至多只有一个产生式，则该文法就是LL(1)文法 由于上面的定义暗示着利用L L ( 1 )文法表就能构造出一个无二义性的分析，所以 LL (1)文法不能是二义性的。 表驱动LL分析器架构： FIRST集定义：FIRST(N) = 从非终结符N开始推导得出的句子开头的所有可能终结符集合 计算公式，近似如下： 注意只关心开头符号 $$ 对\\ N\\to a \\ ...\\\\ FIRST(N)\\ \\cup=\\{a\\}\\\\ 对\\ N\\to M\\ ...\\\\ FIRST(N)\\ \\cup=FIRST(M) $$ 把FIRST扩展到任意串上： 构造LL(1)分析表：表中的数字是文法规则，当栈顶非终结符为N，下个处理符号是T，使用文法规则num 冲突：LL(1)分析表中每个表项，至多只能有一个产生式，如果出现多个选择，就是冲突 冲突检测,对N的两条产生式规则$N\\to\\beta$和$N\\to\\gamma$，要求$FIRST(\\beta)\\cap FIRST(\\gamma)={}$ 而上图中$FIRST(w)\\cap FIRST(wV)={w}$，所以冲突了，体现在表中，就是有两个选择 FOLLOW集对于如下例子：一般条件下的LL(1)分析表构造 $$ Z\\to d\\ |\\ X\\ Y\\ Z\\\\ Y\\to c\\ |\\ \\varepsilon\\\\ X\\to Y\\ |\\ a $$ $FIRST_(X\\ Y\\ Z)=?$ X由Y开头，但Y又可以是空串，那X也能是空串，又只能去看Y，Y可能是空串，看Z，最终Z取d，所以$FIRST_(X\\ Y\\ Z)=\\{a\\ c\\ d\\}$ 一般情况下需知道某个非终结符是否可以推出空串，NULLABLE集 并且一般需要知道在某个非终结符后面可以跟着什么符号，FOLLOW集 对于Y，当取空串的时候，直接弹出栈，没有串压入(空串)，但还要知道谁能跟在Y后面，不然没法向下走，只有知道谁能跟在后面，才能判断输入是否合法 NULLABLE集合：当非终结符X属于集合NULLABLE，当且仅当： $X\\to\\varepsilon$，可以直接推出空串 $X\\to Y_1,…,Y_n$，Y是n个非终结符，且全都属于NULLABLE集 FIRST集合完整计算公式： FOLLOW集算法： text foreach (非终结符 N) FOLLOW(N) = {} // 初始化为空集 while (第一次循环 或 有集合发生变化) foreach (每个产生式 p) // p的形式就是产生式 N -\u003e B1 ... Bn temp = FOLLOW(N) // 临时集合 foreach (Bn to B1) // 考虑每个符号，逆序处理 if (Bi == a ...) // 如果是个终结符 temp = {a} if (Bi == M ...) // 是个非终结符 FOLLOW(M) += temp if (M 不是 NULLABLE) temp = FIRST(M) else temp += FIRST(M) /* N -\u003e B1 B2 ... Bn temp */ $$ z\\ \\to\\ d\\ |\\ X\\ Y\\ Z\\\\ Y\\ \\to\\ c\\ |\\ \\varepsilon\\\\ X\\ \\to\\ Y\\ |\\ a $$ $NULLABLE={X,Y}$ X Y Z FIRST ${a,c}$ ${c}$ ${a,c,d}$ N-FOLLOW / 循环轮次 0 1 2 Z ${ }$ ${}$ Y ${}$ ${a,c,d}$ X ${}$ ${a,c,d}$ 计算FIRST_S集合： text foreach (考虑每个产生式 p) FIRST_S(p) = {} calculte_FIRST_S (考虑每个产生式 P) // p的形式就是产生式 N -\u003e B1 ... Bn foreach (B1 to Bn) if (Bi == a...) //终结符开头 FIRST_S(p) += {a} return if (Bi == M...) FIRST_S(p) += FIRST(M) if (M 不是 NULLABLE) return; FIRST_S(p) += FOLLOW(N) 数字代表的是对应的产生式 冲突处理: 消除左递归和提取左因子这两个技术无法保证可将一个文法变成 LL(1)文法，然而，在绝大多数情况下，它们都十分有用，并且具有可自动操作其应用程序的优点，因此，假设有一个成功的结果，利用它们就可自动地生成LL(1)分析程序 简单直接左递归： $$ A\\to A\\alpha|\\beta $$ 其中α和β是终结符和非终结符的串，而且 β不以A开头，为了消除左递归，将这个文法规则重写为两个规则：一个是首先生成 β，另一个是生成α的重复，它不用左递归却用右递归： $$ A\\to \\beta A'\\\\A'\\to \\alpha A'|\\varepsilon $$ 普遍直接左递归： $$ A → Aα_1 | Aα_2 | . . . | Aα_n | β_1 | β_2 | . . . | β_m $$ 其解法与简单情况类似，只需将选择相应地扩展: $$ A →β_1 A'| β_2 A'| . . . | β_m A' \\\\ A' →α_1 A' | α_2 A' | . . . | α_n A' |\\varepsilon $$ 提取左因子 当两个或更多文法规则选择共享一个通用前缀串时，需要提取左因子。如: $$ A→αβ | α γ $$ 这个简单情况的解法是将左边","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:5:2","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#follow集"},{"categories":["compiler"],"content":" LL(1)分析算法分析算法规范后，可以利用算法自动生成语法分析器的代码，比如一些工具： ANTLR LL(1)分析算法： 从 左(L) 向右读入程序，最 左(L) 推导，采用 一个(1) 前看符号(用未读入的符号做辅助) 分析高效(线性时间) 错误定位和诊断信息准确 有很多开源或商业生成工具：ANTLR… 基本思想：表驱动的分析算法 缺点 能分析的文法类型受限 往往需要文法的改写 LL(1)分析的基本方法：LL(1)分析使用显式栈而不是递归调用来完成分析。 如文法：$S\\to(S)S|\\varepsilon$ ，一个匹配成对括号的文法，假设我们的输入串是\"()\" 分析栈 输入 动作 1 $ S ()$ $S\\to(S)S$ 2 $ S ) S ( ()$ 匹配 3 $ S ) S )$ $S\\to\\varepsilon$ 4 $ S ) )$ 匹配 5 $ S $ $S\\to\\varepsilon$ 6 $ $ 接受 分析栈里的$表示栈底部，输入里的$表示串结束 利用文法选择$A→α$将栈顶部的非终结符$A$替换成串$α$。 将栈顶部的记号与下一个输入记号匹配 对于上面的例子： 初始，栈顶为S，输入() 选择用来替换栈顶S的规则是$S\\to(S)S$，所以将串S)S(压入栈,，（注意顺序是反向的，这样出栈顺序是(S)S） 发现栈顶的(和输入串(匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 发现栈顶的)和输入串)匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 栈为空，接受 这个过程与串()最左推导的步骤完全对应： $$ S\\Rightarrow (S)S \\ ,\\ \\ [S\\to(S)S] \\\\ \\Rightarrow ()S\\ , \\ \\ [S\\to\\varepsilon]\\\\ \\Rightarrow ()\\ ,\\ \\ [S\\to\\varepsilon] $$ 如果要在分析进行时构造一个分析树，则可当将每个非终结符或终结符压入到栈中时添加节点来构造动作。 表驱动(分析表)当非终结符A位于分析栈的顶部时，根据当前的输入记号（前看），必须使用刚刚描述过的分析办法做出一个决定：当替换栈中的 A时应为A选择哪一个文法规则，相反地，当记号位于栈顶部时，就无需做出这样的决定。 通过构造一个LL(1)分析表(LL(1) parsing table)就可以表达出可能的选择。 这样的表格基本上是一个由非终结符和终结符索引的二维数组，其中非终结符和终结符包括了要在恰当的分析 步骤（包括代表输入结束的$）中使用的产生式选择。这个表被称为M[N, T]，这里的N是文法的非终结符的集合， T是终结符或记号的集合M可被认为是“运动的”表。 我们假设表 **M[N, T]**在开始时，它的所有项目均为空。任何在构造之后继续为空的项目都代表了在分析中可能发生的潜在错误。根据以下规则在这个表中添加产生式： 如果$A\\to\\alpha$是一个产生式选择,且有推导$\\alpha\\Rightarrow\\ ^*a\\beta$成立，其中$a$是一个记号，则添加到表中 如果$A→α$是一个产生式选择，且有推导$α ⇒ \\ ^*\\varepsilon$ 和 $S \\$ ⇒ \\ ^∗βAaγ $ 成立，其中S是开始符号， $a$是一个记号（或$），则添加到表中 在规则1中，在输入中给出了记号$a$，若$α$可为匹配生成一个$a$，则希望挑选规则$A→α$ 在规则2中，若A派生了空串（通过A→α），且如a 是一个在推导中可合法地出现在A之后的记号，则要挑选$A→α$以使A消失。 很难完成这些要求，需要First和Follow集合 上面例子中的M[N, T]: M[N, T] $($ $)$ $$$ $S$ $S\\to(S)S$ $S\\to \\varepsilon $ $S\\to \\varepsilon $ 定义：如果文法G相关的LL(1)分析表的每个项目中至多只有一个产生式，则该文法就是LL(1)文法 由于上面的定义暗示着利用L L ( 1 )文法表就能构造出一个无二义性的分析，所以 LL (1)文法不能是二义性的。 表驱动LL分析器架构： FIRST集定义：FIRST(N) = 从非终结符N开始推导得出的句子开头的所有可能终结符集合 计算公式，近似如下： 注意只关心开头符号 $$ 对\\ N\\to a \\ ...\\\\ FIRST(N)\\ \\cup=\\{a\\}\\\\ 对\\ N\\to M\\ ...\\\\ FIRST(N)\\ \\cup=FIRST(M) $$ 把FIRST扩展到任意串上： 构造LL(1)分析表：表中的数字是文法规则，当栈顶非终结符为N，下个处理符号是T，使用文法规则num 冲突：LL(1)分析表中每个表项，至多只能有一个产生式，如果出现多个选择，就是冲突 冲突检测,对N的两条产生式规则$N\\to\\beta$和$N\\to\\gamma$，要求$FIRST(\\beta)\\cap FIRST(\\gamma)={}$ 而上图中$FIRST(w)\\cap FIRST(wV)={w}$，所以冲突了，体现在表中，就是有两个选择 FOLLOW集对于如下例子：一般条件下的LL(1)分析表构造 $$ Z\\to d\\ |\\ X\\ Y\\ Z\\\\ Y\\to c\\ |\\ \\varepsilon\\\\ X\\to Y\\ |\\ a $$ $FIRST_(X\\ Y\\ Z)=?$ X由Y开头，但Y又可以是空串，那X也能是空串，又只能去看Y，Y可能是空串，看Z，最终Z取d，所以$FIRST_(X\\ Y\\ Z)=\\{a\\ c\\ d\\}$ 一般情况下需知道某个非终结符是否可以推出空串，NULLABLE集 并且一般需要知道在某个非终结符后面可以跟着什么符号，FOLLOW集 对于Y，当取空串的时候，直接弹出栈，没有串压入(空串)，但还要知道谁能跟在Y后面，不然没法向下走，只有知道谁能跟在后面，才能判断输入是否合法 NULLABLE集合：当非终结符X属于集合NULLABLE，当且仅当： $X\\to\\varepsilon$，可以直接推出空串 $X\\to Y_1,…,Y_n$，Y是n个非终结符，且全都属于NULLABLE集 FIRST集合完整计算公式： FOLLOW集算法： text foreach (非终结符 N) FOLLOW(N) = {} // 初始化为空集 while (第一次循环 或 有集合发生变化) foreach (每个产生式 p) // p的形式就是产生式 N -\u003e B1 ... Bn temp = FOLLOW(N) // 临时集合 foreach (Bn to B1) // 考虑每个符号，逆序处理 if (Bi == a ...) // 如果是个终结符 temp = {a} if (Bi == M ...) // 是个非终结符 FOLLOW(M) += temp if (M 不是 NULLABLE) temp = FIRST(M) else temp += FIRST(M) /* N -\u003e B1 B2 ... Bn temp */ $$ z\\ \\to\\ d\\ |\\ X\\ Y\\ Z\\\\ Y\\ \\to\\ c\\ |\\ \\varepsilon\\\\ X\\ \\to\\ Y\\ |\\ a $$ $NULLABLE={X,Y}$ X Y Z FIRST ${a,c}$ ${c}$ ${a,c,d}$ N-FOLLOW / 循环轮次 0 1 2 Z ${ }$ ${}$ Y ${}$ ${a,c,d}$ X ${}$ ${a,c,d}$ 计算FIRST_S集合： text foreach (考虑每个产生式 p) FIRST_S(p) = {} calculte_FIRST_S (考虑每个产生式 P) // p的形式就是产生式 N -\u003e B1 ... Bn foreach (B1 to Bn) if (Bi == a...) //终结符开头 FIRST_S(p) += {a} return if (Bi == M...) FIRST_S(p) += FIRST(M) if (M 不是 NULLABLE) return; FIRST_S(p) += FOLLOW(N) 数字代表的是对应的产生式 冲突处理: 消除左递归和提取左因子这两个技术无法保证可将一个文法变成 LL(1)文法，然而，在绝大多数情况下，它们都十分有用，并且具有可自动操作其应用程序的优点，因此，假设有一个成功的结果，利用它们就可自动地生成LL(1)分析程序 简单直接左递归： $$ A\\to A\\alpha|\\beta $$ 其中α和β是终结符和非终结符的串，而且 β不以A开头，为了消除左递归，将这个文法规则重写为两个规则：一个是首先生成 β，另一个是生成α的重复，它不用左递归却用右递归： $$ A\\to \\beta A'\\\\A'\\to \\alpha A'|\\varepsilon $$ 普遍直接左递归： $$ A → Aα_1 | Aα_2 | . . . | Aα_n | β_1 | β_2 | . . . | β_m $$ 其解法与简单情况类似，只需将选择相应地扩展: $$ A →β_1 A'| β_2 A'| . . . | β_m A' \\\\ A' →α_1 A' | α_2 A' | . . . | α_n A' |\\varepsilon $$ 提取左因子 当两个或更多文法规则选择共享一个通用前缀串时，需要提取左因子。如: $$ A→αβ | α γ $$ 这个简单情况的解法是将左边","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:5:2","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#冲突处理-消除左递归和提取左因子"},{"categories":["compiler"],"content":" LL(1)分析算法分析算法规范后，可以利用算法自动生成语法分析器的代码，比如一些工具： ANTLR LL(1)分析算法： 从 左(L) 向右读入程序，最 左(L) 推导，采用 一个(1) 前看符号(用未读入的符号做辅助) 分析高效(线性时间) 错误定位和诊断信息准确 有很多开源或商业生成工具：ANTLR… 基本思想：表驱动的分析算法 缺点 能分析的文法类型受限 往往需要文法的改写 LL(1)分析的基本方法：LL(1)分析使用显式栈而不是递归调用来完成分析。 如文法：$S\\to(S)S|\\varepsilon$ ，一个匹配成对括号的文法，假设我们的输入串是\"()\" 分析栈 输入 动作 1 $ S ()$ $S\\to(S)S$ 2 $ S ) S ( ()$ 匹配 3 $ S ) S )$ $S\\to\\varepsilon$ 4 $ S ) )$ 匹配 5 $ S $ $S\\to\\varepsilon$ 6 $ $ 接受 分析栈里的$表示栈底部，输入里的$表示串结束 利用文法选择$A→α$将栈顶部的非终结符$A$替换成串$α$。 将栈顶部的记号与下一个输入记号匹配 对于上面的例子： 初始，栈顶为S，输入() 选择用来替换栈顶S的规则是$S\\to(S)S$，所以将串S)S(压入栈,，（注意顺序是反向的，这样出栈顺序是(S)S） 发现栈顶的(和输入串(匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 发现栈顶的)和输入串)匹配，弹出，继续 栈顶又变成S，用$S\\to\\varepsilon$替换，即空串替换，仅弹出S 栈为空，接受 这个过程与串()最左推导的步骤完全对应： $$ S\\Rightarrow (S)S \\ ,\\ \\ [S\\to(S)S] \\\\ \\Rightarrow ()S\\ , \\ \\ [S\\to\\varepsilon]\\\\ \\Rightarrow ()\\ ,\\ \\ [S\\to\\varepsilon] $$ 如果要在分析进行时构造一个分析树，则可当将每个非终结符或终结符压入到栈中时添加节点来构造动作。 表驱动(分析表)当非终结符A位于分析栈的顶部时，根据当前的输入记号（前看），必须使用刚刚描述过的分析办法做出一个决定：当替换栈中的 A时应为A选择哪一个文法规则，相反地，当记号位于栈顶部时，就无需做出这样的决定。 通过构造一个LL(1)分析表(LL(1) parsing table)就可以表达出可能的选择。 这样的表格基本上是一个由非终结符和终结符索引的二维数组，其中非终结符和终结符包括了要在恰当的分析 步骤（包括代表输入结束的$）中使用的产生式选择。这个表被称为M[N, T]，这里的N是文法的非终结符的集合， T是终结符或记号的集合M可被认为是“运动的”表。 我们假设表 **M[N, T]**在开始时，它的所有项目均为空。任何在构造之后继续为空的项目都代表了在分析中可能发生的潜在错误。根据以下规则在这个表中添加产生式： 如果$A\\to\\alpha$是一个产生式选择,且有推导$\\alpha\\Rightarrow\\ ^*a\\beta$成立，其中$a$是一个记号，则添加到表中 如果$A→α$是一个产生式选择，且有推导$α ⇒ \\ ^*\\varepsilon$ 和 $S \\$ ⇒ \\ ^∗βAaγ $ 成立，其中S是开始符号， $a$是一个记号（或$），则添加到表中 在规则1中，在输入中给出了记号$a$，若$α$可为匹配生成一个$a$，则希望挑选规则$A→α$ 在规则2中，若A派生了空串（通过A→α），且如a 是一个在推导中可合法地出现在A之后的记号，则要挑选$A→α$以使A消失。 很难完成这些要求，需要First和Follow集合 上面例子中的M[N, T]: M[N, T] $($ $)$ $$$ $S$ $S\\to(S)S$ $S\\to \\varepsilon $ $S\\to \\varepsilon $ 定义：如果文法G相关的LL(1)分析表的每个项目中至多只有一个产生式，则该文法就是LL(1)文法 由于上面的定义暗示着利用L L ( 1 )文法表就能构造出一个无二义性的分析，所以 LL (1)文法不能是二义性的。 表驱动LL分析器架构： FIRST集定义：FIRST(N) = 从非终结符N开始推导得出的句子开头的所有可能终结符集合 计算公式，近似如下： 注意只关心开头符号 $$ 对\\ N\\to a \\ ...\\\\ FIRST(N)\\ \\cup=\\{a\\}\\\\ 对\\ N\\to M\\ ...\\\\ FIRST(N)\\ \\cup=FIRST(M) $$ 把FIRST扩展到任意串上： 构造LL(1)分析表：表中的数字是文法规则，当栈顶非终结符为N，下个处理符号是T，使用文法规则num 冲突：LL(1)分析表中每个表项，至多只能有一个产生式，如果出现多个选择，就是冲突 冲突检测,对N的两条产生式规则$N\\to\\beta$和$N\\to\\gamma$，要求$FIRST(\\beta)\\cap FIRST(\\gamma)={}$ 而上图中$FIRST(w)\\cap FIRST(wV)={w}$，所以冲突了，体现在表中，就是有两个选择 FOLLOW集对于如下例子：一般条件下的LL(1)分析表构造 $$ Z\\to d\\ |\\ X\\ Y\\ Z\\\\ Y\\to c\\ |\\ \\varepsilon\\\\ X\\to Y\\ |\\ a $$ $FIRST_(X\\ Y\\ Z)=?$ X由Y开头，但Y又可以是空串，那X也能是空串，又只能去看Y，Y可能是空串，看Z，最终Z取d，所以$FIRST_(X\\ Y\\ Z)=\\{a\\ c\\ d\\}$ 一般情况下需知道某个非终结符是否可以推出空串，NULLABLE集 并且一般需要知道在某个非终结符后面可以跟着什么符号，FOLLOW集 对于Y，当取空串的时候，直接弹出栈，没有串压入(空串)，但还要知道谁能跟在Y后面，不然没法向下走，只有知道谁能跟在后面，才能判断输入是否合法 NULLABLE集合：当非终结符X属于集合NULLABLE，当且仅当： $X\\to\\varepsilon$，可以直接推出空串 $X\\to Y_1,…,Y_n$，Y是n个非终结符，且全都属于NULLABLE集 FIRST集合完整计算公式： FOLLOW集算法： text foreach (非终结符 N) FOLLOW(N) = {} // 初始化为空集 while (第一次循环 或 有集合发生变化) foreach (每个产生式 p) // p的形式就是产生式 N -\u003e B1 ... Bn temp = FOLLOW(N) // 临时集合 foreach (Bn to B1) // 考虑每个符号，逆序处理 if (Bi == a ...) // 如果是个终结符 temp = {a} if (Bi == M ...) // 是个非终结符 FOLLOW(M) += temp if (M 不是 NULLABLE) temp = FIRST(M) else temp += FIRST(M) /* N -\u003e B1 B2 ... Bn temp */ $$ z\\ \\to\\ d\\ |\\ X\\ Y\\ Z\\\\ Y\\ \\to\\ c\\ |\\ \\varepsilon\\\\ X\\ \\to\\ Y\\ |\\ a $$ $NULLABLE={X,Y}$ X Y Z FIRST ${a,c}$ ${c}$ ${a,c,d}$ N-FOLLOW / 循环轮次 0 1 2 Z ${ }$ ${}$ Y ${}$ ${a,c,d}$ X ${}$ ${a,c,d}$ 计算FIRST_S集合： text foreach (考虑每个产生式 p) FIRST_S(p) = {} calculte_FIRST_S (考虑每个产生式 P) // p的形式就是产生式 N -\u003e B1 ... Bn foreach (B1 to Bn) if (Bi == a...) //终结符开头 FIRST_S(p) += {a} return if (Bi == M...) FIRST_S(p) += FIRST(M) if (M 不是 NULLABLE) return; FIRST_S(p) += FOLLOW(N) 数字代表的是对应的产生式 冲突处理: 消除左递归和提取左因子这两个技术无法保证可将一个文法变成 LL(1)文法，然而，在绝大多数情况下，它们都十分有用，并且具有可自动操作其应用程序的优点，因此，假设有一个成功的结果，利用它们就可自动地生成LL(1)分析程序 简单直接左递归： $$ A\\to A\\alpha|\\beta $$ 其中α和β是终结符和非终结符的串，而且 β不以A开头，为了消除左递归，将这个文法规则重写为两个规则：一个是首先生成 β，另一个是生成α的重复，它不用左递归却用右递归： $$ A\\to \\beta A'\\\\A'\\to \\alpha A'|\\varepsilon $$ 普遍直接左递归： $$ A → Aα_1 | Aα_2 | . . . | Aα_n | β_1 | β_2 | . . . | β_m $$ 其解法与简单情况类似，只需将选择相应地扩展: $$ A →β_1 A'| β_2 A'| . . . | β_m A' \\\\ A' →α_1 A' | α_2 A' | . . . | α_n A' |\\varepsilon $$ 提取左因子 当两个或更多文法规则选择共享一个通用前缀串时，需要提取左因子。如: $$ A→αβ | α γ $$ 这个简单情况的解法是将左边","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:5:2","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#构造分析表"},{"categories":["compiler"],"content":" 自底向上的分析","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:6:0","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#自底向上的分析"},{"categories":["compiler"],"content":" LR(0)LR分析算法(移进-规约算法) 运行高效 有现成的工具 YACC，bison 规约：对于一个产生式，从左到右，叫推导或替换，从右到左叫规约 比如 $F\\to n$，由$F$得到$n$叫推导，反过来叫规约 算法基本思想： $$ S\\to E\\\\ E\\to E+T\\ |\\ T\\\\ T\\to T*F\\ |\\ F\\\\ F\\to n $$ $$ 2+3*4\\\\ F+3*4\\\\ T+3*4\\\\ E+3*4\\\\ \\ \\\\ E+F*4\\\\ E+T*4\\\\ \\ \\\\ E+T*F\\\\ E+T\\\\ E\\\\ S $$ 对于上面的文法，如果输入为$2+3*4$ 首先读入$2$，跟产生式右侧比对，看能不能进行规约 $2$规约为$F$，继续规约为$T$，继续规约为$E$，然后就不能继续了 处理后续读入，当输入$3$ $3$规约为$F$，继续规约为$T$，$T$这里不能继续动了 继续读入，当读入$4$ $4$规约为$F$， $T*F$合起来规约为$T$，$E+T$再合起来规约为$E$，最后得到$S$ 分析完成，反之如果收缩不到$S$则判断输入包含语法错误 如果这个分析过程，从下往上看，刚好是最右推导的过程 点记号为了方便标记语法分析器已经读入了多少输入，我们可以引入一个点记号 $.$ 比如：$E+3.*4$，点号左边是已经读入的，右边是剩余的输入 给上面的例子加上点： 把点对齐 生成步骤 项目及分析算法上下文无关文法的 LR(0)项 (LR(0) item)，是在其右边带有区分位置（$.$）的产生式选择 LR(0) 项可作为一个保持有关分析栈和移进-归约分析过程的信息的有穷自动机的状态来使用。 为了能开始分析，我们将底标记 $$$和开始状态$0$压入到栈中，所以分析在开始时的状况表示为： 分析栈 输入 $ \\$\\ 0$ $inputstring\\ \\$ $ 现在假设下一步是将记号$n $移进到栈中并进入到状态$2$ 分析栈 输入 $ \\$\\ 0\\ n\\ 2$ $inputstring\\ \\$ $ 输入的剩余部分 LR(0)分析算法根据当前的DFA状态选择一个动作，这个状态总是出现在栈的顶部。 对于图片中的例子 分析栈 输入 操作 $ \\$1$ $.xxy\\$ $ 移进 $ \\$1x2$ $.xy\\$ $ $1$读入$x$变为$2$，移进 $ \\$1x2x3$ $.y\\$ $ 移进 $ \\$1x2x3y4$ $.\\$ $ $.$到最后了，开始规约 $ \\$1x2x3T5$ $.\\$ $ $y$规约为$T$,$3$输入$T$变为$5$ $ \\$1S6$ $.\\$ $ $xxT$规约为$S$，$1$输入$S$变为$6$，发现状态$6$里$.$后面是$ \\$ $，接受 LR(0)​分析表：就是对状态集的一个描述 s是switch，移进。g是goto，转移状态，r规约，后面的数组不是状态，而是产生式的编号。 比如，状态1可以读入x变为状态2，读入S变为状态6。状态4可以按规则2规约 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:6:1","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#lr0"},{"categories":["compiler"],"content":" LR(0)LR分析算法(移进-规约算法) 运行高效 有现成的工具 YACC，bison 规约：对于一个产生式，从左到右，叫推导或替换，从右到左叫规约 比如 $F\\to n$，由$F$得到$n$叫推导，反过来叫规约 算法基本思想： $$ S\\to E\\\\ E\\to E+T\\ |\\ T\\\\ T\\to T*F\\ |\\ F\\\\ F\\to n $$ $$ 2+3*4\\\\ F+3*4\\\\ T+3*4\\\\ E+3*4\\\\ \\ \\\\ E+F*4\\\\ E+T*4\\\\ \\ \\\\ E+T*F\\\\ E+T\\\\ E\\\\ S $$ 对于上面的文法，如果输入为$2+3*4$ 首先读入$2$，跟产生式右侧比对，看能不能进行规约 $2$规约为$F$，继续规约为$T$，继续规约为$E$，然后就不能继续了 处理后续读入，当输入$3$ $3$规约为$F$，继续规约为$T$，$T$这里不能继续动了 继续读入，当读入$4$ $4$规约为$F$， $T*F$合起来规约为$T$，$E+T$再合起来规约为$E$，最后得到$S$ 分析完成，反之如果收缩不到$S$则判断输入包含语法错误 如果这个分析过程，从下往上看，刚好是最右推导的过程 点记号为了方便标记语法分析器已经读入了多少输入，我们可以引入一个点记号 $.$ 比如：$E+3.*4$，点号左边是已经读入的，右边是剩余的输入 给上面的例子加上点： 把点对齐 生成步骤 项目及分析算法上下文无关文法的 LR(0)项 (LR(0) item)，是在其右边带有区分位置（$.$）的产生式选择 LR(0) 项可作为一个保持有关分析栈和移进-归约分析过程的信息的有穷自动机的状态来使用。 为了能开始分析，我们将底标记 $$$和开始状态$0$压入到栈中，所以分析在开始时的状况表示为： 分析栈 输入 $ \\$\\ 0$ $inputstring\\ \\$ $ 现在假设下一步是将记号$n $移进到栈中并进入到状态$2$ 分析栈 输入 $ \\$\\ 0\\ n\\ 2$ $inputstring\\ \\$ $ 输入的剩余部分 LR(0)分析算法根据当前的DFA状态选择一个动作，这个状态总是出现在栈的顶部。 对于图片中的例子 分析栈 输入 操作 $ \\$1$ $.xxy\\$ $ 移进 $ \\$1x2$ $.xy\\$ $ $1$读入$x$变为$2$，移进 $ \\$1x2x3$ $.y\\$ $ 移进 $ \\$1x2x3y4$ $.\\$ $ $.$到最后了，开始规约 $ \\$1x2x3T5$ $.\\$ $ $y$规约为$T$,$3$输入$T$变为$5$ $ \\$1S6$ $.\\$ $ $xxT$规约为$S$，$1$输入$S$变为$6$，发现状态$6$里$.$后面是$ \\$ $，接受 LR(0)​分析表：就是对状态集的一个描述 s是switch，移进。g是goto，转移状态，r规约，后面的数组不是状态，而是产生式的编号。 比如，状态1可以读入x变为状态2，读入S变为状态6。状态4可以按规则2规约 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:6:1","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#点记号"},{"categories":["compiler"],"content":" LR(0)LR分析算法(移进-规约算法) 运行高效 有现成的工具 YACC，bison 规约：对于一个产生式，从左到右，叫推导或替换，从右到左叫规约 比如 $F\\to n$，由$F$得到$n$叫推导，反过来叫规约 算法基本思想： $$ S\\to E\\\\ E\\to E+T\\ |\\ T\\\\ T\\to T*F\\ |\\ F\\\\ F\\to n $$ $$ 2+3*4\\\\ F+3*4\\\\ T+3*4\\\\ E+3*4\\\\ \\ \\\\ E+F*4\\\\ E+T*4\\\\ \\ \\\\ E+T*F\\\\ E+T\\\\ E\\\\ S $$ 对于上面的文法，如果输入为$2+3*4$ 首先读入$2$，跟产生式右侧比对，看能不能进行规约 $2$规约为$F$，继续规约为$T$，继续规约为$E$，然后就不能继续了 处理后续读入，当输入$3$ $3$规约为$F$，继续规约为$T$，$T$这里不能继续动了 继续读入，当读入$4$ $4$规约为$F$， $T*F$合起来规约为$T$，$E+T$再合起来规约为$E$，最后得到$S$ 分析完成，反之如果收缩不到$S$则判断输入包含语法错误 如果这个分析过程，从下往上看，刚好是最右推导的过程 点记号为了方便标记语法分析器已经读入了多少输入，我们可以引入一个点记号 $.$ 比如：$E+3.*4$，点号左边是已经读入的，右边是剩余的输入 给上面的例子加上点： 把点对齐 生成步骤 项目及分析算法上下文无关文法的 LR(0)项 (LR(0) item)，是在其右边带有区分位置（$.$）的产生式选择 LR(0) 项可作为一个保持有关分析栈和移进-归约分析过程的信息的有穷自动机的状态来使用。 为了能开始分析，我们将底标记 $$$和开始状态$0$压入到栈中，所以分析在开始时的状况表示为： 分析栈 输入 $ \\$\\ 0$ $inputstring\\ \\$ $ 现在假设下一步是将记号$n $移进到栈中并进入到状态$2$ 分析栈 输入 $ \\$\\ 0\\ n\\ 2$ $inputstring\\ \\$ $ 输入的剩余部分 LR(0)分析算法根据当前的DFA状态选择一个动作，这个状态总是出现在栈的顶部。 对于图片中的例子 分析栈 输入 操作 $ \\$1$ $.xxy\\$ $ 移进 $ \\$1x2$ $.xy\\$ $ $1$读入$x$变为$2$，移进 $ \\$1x2x3$ $.y\\$ $ 移进 $ \\$1x2x3y4$ $.\\$ $ $.$到最后了，开始规约 $ \\$1x2x3T5$ $.\\$ $ $y$规约为$T$,$3$输入$T$变为$5$ $ \\$1S6$ $.\\$ $ $xxT$规约为$S$，$1$输入$S$变为$6$，发现状态$6$里$.$后面是$ \\$ $，接受 LR(0)​分析表：就是对状态集的一个描述 s是switch，移进。g是goto，转移状态，r规约，后面的数组不是状态，而是产生式的编号。 比如，状态1可以读入x变为状态2，读入S变为状态6。状态4可以按规则2规约 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:6:1","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#生成步骤"},{"categories":["compiler"],"content":" LR(0)LR分析算法(移进-规约算法) 运行高效 有现成的工具 YACC，bison 规约：对于一个产生式，从左到右，叫推导或替换，从右到左叫规约 比如 $F\\to n$，由$F$得到$n$叫推导，反过来叫规约 算法基本思想： $$ S\\to E\\\\ E\\to E+T\\ |\\ T\\\\ T\\to T*F\\ |\\ F\\\\ F\\to n $$ $$ 2+3*4\\\\ F+3*4\\\\ T+3*4\\\\ E+3*4\\\\ \\ \\\\ E+F*4\\\\ E+T*4\\\\ \\ \\\\ E+T*F\\\\ E+T\\\\ E\\\\ S $$ 对于上面的文法，如果输入为$2+3*4$ 首先读入$2$，跟产生式右侧比对，看能不能进行规约 $2$规约为$F$，继续规约为$T$，继续规约为$E$，然后就不能继续了 处理后续读入，当输入$3$ $3$规约为$F$，继续规约为$T$，$T$这里不能继续动了 继续读入，当读入$4$ $4$规约为$F$， $T*F$合起来规约为$T$，$E+T$再合起来规约为$E$，最后得到$S$ 分析完成，反之如果收缩不到$S$则判断输入包含语法错误 如果这个分析过程，从下往上看，刚好是最右推导的过程 点记号为了方便标记语法分析器已经读入了多少输入，我们可以引入一个点记号 $.$ 比如：$E+3.*4$，点号左边是已经读入的，右边是剩余的输入 给上面的例子加上点： 把点对齐 生成步骤 项目及分析算法上下文无关文法的 LR(0)项 (LR(0) item)，是在其右边带有区分位置（$.$）的产生式选择 LR(0) 项可作为一个保持有关分析栈和移进-归约分析过程的信息的有穷自动机的状态来使用。 为了能开始分析，我们将底标记 $$$和开始状态$0$压入到栈中，所以分析在开始时的状况表示为： 分析栈 输入 $ \\$\\ 0$ $inputstring\\ \\$ $ 现在假设下一步是将记号$n $移进到栈中并进入到状态$2$ 分析栈 输入 $ \\$\\ 0\\ n\\ 2$ $inputstring\\ \\$ $ 输入的剩余部分 LR(0)分析算法根据当前的DFA状态选择一个动作，这个状态总是出现在栈的顶部。 对于图片中的例子 分析栈 输入 操作 $ \\$1$ $.xxy\\$ $ 移进 $ \\$1x2$ $.xy\\$ $ $1$读入$x$变为$2$，移进 $ \\$1x2x3$ $.y\\$ $ 移进 $ \\$1x2x3y4$ $.\\$ $ $.$到最后了，开始规约 $ \\$1x2x3T5$ $.\\$ $ $y$规约为$T$,$3$输入$T$变为$5$ $ \\$1S6$ $.\\$ $ $xxT$规约为$S$，$1$输入$S$变为$6$，发现状态$6$里$.$后面是$ \\$ $，接受 LR(0)​分析表：就是对状态集的一个描述 s是switch，移进。g是goto，转移状态，r规约，后面的数组不是状态，而是产生式的编号。 比如，状态1可以读入x变为状态2，读入S变为状态6。状态4可以按规则2规约 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:6:1","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#项目及分析算法"},{"categories":["compiler"],"content":" SLR(1)对LR(0)算法的特殊改进，区别就是表中没有冲突 表驱动的LR分析器架构 LR(0)缺点 能分析的文法有限 对于每一个形如$X\\to \\alpha.$的项目都会做规约，这样会延迟项目发现的时机 比如把LL(0)里面哪个例子的输入换成xxyx$ 错误定位 由follow集可知$FOLLOW(S)={\\varepsilon}$，只有空串才能跟在$S$后面。 所以，状态3如果规约成$S$，但下一个输入不是$$$，就可以直接报错了 LR(0)分析表中可能包含冲突 状态3是该移进还是规约，可以使用Follow集合来判断，发现$Follow(E)={\\varepsilon}$，因此$E$后面不可能跟$+$号,所以不能能规约 SLR(1)分析算法 和LR(0)分析算法步骤基本相同 仅区别于对规约的处理 使用Follow集，对于状态$i$上的项目$X\\to \\alpha .$ 仅对$y\\in Follow(X)$ 添加规约动作 缺点，仍然可能有冲突，算完follow集发现还是移进规约冲突，LR(1)解决 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:6:2","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#slr1"},{"categories":["compiler"],"content":" SLR(1)对LR(0)算法的特殊改进，区别就是表中没有冲突 表驱动的LR分析器架构 LR(0)缺点 能分析的文法有限 对于每一个形如$X\\to \\alpha.$的项目都会做规约，这样会延迟项目发现的时机 比如把LL(0)里面哪个例子的输入换成xxyx$ 错误定位 由follow集可知$FOLLOW(S)={\\varepsilon}$，只有空串才能跟在$S$后面。 所以，状态3如果规约成$S$，但下一个输入不是$$$，就可以直接报错了 LR(0)分析表中可能包含冲突 状态3是该移进还是规约，可以使用Follow集合来判断，发现$Follow(E)={\\varepsilon}$，因此$E$后面不可能跟$+$号,所以不能能规约 SLR(1)分析算法 和LR(0)分析算法步骤基本相同 仅区别于对规约的处理 使用Follow集，对于状态$i$上的项目$X\\to \\alpha .$ 仅对$y\\in Follow(X)$ 添加规约动作 缺点，仍然可能有冲突，算完follow集发现还是移进规约冲突，LR(1)解决 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:6:2","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#lr0缺点"},{"categories":["compiler"],"content":" SLR(1)对LR(0)算法的特殊改进，区别就是表中没有冲突 表驱动的LR分析器架构 LR(0)缺点 能分析的文法有限 对于每一个形如$X\\to \\alpha.$的项目都会做规约，这样会延迟项目发现的时机 比如把LL(0)里面哪个例子的输入换成xxyx$ 错误定位 由follow集可知$FOLLOW(S)={\\varepsilon}$，只有空串才能跟在$S$后面。 所以，状态3如果规约成$S$，但下一个输入不是$$$，就可以直接报错了 LR(0)分析表中可能包含冲突 状态3是该移进还是规约，可以使用Follow集合来判断，发现$Follow(E)={\\varepsilon}$，因此$E$后面不可能跟$+$号,所以不能能规约 SLR(1)分析算法 和LR(0)分析算法步骤基本相同 仅区别于对规约的处理 使用Follow集，对于状态$i$上的项目$X\\to \\alpha .$ 仅对$y\\in Follow(X)$ 添加规约动作 缺点，仍然可能有冲突，算完follow集发现还是移进规约冲突，LR(1)解决 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:6:2","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#slr1分析算法"},{"categories":["compiler"],"content":" LR(1) LR(1)项目 $[X\\to \\alpha.\\beta,a]$ 的含义是 $\\alpha$在栈顶上 剩余的输入能够匹配$\\beta a$ , 这个 $a$在SLR里就是follow集合里的，这里范围可能更小 当规约$X\\to\\alpha\\beta$ 时，$a$是前看符号 即 $X\\to\\alpha\\beta.,a$ 把$reduce\\ by\\ X\\to\\alpha\\beta$ 填入 $ACTION[s,a]$ 其他和LR(0)相同，仅闭包的计算不同 对于项目$X\\to\\alpha.Y\\beta,a$ 添加$Y\\to.\\gamma,b$ 到项目集，$b\\in FIRST_S(\\beta a)$ ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:6:3","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#lr1"},{"categories":["compiler"],"content":" LR(1) LR(1)项目 $[X\\to \\alpha.\\beta,a]$ 的含义是 $\\alpha$在栈顶上 剩余的输入能够匹配$\\beta a$ , 这个 $a$在SLR里就是follow集合里的，这里范围可能更小 当规约$X\\to\\alpha\\beta$ 时，$a$是前看符号 即 $X\\to\\alpha\\beta.,a$ 把$reduce\\ by\\ X\\to\\alpha\\beta$ 填入 $ACTION[s,a]$ 其他和LR(0)相同，仅闭包的计算不同 对于项目$X\\to\\alpha.Y\\beta,a$ 添加$Y\\to.\\gamma,b$ 到项目集，$b\\in FIRST_S(\\beta a)$ ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:6:3","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#lr1项目"},{"categories":["compiler"],"content":" LALR 把类似的项目集进行合并 需要修改ACTION表和GOTO表，以反映合并的效果 但是合并后可能会出现冲突 如图中状态 5，11 与 8，10 , 可以合并，减小分析表体积 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:6:4","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#lalr"},{"categories":["compiler"],"content":" 对二义性文法的处理 二义性文法无法使用LR分析算法分析 不过有几类二义性文法很容易理解，LR分析器中对他们特殊处理 优先级 结合性 悬空else ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:6:5","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#对二义性文法的处理"},{"categories":["compiler"],"content":" 分析工具语法分析器的实现方法 ","date":"2020-05-17","objectID":"/compiler2-syntax-analysis/:7:0","series":null,"tags":["compiler"],"title":"Compiler2_语法分析","uri":"/compiler2-syntax-analysis/#分析工具"},{"categories":["compiler"],"content":" 词法分析(Lexical Analysis)的任务字符流到记号流 字符流： 和被编译的语言密切相关(ASCII, Unicode, …) 记号流：编译器内部定义的数据结构，编码所识别出的词法单元 ","date":"2020-05-15","objectID":"/compiler1-lexical-analysis/:1:0","series":null,"tags":["compiler"],"title":"Compiler1_词法分析","uri":"/compiler1-lexical-analysis/#词法分析lexical-analysis的任务"},{"categories":["compiler"],"content":" 词法记号的描述与识别 串和语言 字母表：符号的有限集合，例：$\\Sigma={0,1}$ 串：符号的有穷序列，例：$0110,\\varepsilon$ 语言：字母表上的一个串集 ${\\varepsilon,0,00,…},{\\varepsilon },\\varnothing$ 句子：属于语言的串 串的运算 连接(积) ：$xy,s\\varepsilon=\\varepsilon s=s$ 幂：$s^0为\\varepsilon,s^i为s^{i-1}s(i\u003e0)$ 语言的运算 并：$L\\cup M={s|s\\in L或s\\in M}$ 连接：$LM={st|s\\in L且t\\in M}$ 幂：$L^0是{\\varepsilon},L^i是L^{i-1}L$ 闭包：$L^*=L^0\\cup L^1\\cup L^2\\cup…$ 正闭包：$L^+=L^1\\cup L^2\\cup…$ ","date":"2020-05-15","objectID":"/compiler1-lexical-analysis/:2:0","series":null,"tags":["compiler"],"title":"Compiler1_词法分析","uri":"/compiler1-lexical-analysis/#词法记号的描述与识别"},{"categories":["compiler"],"content":" 正则表达式（Regular Expression, RE） 目的是表达编程语言中词法的规则，从而可以有工具来自动生成词法分析器。 正则表达式表示字符串的格式。正则表达式$ r$完全由它所匹配的串集来定义。这个集合称为由正则表达式生成的语言（language generated by the regular expression），写作L(r)。此处的语言只表示“串的集合”，它与程序设计语言并无特殊关系。 该语言首先依赖于适用的字符集，它一般是 A S C I I字符的集合或它的某个子集。有时该集比 ASCII字符的集合更普通一些，此处集合的元素称作符号（symbol）。这个正规符号的集合称作字母表（alphabet）并且常写作希腊符号$\\Sigma$（sigma）。 对正则表达式命名(正规定义) $$ d_1\\to r_1 \\\\ d_2\\to r_2 \\\\ ...\\\\ d_n\\to r_n $$ 各个$d_i$的名字都不同 每个$r_i$都是$\\Sigma\\cup{d_1,d_2…}$上的正则表达式 语法糖，和对正则表达式命名一样，用来简化构造，不是必须的，只是方便表示 $[c_1-c_n]$ 表示$c_1|c_2|…|cn$ $e+$表示一个或多个$e$ $e?$表示零个或一个$e$ $“a*\"$表示$a*$自身，不是$a$的闭包 $e{i,j}$表示$i$到$j$个$e$的连接 $.$ 表示除$‘\\backslash n’$外所有的任意字符 正规定义的例子：$\\Sigma=ASCII$ c语言标识符，以字母下划线开头，后跟0个或多个数字字母下划线 $$ letter\\_ \\to A|B|...|Z|a|b|...|z|\\_ \\\\ digit \\to 0|1|...|9\\\\ id \\to letter\\_(letter\\_|digit)^* $$ ","date":"2020-05-15","objectID":"/compiler1-lexical-analysis/:3:0","series":null,"tags":["compiler"],"title":"Compiler1_词法分析","uri":"/compiler1-lexical-analysis/#正则表达式"},{"categories":["compiler"],"content":" 有穷自动机finite state automata（FA） 有穷自动机，是描述特定类型算法的数学方法。特别地，有穷自动机可用作描述在输入串中识别模式的过程，因此也能用作构造扫描程序。当然有穷自动机与正则表达式之间有着很密切的关系。 以上面对c语言标识符的定义举例子，识别过程可以表示为下图 圆圈1，2是状态（state） 箭头表示状态转换（transition） 状态 1是初始状态（start state），由一个不来自任何地方的箭头指向它表示 状态 2 是接受状态（ accepting state），两个圆圈表示，可能不止一个 ","date":"2020-05-15","objectID":"/compiler1-lexical-analysis/:4:0","series":null,"tags":["compiler"],"title":"Compiler1_词法分析","uri":"/compiler1-lexical-analysis/#有穷自动机"},{"categories":["compiler"],"content":" 非确定有穷自动机(Nondeterministic finite automata, NFA) 给定字符的状态转移是不确定的，是一个集合，这样的自动机叫非确定有穷自动机。如图，状态0接收到字符a后，可以转换到状态1也可以转换到状态0，目标状态是一个集合，所以是不确定的。 ","date":"2020-05-15","objectID":"/compiler1-lexical-analysis/:4:1","series":null,"tags":["compiler"],"title":"Compiler1_词法分析","uri":"/compiler1-lexical-analysis/#非确定有穷自动机"},{"categories":["compiler"],"content":" 确定性有穷自动机(Deterministic finite automata, DFA) 如果状态转移的目标状态都是确定的，而不是一个集合，那么就是确定性有穷状态自动机。c语言标识符哪个例子里的自动机就是确定性的。 词法分析器应该使用DFA，比NFA容易。 ","date":"2020-05-15","objectID":"/compiler1-lexical-analysis/:4:2","series":null,"tags":["compiler"],"title":"Compiler1_词法分析","uri":"/compiler1-lexical-analysis/#确定性有穷自动机"},{"categories":["compiler"],"content":" 从RE到NFA下面将要谈到的结构是 Thompso n结构（Thompson construction），它以其发明者命名。Thompson结构利用$\\varepsilon-$转换将正则表达式的机器片段“粘在一起”以构成与整个表达式相对应的机器。 基于对RE的结构做归纳： 对于基本的RE直接构造 对于复合的RE递归构造 基本正则表达式：基本正则表达式格式 a 或 $\\varepsilon$ ， a 表示字母表中单个字符的匹配，$\\varepsilon $是空串的匹配 并置：我们希望构造一个与正则表达式 $rs$ 等同的 NFA，其中 $r$ 和 $s$ 都是正则表达式。假设已构造好了与 $r$ 和 $s$ 等同的 NFA，可将与 $rs$ 对应的 NFA 构造如下： 在各项中选择：构造一个与 $ r | s $ 相对应的 NFA 重复：构造与 $r^*$ 相对应的 NFA ","date":"2020-05-15","objectID":"/compiler1-lexical-analysis/:5:0","series":null,"tags":["compiler"],"title":"Compiler1_词法分析","uri":"/compiler1-lexical-analysis/#从re到nfa"},{"categories":["compiler"],"content":" 从NFA到DFA子集构造法 对于正则表达式 $a(b|c)^*$ 的NFA $n_0$读入$a$，可以转换到 ${n_1,n_2,n_3,n_4,n_6,n_9}$，记作 $q_1$ (从$n_1$可以继续沿着$\\varepsilon$边走，记录所有可达状态，这个叫$\\varepsilon-$闭包) $q_1$读入$b$，可以到达${n_5,n_8,n_9,n_3,n_4,n_6}$，记作$q_2$ ，($n_4$可以走到$n_5$，然后加上$n_5$的$\\varepsilon-$闭包) $q_1$读入$c$，可以到达${n_7,n_8,n_9,n_3,n_4,n_6}$，记作$q_3$ 然后发现从$q_2$ $q_3$ 都可以读入$b$ $c$，最后得到的集合还是$q_2$ $q_3$ 到这里就完成了，所有包含$n_9$的状态都是接受状态，起始状态$q_0={n_0}$，$n_0$没有$\\varepsilon$边 状态集合的 $\\varepsilon-$ 闭包：我们将单个状态$s$ 的 $\\varepsilon-$ 闭包定义为可由一系列的零个或多个 $\\varepsilon-$ 转换 能达到的状态集合，并将这个集合写作$\\bar{s}$ 。一个状态的 $\\varepsilon-$ 闭包总是包含着该状态本身。 ","date":"2020-05-15","objectID":"/compiler1-lexical-analysis/:6:0","series":null,"tags":["compiler"],"title":"Compiler1_词法分析","uri":"/compiler1-lexical-analysis/#从nfa到dfa"},{"categories":["compiler"],"content":" DFA的最小化因为在扫描程序中，效率是很重要的，如果可能的话，在某种意义上构造的 DFA 应最小。实际上，自动机理论中有一个很重要的结论，即：对于任何给定的 DFA，都有一个含有最少量状态的等价的DFA，而且这个最小状态的 DFA是唯一的 Hopcroft算法：基于等价类的思想 先将所有状态分为两个集合$N$(非接受状态)，$A$(接受状态) 对于每个输入，如果集合内的状态接受这个输入转换后，目标状态不在同一个集合，则需要把这个集合划分开，因为他们对于当前输入不等价(目标不一致) 重复上一条，直到不可划分，合并同一个集合的状态 例1：对于上面$a(b|c)^*$ 的 DFA $N={q_0}$，$A={q_1,q_2,q_3}$ $N$只有一个状态不能划分，$A$里面所有状态转移都落在$A$集合本身里，所以不能划分 合并完只有两个节点了 例2：$f(ee|ie)$的DFA $N={q_0,q_1,q_2,q_4}$，$A={q_3,q_5}$(不可分) $e$可以把集合$N$拆分成两个：${q_0,q_1}$，${q_2,q_4}$，$q_0,q_1$接受$e$后都还在集合$N$，$q_2,q_4$都转换到了$A$(看作他俩等价) ${q_2,q_4}$(不可分)记作$S$，对于${q_0,q_1}$，$e$可以把他划分为：${q_0}$，${q_1}$ (一个目标在原集合，一个在$S$) 全部不可再分，合并 ","date":"2020-05-15","objectID":"/compiler1-lexical-analysis/:7:0","series":null,"tags":["compiler"],"title":"Compiler1_词法分析","uri":"/compiler1-lexical-analysis/#dfa的最小化"},{"categories":["compiler"],"content":"编译原理课程的一系列笔记（大三下学期） ","date":"2020-05-15","objectID":"/compiler0-overview/:0:0","series":null,"tags":["compiler"],"title":"Compiler0_概览","uri":"/compiler0-overview/#"},{"categories":["compiler"],"content":" 编译器结构 主要阶段： 词法分析 语法分析 语义分析 代码生成 前端后端 前端 后端 ","date":"2020-05-15","objectID":"/compiler0-overview/:1:0","series":null,"tags":["compiler"],"title":"Compiler0_概览","uri":"/compiler0-overview/#编译器结构"},{"categories":["compiler"],"content":" 参考 《编译原理及实践》 华保健老师的网易云公开课 陈意云老师的公开课及PPT课件 ","date":"2020-05-15","objectID":"/compiler0-overview/:2:0","series":null,"tags":["compiler"],"title":"Compiler0_概览","uri":"/compiler0-overview/#参考"},{"categories":["program"],"content":" 计算机网络OSI七层协议 实际使用中 TCP/IP 协议族是一个四层协议 应用层 传输层 网络层 数据链路层 ","date":"2020-04-20","objectID":"/computer-networks/:1:0","series":null,"tags":["network"],"title":"计算机网络","uri":"/computer-networks/#计算机网络"},{"categories":["program"],"content":" IP头部 ","date":"2020-04-20","objectID":"/computer-networks/:1:1","series":null,"tags":["network"],"title":"计算机网络","uri":"/computer-networks/#ip头部"},{"categories":["program"],"content":" udp头部 ","date":"2020-04-20","objectID":"/computer-networks/:1:2","series":null,"tags":["network"],"title":"计算机网络","uri":"/computer-networks/#udp头部"},{"categories":["program"],"content":" tcp头部 ","date":"2020-04-20","objectID":"/computer-networks/:1:3","series":null,"tags":["network"],"title":"计算机网络","uri":"/computer-networks/#tcp头部"},{"categories":["program"],"content":" tcp流量控制 ","date":"2020-04-20","objectID":"/computer-networks/:1:4","series":null,"tags":["network"],"title":"计算机网络","uri":"/computer-networks/#tcp流量控制"},{"categories":["program"],"content":" tcp状态 ","date":"2020-04-20","objectID":"/computer-networks/:1:5","series":null,"tags":["network"],"title":"计算机网络","uri":"/computer-networks/#tcp状态"},{"categories":["program"],"content":"x86CPU下AT\u0026T汇编 与AT\u0026T汇编对应的是inter汇编，还有go的plan9 ","date":"2019-12-21","objectID":"/att-assembly-x86/:0:0","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#"},{"categories":["program"],"content":" c语言中基本数据类型得大小（byets） c data type typical 32-bit x86-32 x86-64 char 1 1 1 short 2 2 2 int 4 4 4 long 4 4 8 long long 8 8 8 float 4 4 4 double 8 8 8 long double 8 10/12 10/16 cahr * 4 4 8 at\u0026t汇编语言数据格式 c声明 inter数据类型 汇编代码后缀 大小（byte） char 字节 b 1 short 字 w 2 int 双字 l 4 long 双字 l 4 long long 4 char * 双字 l 4 float 单精度 s 4 double 双精度 l 8 long double 扩展精度 t 10/12 ","date":"2019-12-21","objectID":"/att-assembly-x86/:1:0","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#c语言中基本数据类型得大小byets"},{"categories":["program"],"content":" 数据传送指令（mov）mov? S,D 将S传送到D mov S,D S→D 传送 movb 传送字节 movw 传送字 movl 传送双字 movs S,D 符号扩展(S)→D 高位填充符号位 movsbw 扩展字节为字 movsbl 扩展字节为双字 movswl 扩展字为双字 movz S,D 零扩展(S)→D 高位充零 movzbw 扩展字节为字 movzbl 扩展字节为双字 movzwl 扩展字为双字 pushl S R[%esp]-4 → R[%esp] S→M[R[%esp]] 双字压栈 popl D M[R[%esp]] → D R[%esp]+4→R[%esp] 双字出栈 注意栈是从高地址到低地址增长 允许操作的类型： 立即数：长整数 如：￥0x400,$-533 寄存器：8个通用寄存器之一 %eax %edx %ecx %ebx %esi %edi %esp %ebp 存储器：4个连续字节 不能从内存到内存 ","date":"2019-12-21","objectID":"/att-assembly-x86/:2:0","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#数据传送指令mov"},{"categories":["program"],"content":" 寻址模式D(RB,RI,S) = Mem[Reg[RB]+S*REG[Ri]+D] D:常量（地址偏移量） Rb:基址寄存器：8个通用寄存器之一 RI:索引寄存器：%esp不作为索引寄存器，一般%ebp也不用作这个用途 S:比例因子 1,2,4,or 8 其他变形： (RB,Ri) = Mem[Reg[RB]+REG[Ri] D(RB,Ri) = Mem[Reg[RB]+REG[Ri]+D (RB,Ri,S) = Mem[Reg[RB]+S*REG[Ri] 地址计算指令leal lea 不解引用， leaq (%rsp) %rax == movq %rsp %rax 而不是 movq (%rsp) %rax leal src,dest 计算出来得地址赋给dest ","date":"2019-12-21","objectID":"/att-assembly-x86/:3:0","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#寻址模式"},{"categories":["program"],"content":" 整数计算指令 以寄存器之间操作举例 assembly addl %eax,%ebx # ebx += eax subl %eax,%ebx # ebx -= eax imull %eax,%ebx # ebx *= eax sall %eax,%ebx # ebx \u003c\u003c eax 等价shll sarl %eax,%ebx # ebx \u003e\u003e eax 算术右移 shrl %eax,%ebx # ebx \u003e\u003e eax 逻辑右移 xorl %eax,%ebx # ebx ^= eax andl %eax,%ebx # ebx \u0026= eax orl %eax,%ebx # ebx |= eax incl %eax # eax++ decl %eax # eax-- negl %eax # eax = -eax notl %eax # eax = ~eax 补充 assembly imull S # R[%edx]:R[%eax]=S*R[%eax] 有符号乘，结果64位 mull S # R[%edx]:R[%eax]=S*R[%eax] 无符号乘，结果64位 cltd S # R[%edx]:R[%eax]=符号为扩展[%eax] 转换为8字节 idivl S # R[edx]=R[%edx]:R[%eax]%S # R[eax]=R[%edx]:R[%eax]/S 有符号除法，保存余数和商 divl S # R[edx]=R[%edx]:R[%eax]%S # R[eax]=R[%edx]:R[%eax]/S 无符号除法，保存余数和商 ","date":"2019-12-21","objectID":"/att-assembly-x86/:4:0","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#整数计算指令"},{"categories":["program"],"content":" x86-64的通用寄存器 name name [%rax [%eax] ] [%r8 [%r8d] ] [%rdx [%edx] ] [%r9 [%r9d] ] [%rcx [%ecx] ] [%r10 [%r10d] ] [%rbx [%ebx] ] [%r11 [%r11d] ] [%rsi [%esi] ] [%r12 [%r12d] ] [%rdi [%edi] ] [%r13 [%r13d] ] [%rsp [%esp] ] [%r14 [%r14d] ] [%rbp [%ebp] ] [%r15 [%r15d] ] 兼容32位下的寄存器（e开头）,仍然可以使用，%eax也兼容16位下ah,al寄存器 64位传参：少于等于6个时放入寄存器rdi,rsi,rdx,rcx,r8,r9。多出的放入栈中 32位传参：放在栈中 ","date":"2019-12-21","objectID":"/att-assembly-x86/:5:0","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#x86-64的通用寄存器"},{"categories":["program"],"content":" 条件码CF:carry flag SF:sign flag ZF:zero flag OF:overflow flag 条件码由算术指令隐含设置addl src,edst 如果产生进位，CF被设置，可以检测无符号数运算溢出 结果为0，ZF被设置 结果小于0，SF 补码运算溢出，OF，可以看作符号数运算溢出（两个大于0的数相加为负） 比较指令cmpl src2,src1 cmpl b,a 类似 a-b 相等ZF置1 结果小于0,SF置1 溢出OF置1（a\u003e0\u0026\u0026b\u003c0\u0026\u0026(a-b)\u003c0）||（a\u003c0\u0026\u0026b\u003e0\u0026\u0026(a-b)\u003e0） 测试指令testl src2,src1 testl b,a 类似a\u0026b 当为0，ZF置1 当\u003c0，SF置1 test使 CF,OF 置0 ","date":"2019-12-21","objectID":"/att-assembly-x86/:6:0","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#条件码"},{"categories":["program"],"content":" 读取条件码 setX指令 读取当前条件码（组合）到目的字节寄存器 setX condition description sete ZF equal/zero setne ~ZF not equal/not zero sets SF Negative setns ~SF nonnegative setg ~(SF^OF)\u0026~ZF greater(signed) setge ~(SF^OF) greater or equal(signed) setl (SF^OF) less(signed) setle (SF^OF)|ZF less or equal(signed) seta ~CF\u0026~ZF above(unsigned) setb CF below(unsigned) cpp //a.c int gt(int x,int y){ return x\u003ey; } /* gcc -S -m32 a.c -o a.asm32 摘要 movl 8(%ebp), %eax #get x cmpl 12(%ebp), %eax #x-y setg %al #取标记 movzbl %al, %eax #结果放到eax */ //-fno-omit-frame-pointer 不优化指针框架 ","date":"2019-12-21","objectID":"/att-assembly-x86/:6:1","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#读取条件码"},{"categories":["program"],"content":" 跳转指令 依赖当前条件码选择下一条执行语句 jX condition description jmp 1 unconditional je ZF equal/zero jne ~ZF not equal/not zero js SF negative jns ~SF nonnegative jg ~(SF^OF)\u0026~ZF greater(signed) jge ~(SF^OF) greater or equal(signed) jl (SF^OF) less(signed) jle (SF^OF)|ZF less or equal(signed) ja ~CF\u0026~ZF above(unsigned) jb CF below(unsigned) cpp //a.cpp int absdiff(int x,int y){ int res; if(x\u003ey){ res = x-y; }else{ res = y-x; } return res; } /* gcc -S -m32 -fno-omit-frame-pointer a.c -o a.asm32 movl 8(%ebp), %eax cmpl 12(%ebp), %eax jle .L2 movl 8(%ebp), %eax subl 12(%ebp), %eax movl %eax, -4(%ebp) jmp .L3 .L2: movl 12(%ebp), %eax subl 8(%ebp), %eax movl %eax, -4(%ebp) .L3: movl -4(%ebp), %eax leave ret */ x86-64 下条件传送指令 比较新的机器有这个指令（比如i686） cmovC src,dest 如果C成立，将数据从src移动到dest ","date":"2019-12-21","objectID":"/att-assembly-x86/:6:2","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#跳转指令"},{"categories":["program"],"content":" switch的汇编表示","date":"2019-12-21","objectID":"/att-assembly-x86/:7:0","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#switch的汇编表示"},{"categories":["program"],"content":" 表结构基地址是 .L62 通过jump table来进行跳转 取值比较稀疏通过二叉树表示 ","date":"2019-12-21","objectID":"/att-assembly-x86/:7:1","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#表结构"},{"categories":["program"],"content":" 程序运行栈%esp存储栈顶地址,栈网低地址延伸 pushl src 从src取得操作数 %esp=%esp-4，32位汇编下 数据写入栈顶地址%esp popl dest 读取栈顶%esp数据 %esp=%esp+4 数据写入dest ","date":"2019-12-21","objectID":"/att-assembly-x86/:8:0","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#程序运行栈"},{"categories":["program"],"content":" 过程调用指令：call call label 将返回地址压入栈，跳转至label 返回地址是指：call指令的下一条指令地址 ret 跳转至栈顶的返回地址 ","date":"2019-12-21","objectID":"/att-assembly-x86/:8:1","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#过程调用指令call"},{"categories":["program"],"content":" 栈帧：%ebp 存储的内容，自”顶“（栈顶）向下 子过程参数 局部变量，因为寄存器个数有限 被保存的寄存器值 父过程的栈帧起始地址（old %ebp） 栈帧的分配与释放 进入过程后先分配栈帧空间 过程返回时释放 %ebp指向当前栈帧起始地址，与%esp永远指向当前活跃栈帧的头尾 c void swap(int *xp, int *yp) { int t0 = *xp; int t1 = *yp; *xp = t1; *yp = t0; } int zip1 = 15213; int zip2 = 91125; void call_swap() { swap(\u0026zip1, \u0026zip2); } assembly call_swap: #... pushl $zip2 #传参,从右往左压栈，变量加$表示取地址 pushl $zip1 call swap /*栈 ... \u003c- %ebp \u0026zip2 \u0026zip1 rtn adr \u003c- %esp */ swap: pushl %ebp #记录 old ebp movl %esp,%ebp #设置自己的ebp pushl %ebx #存一下寄存器信息 movl 12(%ebp),%ecx movl 8(%ebp),%edx movl (%ecx),%eax movl (%edx),%ebx movl %eax,(%edx) movl %ebx,(%ecx) movl -4(%ebp),%ebx #恢复%ebx原来的值 movl %ebp,%esp #esp重置到ebp位置 popl %ebp #esp指向 rtn adr 返回地址 ret #根据esp返回 #set up /*栈 ... \u003c- %ebp +12 yp +8 xp +4 rtn adr ebp old %ebp #pushl %ebp \u003c- %ebp #movl %esp,%ebp -4 old %ebx #pushl %ebx */ #为什么我们只保存了old ebx？ ","date":"2019-12-21","objectID":"/att-assembly-x86/:8:2","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#栈帧ebp"},{"categories":["program"],"content":" 寄存器使用惯例 这是一个软件层的约定 使用惯例—通用寄存器分为两类 调用者负责保存 %eax %edx %ecx %eax 用于保存过程返回值 被调用者负责保存 %ebx %esi %edi %ebp其实也是 特殊 %ebp %esp ","date":"2019-12-21","objectID":"/att-assembly-x86/:8:3","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#寄存器使用惯例"},{"categories":["program"],"content":" x86-64过程调用与运行栈过程参数（不超过6个）通过寄存器传参，大于部分使用栈传 当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。 当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。 所有对于栈帧内容的访问都是基于%rsp，%rbp完全当作通用寄存器 x86-64下的栈帧有一些不用操作特性 一次性分配整个帧 将%rsp减去某个值（栈帧的大小） 对于栈帧内容的访问都是基于%rsp完成 可以延迟分配,可以访问(%esp)128字节的栈上空间 释放简单 %rsp直接加上某个值 ","date":"2019-12-21","objectID":"/att-assembly-x86/:9:0","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#x86-64过程调用与运行栈"},{"categories":["program"],"content":" 数组的存储T A[L]; 基本数据类型：T 数组长度：L 连续存储在大小为L*sizeof(T)字节的空间内 int a[5]; 寄存器edx赋值为数组的起始地址，寄存器%eax赋值为下标，对应的元素地址为edx+4*eax (%edx,%eax,4) cpp // a[5]; void zincr_p(int * z){ int *zend = z+5; do{ (*z)++; z++; }while(z!=zend); } assembly //edx = z movl $0,%eax #i=0; .L8: #loop addl $1,(%edx,%eax) # *(z+i)++ 注意汇编里面指针加都是加1 addl $4,%eax # i+=4 cmpl $20,%eax # compare i:20 jne .L8 # if != ,goto loop ","date":"2019-12-21","objectID":"/att-assembly-x86/:10:0","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#数组的存储"},{"categories":["program"],"content":" 8086汇编与c语言","date":"2019-12-21","objectID":"/att-assembly-x86/:11:0","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#8086汇编与c语言"},{"categories":["program"],"content":" 结构struct cpp struct rec{ int i; int a[3]; int *p; }; // 连续分配的内存区域，内部元素通过名字访问，元素类型可以不同 //访问 void set_i(struct rec *r,int val){ r-\u003ei = val; } int * find_a(struct rec *r,int idx){ return \u0026r-\u003ea[idx]; } 相应汇编代码 assembly # set_i # %eax = val # %edx = r movl %eax,(%edx) #mem[r]=val #find_a # %ecx = idx # %edx = r leal 0(,%ecx,4),%eax # 4*idx leal 4(%eax,%edx),eax # r+4*idx+4 r+4是a[0],r+4+idx*4是a[idx] ","date":"2019-12-21","objectID":"/att-assembly-x86/:11:1","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#结构struct"},{"categories":["program"],"content":" 数据存储位置对齐对齐的一般原则 已知某种基本类型的大小为k字节 那么，其存储地址必须是k的整数倍 x86-64的对齐要求基本上就是这样 但是32位系统，linux与windows系统的要求都略有不同 为何需要对齐 计算机访问内存一般是以内存块为单位的，块的大小是地址对齐的，如4，8，16字节对齐等 如果数据访问地址跨越“块”边界会引起额外的内存访问 编译器的工作 在结构的各个元素间插入额外空间来满足不同元素的对齐要求 x86-32下不同元素的对齐要求 基本数据类型 1 byte （char） 无要求 2 byte （short）2字节对齐 地址最后一位为0 4 byte （int,float,char *） 4字节对齐 地址后两位为0 8 byte （double） win（及大多数） 8字节对齐，3位0，linux 四字节对齐，2位0 12 byte （long double） win，linux 四字节对齐 两位0 x86-64下不同元素的对齐要求 基本数据类型 1，2，4 byte同32位一样 8 bytes (double ,char *) win\u0026linux 8字节对齐，地址后三位为0 16 bytes （long double）linux 8位对齐 结构的存储对齐要求 必须满足结构中各个元素的对齐要求 结构自身的对齐要求等于其各个元素中对齐要求最高的那个，设为k字节 结构的起始地址与结构长度必须是k的整数倍 ","date":"2019-12-21","objectID":"/att-assembly-x86/:11:2","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#数据存储位置对齐"},{"categories":["program"],"content":" 80x86-32汇编编程","date":"2019-12-21","objectID":"/att-assembly-x86/:12:0","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#80x86-32汇编编程"},{"categories":["program"],"content":" hello world c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(){ printf(\"hellow world\\n\"); exit(0); return 0; } // gcc -S -O2 helloworld.c 这个是64位的汇编，我加-m32找不见头文件 assembly .file \"helloworld.c\" .text .section .rodata .LC0: .string \"hello world\" .text .globl main .type main, @function main: .LFB5: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 leaq .LC0(%rip), %rdi call puts@PLT movl $0, %edi call exit@PLT .cfi_endproc .LFE5: .size main, .-main .ident \"GCC: (Ubuntu 7.3.0-27ubuntu1~18.04) 7.3.0\" .section .note.GNU-stack,\"\",@progbits ","date":"2019-12-21","objectID":"/att-assembly-x86/:12:1","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#hello-world"},{"categories":["program"],"content":" 汇编指示 汇编代码中以.开头的都是汇编指示（Directives），如.file，.def，.text等，用以指导汇编器如何进行汇编。其中.file .def均用于调试（可以将其忽略） 以:结尾的字符串，如_main: 是用以表示变量或函数地址的符号（Symbol） 其他均为汇编指令 assembly .globl _main #指示汇编器表示符号_main是全局的 #没有.globl标明的都是局部的 .text #代码段 .p2align 4,,15 #指定下一行代码的对齐方式，参数1：按2的多少次幂对齐 #参数2：对齐是额外空间用什么数据填充 #参数3：最多允许额外填充多少字节 .section .rodata #只读数据段 .LC0: .ascii \"hello world\\12\\0\" #.ascii是类型 文本字符串 #.asciz 以空字符结尾的字符串 #.byte 字节值 #.double .float .single .int .long .octa .quad .short #双精度 单精度 4byte 16 8 16 ages: #一行可以声明多个值 .int 20,10,30,40 .section .bss #未初始化代码段 .lcomm buffer,1000 #声明未初始化本地内存区域 symbol,size .type power,@function #告诉linker power是一个函数 #.equ 用于把常量设置为可以在程序中使用的symbol .equ factor,3 .equ LINUX_SYS_CALL,0x80 ","date":"2019-12-21","objectID":"/att-assembly-x86/:12:2","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#汇编指示"},{"categories":["program"],"content":" linux汇编命令\u0026系统调用as -o my-object-file.o helloworld.s -gstabs 产生带调试信息的object文件 64位环境下使用32位汇编，加参数：–32 ld -o my-exe-file my-object-file.o 可以有多个.o文件 64位下生成32位可执行程序加参数：-m elf_i386 如果有什么找不见：sudo apt-get install g++-multilib helloworld程序 assembly .data #数据段 msg: .ascii \"hellow world\\n\" len = .-msg # . 表示当前地址 .text .globl _start #汇编程序入口 _start: movl $len,%edx movl $msg,%ecx movl $1,%ebx #系统输出 movl $4,%eax int $0x80 movl $0,%ebx #程序退出 movl $1,%eax int $0x80 x86-linux 下的系统调用是通过中断指令（int 0X80）来实现的。 在执行int $0x80指令时 寄存器eax中存放的是系统调用的功能号，而传给系统调用的参数则必须按顺序放到寄存器ebx,ecx,edx,esi,edi中 系统调用完成之后，返回值可以在eax中获得 当系统调用需要参数大于5个，功能号保存在eax，全部参数依次存在一块连续内存中，同时在寄存器ebx中保存指向该内存区域的指针 查看系统调用功能号列表：locate unistd_32或locate unistd_32 或者http://codelab.shiyanlou.com/xref/linux-3.18.6/arch/x86/syscalls/syscall_32.tbl http://syscalls.kernelgrok.com/ 处理命令行参数: 将参数按行输出 assembly .text .globl _start _start: popl %ecx #argc vnext: popl %ecx #argv test %ecx,%ecx #空指针表示结束 jz exit movl %ecx,%ebx #argv起始指针 xorl %edx,%edx strlen: movb (%ebx),%al inc %edx #edx++ inc %ebx #ebx++ test %al,%al jnz strlen movb $10,-1(%ebx) #10是换行符 movl $4,%eax #系统调用sys_write movl $1,%ebx #参数1：fd 参数2：ecx字符串开始地址 参数3：edx 字符串长度 int $0x80 jmp vnext exit: movl $1,%eax #系统调用号sys_exit xorl %ebx,%ebx #参数1：退出代码 int $0x80 调用libc库函数:打印cpu信息 assembly .section .data output: .asciz \"The processor vendor id is '%s'\\n\" #.asciz 自动末尾加0 .section .bss #可读可写且没有初始化的数据区 .lcomm buffer,12 .section .text .globl _start _start: movl $0,%eax cpuid #参数放入eax，获取cpu特定信息，填0时，厂商id字符串反回到ebx,ecx,edx #一共12个字符 movl $buffer,%edi #buffer地址放入edi movl %ebx,(%edi) movl %edx,4(%edi) movl %ecx,8(%edi) #cpu信息放入buffer push $buffer #printf的参数，从右往左压栈 push $output call printf #libc addl $8,%esp #栈中弹出参数 push $0 call exit # ld -lc dynamic-linker /lib/ld-linux.so.2 -o cpuid.exe cpuid.o go p88 ","date":"2019-12-21","objectID":"/att-assembly-x86/:12:3","series":null,"tags":["assembly"],"title":"AT\u0026T汇编-x86","uri":"/att-assembly-x86/#linux汇编命令系统调用"},{"categories":["program"],"content":" linux系统编程","date":"2019-09-26","objectID":"/linux-system-programming/:0:0","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#linux系统编程"},{"categories":["program"],"content":" 1 文件I/O 文件描述符，文件描述符是一个非负整数。 0标准输入，1标准输出，2标准错误 STDIN_FILENO，STDOUT_FILENO，STDERR_FILENO 普通文件的文件描述符，在内核空间是这样的： ","date":"2019-09-26","objectID":"/linux-system-programming/:1:0","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#1-文件io"},{"categories":["program"],"content":" 1.1 函数open和openat c #include \u003cfcntl.h\u003e int open(const char *path, int oflag,.../* mode_t mode */); int openat(int fd,const char *path, int oflag,.../* mode_t mode*/); //成功返回文件描述符，出错返回-1 fd参数把open和openat区分开 1 path参数指定的是绝对路径名，fd参数被忽略，两函数没有区别 2 path参数指定的是相对路径名，fd参数指出了相对路径名在文件系统中的开始地址。fd是通过打开相对路径名所在的目录来获取的 2 path参数指定的是相对路径名，fd参数具有特殊值AT_FDCWD，在这种情况下路径名在当前工作目录中获取 oflag选项可用选项 宏 作用 备注 O_RDONLY 只读打开 O_WRONLY 只写打开 O_RDWR 读写打开 大多数实现将前三种定义成0，1，2 O_EXEC 只执行打开 O_APPEND 追加模式 在每次写入操作执行之前，自动将文件指针定位到文件末尾 O_CLOEXEC 把FD_CLOEXEC常量设置为文件描述符标志 O_CREAT 若文件不存在则创建 需要给定第三个参数，设置文件权限，最终权限受umask影响 O_DIRECTORY 如果path不是目录则出错 O_EXCL 如果同时指定了O_CREAT，而文件已存在，则出错 O_NOCTTY 如果path引用的是终端设备，则不将该终端分配作为此进程的控制终端 O_NOFOLLOW 如果path是一个符号链接，则出错 O_NONBLOCK 如果path引用的是个FIFO，一个块或字符文件特殊文件，设置I/O操作为非阻塞 O_SYNC 使每次write等待物理I/O操作完成，包括write操作引起的文件属性更新所需的I/O O_TRUNC 如果此文件存在，且以写属性打开，将其长度截断为0 对FIFO和终端文件不管用 O_TTY_INIT 打开一个未打开的终端设备，设置非标准termios参数，使其符合singel unix specification ","date":"2019-09-26","objectID":"/linux-system-programming/:1:1","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#11-函数open和openat"},{"categories":["program"],"content":" 1.2 函数creat c #include \u003cfcntl.h\u003e int creat(const char *path, mode_t mode); //成功返回只写打开的文件描述符，出错返回-1 //等效于open(path, O_WRONLY|O_CREAT|O_TRUNC, mode); //不怎么用了，用open都可以实现，且更灵活 ","date":"2019-09-26","objectID":"/linux-system-programming/:1:2","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#12-函数creat"},{"categories":["program"],"content":" 1.3 函数lseek 每打开一个文件都有一个与其关联的“当前文件偏移量”（current file offset） c #include \u003cunistd.h\u003e off_t lseek(int fd, off_t offset, int whence); //成功返回新的文件偏移量，出错返回-1 对管道，FIFO或网络套接字使用，返回-1，设置errno为ESPIPE whence 参数取值 /wens/ 根源 SEEK_SET ，将该文件偏移量设置为距文件开始处offset个字节 SEEK_CUR ，将该文件偏移量设置为当前值+offset，offset可正可负 SEEK_END ，将该文件偏移量设置为文件长度+offset，offset可正可负 ","date":"2019-09-26","objectID":"/linux-system-programming/:1:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#13-函数lseek"},{"categories":["program"],"content":" 1.4 函数read c #include \u003cunistd.h\u003e ssize_t read(int fd, void *buf, size_t nbytes); //返回实际读到的字节数，出错返回-1 当文件指针已位于文件结尾，返回0，在套接字上读到0说明另一端关闭 返回-1时会设置errno 错误值 含义 EAGAIN 使用O_NONBLOCK标志 指定了非阻塞输入输出，但当前没有数据可读。 EBADF fd不是一个合法的文件描述符，或者不是为了读操作而打开。 EINTR 在读取到数据以前调用被信号中断。 EINVAL fd所指向的对象不合适读，或者是文件打开时指定了O_DIRECT标志。 EISDIR fd指向一个目录。 ","date":"2019-09-26","objectID":"/linux-system-programming/:1:4","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#14-函数read"},{"categories":["program"],"content":" 1.5 函数write c #include \u003cunistd.h\u003e ssize_t write(int fd, const void *buf, size_t nbytes); //返回写入字节数，出错返回-1 错误值 错误值 含义 EBADF fd不是一个合法的文件描述符，或者不是为写 操作而打开。 EINTR 系统调用在写入任何数据之前调用被信号所中断。 EINVAL fd所有指向的对象不合适写，或者是文件打开时指定了O_DIRECT标志。 ENOSPC fd指向的文件所在的设备无可用空间。 EPIPE fd连接到一个管道，或者套接字的读方向一端已经关闭。 ","date":"2019-09-26","objectID":"/linux-system-programming/:1:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#15-函数write"},{"categories":["program"],"content":" 1.6 函数dup和dup2 两函数都复制一个现有的文件描述符 c #include \u003cunistd.h\u003e int dup(int fd); int dup2(int fd, ing fd2); //成功返回新的文件描述符，出错返回-1 dup返回到新描述符一定是当前可用的描述符中最小值 dup2可以用fd2指定新描述符的值，如果fd2已打开，则先将其关闭。 若fd=fd2,返回fd2但不执行关闭动作。否则fd2的FD_CLOEXEC标志就被清除，这样fd2在进程调用exec时是打开状态 ","date":"2019-09-26","objectID":"/linux-system-programming/:1:6","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#16-函数dup和dup2"},{"categories":["program"],"content":" 1.7 函数close 可调用close函数关闭一个打开文件 c #include \u003cunistd.h\u003e int close(int fd); //成功返回0，否则返回-1 当关闭一个文件还会释放该进程加在该文件上的所有记录锁。 当进程终止时，内核自动关闭它打开的所有文件，很多程序利用这一点不显式调用。 ","date":"2019-09-26","objectID":"/linux-system-programming/:1:7","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#17-函数close"},{"categories":["program"],"content":" 1.8 函数 sync fsync fdatasync 将缓冲区内容同步到磁盘 c #include \u003cunistd.h\u003e int fsync(int fd); int fdatasync(int fd); //成功返回0，否则返回-1 void sync(void); sync 只是将所有修改过的块缓冲区写入队列，就返回，不等待实际磁盘操作 fsync只对文件描述符指定的一个文件起作用，并等待磁盘操作结束才返回 fdatasync类似发fsync，但它只影响文件的数据部分，fsync同时更新属性部分 ","date":"2019-09-26","objectID":"/linux-system-programming/:1:8","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#18-函数-sync-fsync-fdatasync"},{"categories":["program"],"content":" 1.9 函数 fcntl fcntl 函数可以改变已经打开文件的属性 c #include \u003cfcntl.h\u003e int fcntl(int fd, int cmd, .../*int arg*/); //返回值：成功则依赖于cmd，出错返回-1 cmd 参数 功能 F_DUPFD 复制文件描述符fd，新文件描述符作为返回值，它是尚未打开的各描述符中大于等于第三个参数值中最小的值。新描述符有他自己的一套标志，其中FD_CLOEXEC被清除， F_DUPFD_CLOEXEC 同上，但D_CLOEXEC被设置 F_GETFD 对应于fd的文件描述符标志作为函数返回值。 F_SETFD 对于fd设置文件描述符标志，新标志按第三个参数传递(如FD_CLOSEXEC) F_GETFL 对应于fd的文件状态标志作为函数返回值，open函数下面有列出 F_SETFL 设置状态标志，可更改的有：O_APPEND,O_NONBLOCK,O_SYNC等 F_GETOWN 获取当前SIGIO和SIGURG信号（两种异步io信号）的进程id或进程组id F_SETOWN 设置接收当前SIGIO和SIGURG信号的进程id或组id，正的arg指定进程id，负的arg指定组id ","date":"2019-09-26","objectID":"/linux-system-programming/:1:9","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#19-函数-fcntl"},{"categories":["program"],"content":" 1.10 函数 ioctl 不能用其他函数表示的i/o操作通常都可以用这个 每个设备驱动文件可以定义他自己专用的一组ioctl命令，系统则为不同驱动提供通用ioctl命令 c #include \u003csys/ioctl.h\u003e int ioctl(int fd, int request, ...); //出错返回-1，成功返回其他值 ","date":"2019-09-26","objectID":"/linux-system-programming/:1:10","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#110-函数-ioctl"},{"categories":["program"],"content":" 1.11 /dev/fd 较新的系统都有名为/dev/fd的目录，目录下是名为0，1，2的文件 打开/dev/fd/n等效于复制描述符n，如fd = open(\"/dev/fd/0\",mode)等效fd = dup(0) ","date":"2019-09-26","objectID":"/linux-system-programming/:1:11","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#111-devfd"},{"categories":["program"],"content":" 2 C 标准I/O","date":"2019-09-26","objectID":"/linux-system-programming/:2:0","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#2-c-标准io"},{"categories":["program"],"content":" 2.1 文件指针 标准I/O并不直接操作文件描述符，而是通过文件指针（file pointer）。文件指针映射到一个文件描述符。文件指针类型为FILE，定义在头文件\u003cstdio.h\u003e 在标准I/O中，一个打开的文件叫做“流”（stream）。 标准输入 输出 错误的流通过预定义文件指针 stdin，stdout，stderr加以引用 ","date":"2019-09-26","objectID":"/linux-system-programming/:2:1","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#21-文件指针"},{"categories":["program"],"content":" 2.2 打开文件 文件通过 fopen()打开以提供读写操作：打开文件并为它关联一个新的流 c #include \u003cstdio.h\u003e FILE* fopen(const char * path, const char * mode); //成功返回文件指针，否则返回NULL mode mode 说明 r 打开文件用来读，流定位在文件开始处 r+ 打开文件用来读写，流定位在文件开始处 w 打开文件用来写，如果文件存在，文件会被清空。如果不存在，会被创建。流定位在文件开始。 a d打开文件用来追加模式的写入。如果文件不存在它会被创建。流被设置在文件的末尾，所有写入都会接在文件后。 a+ 打开文件用来追加模式的读写。如果文件不存在它会被创建。流被设置在文件的末尾，所有写入都会接在文件后。 b 表示二进制形式，这个值在linux下被忽略，因为文本文件和二进制文件都一视同仁 通过文件描述符打开文件 函数fdopen()将一个已经打开的文件描述符转换成流 c #include \u003cstdio.h\u003e FILE* fdopen(int fd, const char * mode); 可能模式与上面一样，但必须和原来打开文件描述符的模式匹配。可以指定w，w+，但是他们不会截断文件。流的位置设置在文件描述符指向的文件位置。可以但不要在打开流的情况下直接操作描述符。关闭流也会关闭描述符。 ","date":"2019-09-26","objectID":"/linux-system-programming/:2:2","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#22-打开文件"},{"categories":["program"],"content":" 2.3 关闭流 fclose()函数关闭一个给定的流 cc #include \u003cstdio.h\u003e int fclose(FILE * stream); //成功返回0，失败返回EOF（-1），设置errno fcloseall()关闭所有和当前程序关联的流，包括标准输入，输出，错误 c #include \u003cstdio.h\u003e int fcloseall(void); //该函数始终返回0；该函数是linux特有的 ","date":"2019-09-26","objectID":"/linux-system-programming/:2:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#23-关闭流"},{"categories":["program"],"content":" 2.3 从流中读取数据 单字节读取 c #include \u003cstdio.h\u003e int fgetc(FILE * stream); //读取一个字符，并把该无符号字符强转成int返回。文件结尾，错误都返回EOF（-1） 把字符放回流中 允许你偷窥流，如果不需要，可以把它放回 c #include \u003cstdio.h\u003e int ungetc(int c,FILE * stream); //把c强转为无符号字符，放回流中，成功返回c，否则返回EOF //如果使用了一次定位函数，所有推回的字符被丢弃 按行读取 c #include \u003cstdio.h\u003e char * fgets(char *str, int size, FILE * stream); //从流中读取最多size-1个字节数据，遇到文件尾或换行时读入结束，如果读到‘\\n’ //也放入str，最后把空字符'\\0'放到str结尾。成功返回str，失败返回NULL 读取二进制文件 c #include \u003cstdio.h\u003e size_t fread(void *buf, size_t size, size_t nr, FILE* stream); //从流中读取nr个数据，每个数据大小为size，放入buf中 //实际读入的个数被返回（注意不是字节数） //返回小于nr的值时读取失败或文件结束，用ferror()和feof()判断 ","date":"2019-09-26","objectID":"/linux-system-programming/:2:4","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#23-从流中读取数据"},{"categories":["program"],"content":" 2.4 向流中写数据 c #include \u003cstdio.h\u003e //写入单个字符 int fput(int c, FILE * stream); //成功返回c,否则返回EOF //写入字符串 int fputs(const char *str, FILE *stream); //将str中'\\0'前部分写入stream指向的流中，成功返回非负整数，失败EOF //写入二进制数据 size_t fwrite(void *buf, size_t size, size_t nr, FILE *stream); //把buf指向的nr个元素（每个元素大小为size）写入流，返回实际写入个数，小于nr出错 ","date":"2019-09-26","objectID":"/linux-system-programming/:2:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#24-向流中写数据"},{"categories":["program"],"content":" 2.5 定位/清洗流 c #include \u003cstdio.h\u003e int fseek(FILE *stream, long offset, int whence); //成功返回0，清空文件结束标志，取消ungetc()操作，错误返回-1 SEEK_SET ，将该文件偏移量设置为距文件开始处offset个字节 SEEK_CUR ，将该文件偏移量设置为当前值+offset，offset可正可负 SEEK_END ，将该文件偏移量设置为文件长度+offset，offset可正可负 c //将流位置设置到pos处 int fsetpos(FILE *stream, const fpos_t *pos); //成功返回0，否则返回-1 //将当前位置填入pos int fegtpos(FILE *stream, fpos_t *pos); void rewind(FILE *stream); //等于 fseek(stream,0,SEEK_SET); 位置重置为初始位置 //返回当前流位置 long fetll(FILE *stream); //错误返回-1 //清洗一个流，流中数据立即刷新到内核中 int fflush(FILE *stream); ","date":"2019-09-26","objectID":"/linux-system-programming/:2:6","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#25-定位清洗流"},{"categories":["program"],"content":" 2.6 错误和文件结束 c #include \u003cstdio.h\u003e //测试流上是否设置了错误标志 int ferror(FILE *stream); //如果有错误标记，返回非0，否则返回0 //测试文件结尾标记是否被设置 int feof(FILE *stream); //如果有文件结束标记，返回非0，否则返回0 //清空错误和结尾标记 void cleareer(FILE *stream); ","date":"2019-09-26","objectID":"/linux-system-programming/:2:7","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#26-错误和文件结束"},{"categories":["program"],"content":" 2.7 控制缓冲和关联描述符 提供三种用户缓冲，不缓冲，行缓冲（标准输出默认），块缓冲（文件操作默认） c #include \u003cstdio.h\u003e void setbuf(FILE *stream, char *buf); //buf为NULL是关闭缓冲，否则大小由常量BUFSIZ决定 int setvbuf(FILE *stream, char *buf, int mode, size_t size); //必须在流打开后，任何操作之前调用 //成功返回0，否则返回非0 mode _IONBF 无缓冲 _IOLBF 行缓冲 _IOFBUF 块缓冲 _IONBF情况下buf和size被忽略 buf可以指向一个size字节大小的缓冲空间，如果buf为NULL，则由glibc自动分配 获得关联文件的描述符 c #include \u003cstdio.h\u003e int fileno(FILE *stream); //成功返回和流关联的文件描述符，否则返回-1 ","date":"2019-09-26","objectID":"/linux-system-programming/:2:8","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#27-控制缓冲和关联描述符"},{"categories":["program"],"content":" 2.8 线程安全 单个I/O操作是原子的，但有时需要加锁一组操作 又时有不需要单个I/O的锁机制 手动文件加锁 c #include \u003cstdio.h\u003e void flockfile(FILE *stream); //等待流解锁 并 获得锁 然后返回 vodi funlockfile(FILE *stream); //解锁 //非阻塞加锁版本 int ftrylockfile(FILE *stream); //没有拿到锁返回非零，拿到了返回0 不加锁的流操作，linux提供一系列函数 c #include \u003cstdio.h\u003e int getc_unlocked(FILE *stream); int getchar_unlocked(void); int putc_unlocked(int c, FILE *stream); int putchar_unlocked(int c); void clearerr_unlocked(FILE *stream); int feof_unlocked(FILE *stream); int ferror_unlocked(FILE *stream); int fileno_unlocked(FILE *stream); int fflush_unlocked(FILE *stream); int fgetc_unlocked(FILE *stream); int fputc_unlocked(int c, FILE *stream); size_t fread_unlocked(void *ptr, size_t size, size_t n, FILE *stream); size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream); char *fgets_unlocked(char *s, int n, FILE *stream); int fputs_unlocked(const char *s, FILE *stream); ... ","date":"2019-09-26","objectID":"/linux-system-programming/:2:9","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#28-线程安全"},{"categories":["program"],"content":" 3 高级IO","date":"2019-09-26","objectID":"/linux-system-programming/:3:0","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#3-高级io"},{"categories":["program"],"content":" 3.1 非阻塞IO两种指定非阻塞io的方法： 如果调用open获得描述符，可指定O_NONBLCK标志 对于一个已经打开的描述符，调用fcntl，由该函数打开O_NONBLCK标志 c //1 if(open(\"path/a.txt\",O_RDWR|O_NONBLOCK) == -1 ) return -1; //2 int flags; if((flags = fcntl(fd, F_GETFL, NULL)) \u003c 0) return -1; if(fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) return -1; 如果调用read/write时暂时没有数据可读，返回-1，设置errno为EAGAIN ","date":"2019-09-26","objectID":"/linux-system-programming/:3:1","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#31-非阻塞io"},{"categories":["program"],"content":" 3.2 fcntl记录锁 c #include \u003cfcntl.h\u003e int fcntl(int fd, int cmd, ... /*struct flock * flockptr*/); struct flock { short l_type; /*F_RDLCK，F_WRLCK，or F_UNLCK*/ short l_whence; /*SEEK_SET,SEEK_CUR or SEEK_END*/ off_t l_start; /*offset in bytes,relative to l_whence*/ off_t l_len; /*length,in bytes, 0 mens lock to EOF*/ pid_t l_pid; /*returned with F_GETLK*/ } 对flock结构说明如下 所希望的锁的类型：F_RDLCK共享读锁，F_WRLCK独占性写锁，or F_UNLCK解锁一个区域 要加锁或解锁的区域的起始位置 l_whence + l_start 区域的字节长度 进程的ID持有的锁能阻塞当前进程（仅由F_GETLK返回） 锁可以在当前文件尾部开始，或越过尾部开始，但不能在文件起始位置之前开始 若l_len为0，表示锁的范围无限大 为了对整个文件加锁，设置l_start和l_whence指向文件起始位置，l_len为0 俩个锁实现：可以同时读，读时不能写。只能一个写，写时不能读。 cmd： F_GETLK：如果锁能被设置，该命令并不真的设置锁，而是只修改lock的l_type为F_UNLCK,然后返回该结构体。如果存在一个或多个锁与希望设置的锁相互冲突，则fcntl返回其中的一个锁的flock结构。出错返回-1 F_SETLK：加锁或解锁，如果锁被其他进程占用，则返回-1，这种情况设的锁遇到锁被其他进程占用时，会立刻停止进程。; F_SETLKW：F_SETLK的阻塞版本 ","date":"2019-09-26","objectID":"/linux-system-programming/:3:2","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#32-fcntl记录锁"},{"categories":["program"],"content":" 3.3 IO多路转接如果我们的程序要处理多个输入输出，我们不能阻塞在任意一个上面，也不知道何时有哪个fd上的数据可读。 使用多进程，增加复杂性，父子进程同步 使用多线程，增加复杂性，线程同步 一个程序，非阻塞IO，轮询，长时间空转，浪费性能 异步IO（asynchronous IO），当描述符准备好可以IO时，内核用一个信号通知进程。缺点标准不统一，信号有限（SIGPOLL或SIGIO，各系统不一致），难以管理多个描述符。 IO多路转接（IO multiplexing），先构造一张我们感兴趣的描述符的列表，然后调用一个函数，知道这些描述符中的一个已准备好IO时，该函数才返回。poll，pselect，select这三个函数使我们能够进行IO多路转接。 posix指定，为了使用select，必须包含\u003csys/select.h\u003e。 3.3.1 select和pselect在所有posix兼容的平台上，select函数使我们可以执行IO多路转接，传给select的参数告诉内核： 我们关心的描述符 对于每个描述符我们所关心的条件（是否想读，是否想写，是否关心异常条件） 愿意等待多长时间（可以永远等待，等待一个固定的时间或根本不等待） 从select返回时，内核告诉我们： 已准备好的描述符的总量 对于读，写，异常这3个条件中的每一个，哪些描述符已准备好 使用这种返回信息，就可以调用IO函数（一般是read或write），并确知不会阻塞。 c #include \u003csys/select.h\u003e int select(int maxfdp1, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval *restrict tvptr); //返回准备就绪的描述符数量；若超时返回0，出错返回-1 maxfdp1是最大文件描述符编号值加1，找出三个描述符集中最大的描述符编号值，然后加1。也可以设置为FD_SETSIZE常量，经常是1024。对于大多数程序，此值过大。 中间三个参数readfds，writefds，exceptfds是指向描述符集的指针，既是输入又是输出，每个描述符集存储在一个FD_SET数据类型中。描述符集可以看做一个大数组，关心哪个描述符就在数组中置1，select将更新这个集合,把其中不可读的套节字去掉。如果三个参数都是NULL，可以 提供比sleep()更精确的睡眠 c #include \u003csys/select.h\u003e int FD_ISSET(int fd, fd_set *fdset); //若fd在描述符集中，返回非0，否则返回0 void FD_CLR(int fd, fd_set *fdset); //开启描述符中的一位 void FD_SET(int fd, fd_set *fdset); //清除一位 void FD_ZERO(fd_set * fdset); //将所有位清0 tvptr，等待时间，单位秒和微秒 c tvptr == NULL 永远等待，知道知道描述符中一个已经准备好。如果捕捉到一个信号则返回-1，errno=EINTR tvpty-\u003etv_sec == 0 \u0026\u0026 tvptr-\u003etv_usec == 0 不等待 tvpty-\u003etv_sec != 0 || tvptr-\u003etv_usec != 0 等待指定时间，也可被信号打断 返回-1，表示出错，如被信号打断 返回0，表示没有描述符准备好，所有描述符集都会被置0 返回正值，说明已经准备好的描述符数。该值是3个描述符集中已准备好的个数之和。同一个描述符准备 好读和写，那么返回值会计数两次。 当一个描述符达到文件尾端，select仍认为是可读的，这时候read返回0 POSIX也定义了一个select的变体pselect c #include \u003csys/select.h\u003e int pselect(int maxfdp1, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, const struct timespec *restrict tsptr, const sigset_t * sigmask); //返回准备就绪的描述符数量；若超时返回0，出错返回-1 不同点： 使用timespec提供纳秒级别控制 超时值被声明为const，保证pselect不会改变此值 可使用可选信号屏蔽字。原子操作安装屏蔽字，返回时恢复以前的信号屏蔽字 3.3.2 pollpoll函数类似select，但是程序员接口有所不用。 C #include \u003cpoll.h\u003e int poll(struct pollfd fdarray[], nfds_t nfds, int timeout); //返回就绪的描述符数目，若超时返回0，出错返回-1 //与select不同，poll不是为每个条件构造一个描述符集，而是构造一个pollfd结构的数组 struct pollfd { int fd; /*file descriptor to check, or \u003c 0 to ignore*/ short events; /*events of interest on fd*/ short revents; /*events that occured on fd 由内核设置，告诉我们发生了什么*/ } events应设置： POLLIN普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND POLLRDNORM‐普通数据可读 POLLRDBAND‐优先级带数据可读 POLLPRI 高优先级可读数据 POLLOUT普通或带外数据可写 POLLWRNORM‐数据可写 POLLWRBAND‐优先级带数据可写 POLLERR 发生错误 POLLHUP 发生挂起 POLLNVAL 描述字不是一个打开的文件 nfds指定数组中的元素数 timeout毫秒级等待，-1永远等待，0不等待 ","date":"2019-09-26","objectID":"/linux-system-programming/:3:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#33-io多路转接"},{"categories":["program"],"content":" 3.3 IO多路转接如果我们的程序要处理多个输入输出，我们不能阻塞在任意一个上面，也不知道何时有哪个fd上的数据可读。 使用多进程，增加复杂性，父子进程同步 使用多线程，增加复杂性，线程同步 一个程序，非阻塞IO，轮询，长时间空转，浪费性能 异步IO（asynchronous IO），当描述符准备好可以IO时，内核用一个信号通知进程。缺点标准不统一，信号有限（SIGPOLL或SIGIO，各系统不一致），难以管理多个描述符。 IO多路转接（IO multiplexing），先构造一张我们感兴趣的描述符的列表，然后调用一个函数，知道这些描述符中的一个已准备好IO时，该函数才返回。poll，pselect，select这三个函数使我们能够进行IO多路转接。 posix指定，为了使用select，必须包含。 3.3.1 select和pselect在所有posix兼容的平台上，select函数使我们可以执行IO多路转接，传给select的参数告诉内核： 我们关心的描述符 对于每个描述符我们所关心的条件（是否想读，是否想写，是否关心异常条件） 愿意等待多长时间（可以永远等待，等待一个固定的时间或根本不等待） 从select返回时，内核告诉我们： 已准备好的描述符的总量 对于读，写，异常这3个条件中的每一个，哪些描述符已准备好 使用这种返回信息，就可以调用IO函数（一般是read或write），并确知不会阻塞。 c #include int select(int maxfdp1, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval *restrict tvptr); //返回准备就绪的描述符数量；若超时返回0，出错返回-1 maxfdp1是最大文件描述符编号值加1，找出三个描述符集中最大的描述符编号值，然后加1。也可以设置为FD_SETSIZE常量，经常是1024。对于大多数程序，此值过大。 中间三个参数readfds，writefds，exceptfds是指向描述符集的指针，既是输入又是输出，每个描述符集存储在一个FD_SET数据类型中。描述符集可以看做一个大数组，关心哪个描述符就在数组中置1，select将更新这个集合,把其中不可读的套节字去掉。如果三个参数都是NULL，可以 提供比sleep()更精确的睡眠 c #include int FD_ISSET(int fd, fd_set *fdset); //若fd在描述符集中，返回非0，否则返回0 void FD_CLR(int fd, fd_set *fdset); //开启描述符中的一位 void FD_SET(int fd, fd_set *fdset); //清除一位 void FD_ZERO(fd_set * fdset); //将所有位清0 tvptr，等待时间，单位秒和微秒 c tvptr == NULL 永远等待，知道知道描述符中一个已经准备好。如果捕捉到一个信号则返回-1，errno=EINTR tvpty-\u003etv_sec == 0 \u0026\u0026 tvptr-\u003etv_usec == 0 不等待 tvpty-\u003etv_sec != 0 || tvptr-\u003etv_usec != 0 等待指定时间，也可被信号打断 返回-1，表示出错，如被信号打断 返回0，表示没有描述符准备好，所有描述符集都会被置0 返回正值，说明已经准备好的描述符数。该值是3个描述符集中已准备好的个数之和。同一个描述符准备 好读和写，那么返回值会计数两次。 当一个描述符达到文件尾端，select仍认为是可读的，这时候read返回0 POSIX也定义了一个select的变体pselect c #include int pselect(int maxfdp1, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, const struct timespec *restrict tsptr, const sigset_t * sigmask); //返回准备就绪的描述符数量；若超时返回0，出错返回-1 不同点： 使用timespec提供纳秒级别控制 超时值被声明为const，保证pselect不会改变此值 可使用可选信号屏蔽字。原子操作安装屏蔽字，返回时恢复以前的信号屏蔽字 3.3.2 pollpoll函数类似select，但是程序员接口有所不用。 C #include int poll(struct pollfd fdarray[], nfds_t nfds, int timeout); //返回就绪的描述符数目，若超时返回0，出错返回-1 //与select不同，poll不是为每个条件构造一个描述符集，而是构造一个pollfd结构的数组 struct pollfd { int fd; /*file descriptor to check, or \u003c 0 to ignore*/ short events; /*events of interest on fd*/ short revents; /*events that occured on fd 由内核设置，告诉我们发生了什么*/ } events应设置： POLLIN普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND POLLRDNORM‐普通数据可读 POLLRDBAND‐优先级带数据可读 POLLPRI 高优先级可读数据 POLLOUT普通或带外数据可写 POLLWRNORM‐数据可写 POLLWRBAND‐优先级带数据可写 POLLERR 发生错误 POLLHUP 发生挂起 POLLNVAL 描述字不是一个打开的文件 nfds指定数组中的元素数 timeout毫秒级等待，-1永远等待，0不等待 ","date":"2019-09-26","objectID":"/linux-system-programming/:3:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#331-select和pselect"},{"categories":["program"],"content":" 3.3 IO多路转接如果我们的程序要处理多个输入输出，我们不能阻塞在任意一个上面，也不知道何时有哪个fd上的数据可读。 使用多进程，增加复杂性，父子进程同步 使用多线程，增加复杂性，线程同步 一个程序，非阻塞IO，轮询，长时间空转，浪费性能 异步IO（asynchronous IO），当描述符准备好可以IO时，内核用一个信号通知进程。缺点标准不统一，信号有限（SIGPOLL或SIGIO，各系统不一致），难以管理多个描述符。 IO多路转接（IO multiplexing），先构造一张我们感兴趣的描述符的列表，然后调用一个函数，知道这些描述符中的一个已准备好IO时，该函数才返回。poll，pselect，select这三个函数使我们能够进行IO多路转接。 posix指定，为了使用select，必须包含。 3.3.1 select和pselect在所有posix兼容的平台上，select函数使我们可以执行IO多路转接，传给select的参数告诉内核： 我们关心的描述符 对于每个描述符我们所关心的条件（是否想读，是否想写，是否关心异常条件） 愿意等待多长时间（可以永远等待，等待一个固定的时间或根本不等待） 从select返回时，内核告诉我们： 已准备好的描述符的总量 对于读，写，异常这3个条件中的每一个，哪些描述符已准备好 使用这种返回信息，就可以调用IO函数（一般是read或write），并确知不会阻塞。 c #include int select(int maxfdp1, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval *restrict tvptr); //返回准备就绪的描述符数量；若超时返回0，出错返回-1 maxfdp1是最大文件描述符编号值加1，找出三个描述符集中最大的描述符编号值，然后加1。也可以设置为FD_SETSIZE常量，经常是1024。对于大多数程序，此值过大。 中间三个参数readfds，writefds，exceptfds是指向描述符集的指针，既是输入又是输出，每个描述符集存储在一个FD_SET数据类型中。描述符集可以看做一个大数组，关心哪个描述符就在数组中置1，select将更新这个集合,把其中不可读的套节字去掉。如果三个参数都是NULL，可以 提供比sleep()更精确的睡眠 c #include int FD_ISSET(int fd, fd_set *fdset); //若fd在描述符集中，返回非0，否则返回0 void FD_CLR(int fd, fd_set *fdset); //开启描述符中的一位 void FD_SET(int fd, fd_set *fdset); //清除一位 void FD_ZERO(fd_set * fdset); //将所有位清0 tvptr，等待时间，单位秒和微秒 c tvptr == NULL 永远等待，知道知道描述符中一个已经准备好。如果捕捉到一个信号则返回-1，errno=EINTR tvpty-\u003etv_sec == 0 \u0026\u0026 tvptr-\u003etv_usec == 0 不等待 tvpty-\u003etv_sec != 0 || tvptr-\u003etv_usec != 0 等待指定时间，也可被信号打断 返回-1，表示出错，如被信号打断 返回0，表示没有描述符准备好，所有描述符集都会被置0 返回正值，说明已经准备好的描述符数。该值是3个描述符集中已准备好的个数之和。同一个描述符准备 好读和写，那么返回值会计数两次。 当一个描述符达到文件尾端，select仍认为是可读的，这时候read返回0 POSIX也定义了一个select的变体pselect c #include int pselect(int maxfdp1, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, const struct timespec *restrict tsptr, const sigset_t * sigmask); //返回准备就绪的描述符数量；若超时返回0，出错返回-1 不同点： 使用timespec提供纳秒级别控制 超时值被声明为const，保证pselect不会改变此值 可使用可选信号屏蔽字。原子操作安装屏蔽字，返回时恢复以前的信号屏蔽字 3.3.2 pollpoll函数类似select，但是程序员接口有所不用。 C #include int poll(struct pollfd fdarray[], nfds_t nfds, int timeout); //返回就绪的描述符数目，若超时返回0，出错返回-1 //与select不同，poll不是为每个条件构造一个描述符集，而是构造一个pollfd结构的数组 struct pollfd { int fd; /*file descriptor to check, or \u003c 0 to ignore*/ short events; /*events of interest on fd*/ short revents; /*events that occured on fd 由内核设置，告诉我们发生了什么*/ } events应设置： POLLIN普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND POLLRDNORM‐普通数据可读 POLLRDBAND‐优先级带数据可读 POLLPRI 高优先级可读数据 POLLOUT普通或带外数据可写 POLLWRNORM‐数据可写 POLLWRBAND‐优先级带数据可写 POLLERR 发生错误 POLLHUP 发生挂起 POLLNVAL 描述字不是一个打开的文件 nfds指定数组中的元素数 timeout毫秒级等待，-1永远等待，0不等待 ","date":"2019-09-26","objectID":"/linux-system-programming/:3:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#332-poll"},{"categories":["program"],"content":" 3.4 epoll由于poll和select的局限性，linux引入了event poll机制。虽然比前两个复杂了很多，但解决了他们共有的性能问题。它能显著提高程序在大量文件描述符中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。 创建epoll实例： c #include \u003csys/epoll.h\u003e int epoll_create(int size); //创建一个实例，返回一个epoll fd，出错返回-1 int epoll_create1(int flag); // EPOLL_CLOEXEC设置描述符标志 为0和epoll_create一样 出错设置errno为下列值之一： EINVALsize不是正数 ENFILE系统达到打开文件数的上限 ENOMEN没有足够内存完成此次操作 c int epfd; epfd = epoll_create(100);/*plan to watch ~100 fds*/ if(epfd\u003c0){ perror(\"epoll_create\"); } epoll返回的文件描述符需要用close()关闭。 控制epoll c #include \u003csys/epoll.h\u003e int epoll_ctl(int epfd, int op, int fd, struct epoll_event * event); //成功返回0，失败返回-1 struct epoll_event { __u32 events; /* events */ union { void *ptr; int fd; __u32 u32; __u64 u64; } data; }; 参数op指定要对fd进行的操作：增删改 EPOLL_CTL_ADD把fd指定文件添加到epfd指定的epoll实例监听集中，监听event中定义的事件 EPOLL_CTL_DEL从监听集合中删除 EPOLL_CTL_MOD使用event改变在已有fd上的监听行为 epoll events结构体中的events参数列出了在给定文件描述符上监听的事件。可以用位运算同时指定 EPOLLIN 文件描述符可读（包括对端SOCKET正常关闭） EPOLLOUT文件描述符可写 EPOLLPRI高优先级的带外数据可读 EPOLLERR文件出错，即使没有设置这个事件也是被监听的 EPOLLHUP文件被挂起，即使没有设置这个事件也是被监听的 EPOLLET将EPOLL设为边缘触发(Edge Triggered)模式，默认是水平触发(Level Triggered) EPOLLONESHOT只监听一次事件，当监听完这次事件之后,必须使用EPOLL_CTL_MOD指定新事件，以便重新监听文件 event_poll中的data字段由用户使用。确认事件监听后，data会被返回给用户，通常将event.data.fd设定为fd 失败后errno为下列值： EBADF epfd不是一个有效地epoll实例，或者fd不是有效地文件描述符 EEXIST op为 EPOLL_CTL_ADD，但是fd已经关联过，不可重复关联 EINVAL epfd不是一个epoll实例，epfd和fd相同，或者op无效 ENOENT op为 EPOLL_CTL_MOD 或 EPOLL_CTL_DEL ，但fd没有与epfd关联 ENOMEN 内存不足 EPERM fd不支持epoll 等待epoll事件 c #include \u003csys/epoll.h\u003e int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); //返回事件数，出错返回-1 出错设置errno : EBADF epfd无效 EFAULT 进程对events指向的内存无写权限 EINTR 被信号打断 EINVAL epfd不是有效epoll实例，或者maxevents大于创建时的size timeout为-1，永远等待，为0不等待，如果超时函数返回0 c #define MAX_EVENTS 64 struct epoll_event * events; int nr_events, i, epfd; events = malloc(sizeof(struct epoll_event) * MAX_EVENTS); /*创建接收结果的数组*/ if(!events){ perror(\"malloc\"); return 1; } nr_events = epoll_wait(epfd, events, MAX_EVENTS, -1); if(nr_events \u003c 0){ perror(\"epoll_wait\"); free(events); return 1; } for(i=0; i \u003c nr_events; ++i){ printf(\"event=%ld on fd=%d\\n\",events[i].events,events[i].data.fd); /*do something IO*/ } free(events); ","date":"2019-09-26","objectID":"/linux-system-programming/:3:4","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#34-epoll"},{"categories":["program"],"content":" 3.5 异步IO","date":"2019-09-26","objectID":"/linux-system-programming/:3:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#35-异步io"},{"categories":["program"],"content":" 4 文件和目录","date":"2019-09-26","objectID":"/linux-system-programming/:4:0","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#4-文件和目录"},{"categories":["program"],"content":" 5 进程控制","date":"2019-09-26","objectID":"/linux-system-programming/:5:0","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#5-进程控制"},{"categories":["program"],"content":" 5.1 进程环境 main函数 c程序总是从main函数开始执行，main函数的原型是： c int main(int argc, char *argv[]); 内核执行c程序时（使用exec函数），调用main前先调用一个特殊的启动例程，启动例程从内核取得命令行参数和环境变量值。此启动例程被设置为程序起始地址，这是由连接编辑器设置的。 进程终止 5中正常终止： 从main返回 调用exit 调用 _exit 或 _Exit 最后一个线程从其启动例程返回 最后一个线程调用 pthread_exit 3中异常终止： 调用abort 接到一个信号 最后一个线程对取消请求作出相应 退出函数 c #include \u003cstdlib.h\u003e void exit(int status); void _Exit(int status); #include \u003cunistd.h\u003e void _exit(int status); 3个函数用于正常终止一个程序，_exit 和 _Exit 立即进入内核，exit则先执行一些清理处理，然后返回内核 函数 atexit c #include \u003cstdlib.h\u003e int atexit(void (*func)(void)); //成返回0，失败返回非0 一个进程可以登记至多32个函数，这些函数由exit自动调用。调用顺序与登记顺序相反 环境表 每个程序都接收到一张环境表。 c extern char **environ; 通常使用 getenv 和 putenv 函数来访问特定的环境变量，但如果要查看整个环境，必须使用environ c #include \u003cstdlib.h\u003e char *getenv(const char *name); //返回与name关联的value指针，找不到返回NULL int putenv(char *str); //成功返回0，出错非0 int setenv(const char *name, const char *value, int rewrite); int unsetenv(const char *name); //成功返回0，失败返回-1 putenv去形式为name=value的字符串，name已存在则先删除原来的 setenv将name设置为value，若name已存在，rewirte 取1/0控制是否删除原来或放弃操作，放弃不算出错 unsetenv删除name的定义 ","date":"2019-09-26","objectID":"/linux-system-programming/:5:1","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#51-进程环境"},{"categories":["program"],"content":" 5.2 进程标识符每个进程都有一个非负整形表示的唯一进程ID c #include \u003cunistd.h\u003e pid_t getpid(void); //返回进程ID pid_t getppid(void); //返回父进程ID uid_t getuid(void); //返回调用程序的实际用户ID uid_t geteudi(void); //返回有效用户ID gid_t getgid(void); //返回实际组ID gid_t getegid(void); //返回有效组ID 这些函数都没有出错返回。 ","date":"2019-09-26","objectID":"/linux-system-programming/:5:2","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#52-进程标识符"},{"categories":["program"],"content":" 5.3 fork一个现有的进程可以调用fork函数创建一个新进程 c #include \u003cunistd.h\u003e pid_t fork(void); //子进程返回0，父进程返回子进程ID，出错返回-1 子进程获得父进程数据空间，堆栈的副本。并不共享（写时复制Copy-On-Write） 文件共享： 除了打开文件之外，父进程很多其他属性也被继承： 实际用户ID，实际组ID，有效用户ID，有效组ID 附属组ID 进程组ID 会话ID 控制终端 设置用户ID标志和设置组ID标志 当前工作目录 根目录 文件模式创建屏蔽字 信号屏蔽和安排 对任一打开文件描述符的执行时关闭（close-on-exec）标志 环境 连接的共享存储段 存储映像 资源限制 父进程和子进程之间的区别如下： fork返回值不同 进程ID不同 父进程ID不同 子进程的tms_utime、tmd_stime、tms_cutime 和 tms_ustime 的值设置为0 子进程不继承父进程设置的文件锁 子进程的未处理闹钟被清除 子进程的未处理信号集设置为空集 fork失败有两个主要原因：系统有太多进程，用户进程数超过限制 ","date":"2019-09-26","objectID":"/linux-system-programming/:5:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#53-fork"},{"categories":["program"],"content":" 5.4 函数wait和waitpid当一个进程正常或异常结束时，内核就向其父进程发送SIGCHLD信号。 调用wait和waitpid可能会发生： 如果其所有子进程都还在运行，则阻塞 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程终止状态立即返回 如果他没有任何子进程，立即出错返回 c #include \u003csys/wait.h\u003e pid_t wait(int *statloc); pid_t waitpid(pid_t pid, int *statloc, int options); //俩函数成功返回进程id，出错返回0或-1 两函数区别： 在一个子进程终止前，wait使其调用者阻塞，而waitpid有一个选项可以不阻塞 waitpid不等待在其调用之后的第一个 终止子进程，他有若干个选项，可以控制他所等待的进程 参数statloc是一个整型指针。如果不是空指针，则终止进程的状态就放在里面，如果不关心终止状态，可以指定为NULL 有4个互斥的宏可以用来取得进程终止的原因 宏 说明 WIFEXITED(status) 若为正常终止的状态，返回真。可以执行WEXITSTATUS(status)获取子进程传送给exit的低8位 WIFSIGNALED(status) 若为异常常终止的状态，返回真（接到一个不捕捉的信号），可执行WTERMSIG(status)获取使进程终止的信号编号。有些实现定义宏WCOREDUMP(status)返回是否已产生终止进程的core文件 WIFSTOPPED(status) 若为当前暂停子进程的返回的状态，则为真，可执行WSTOPSIG(status)，获取使进程暂停的信号编号 WIFCONTINUED(status) 若在作业控制暂停后已经继续的子进程返回了状态，则为真。（仅用于waitpid） 对与waitpid的参数pid c pid == -1; /*等待任一子进程，和wait没区别*/ pid \u003e 0; /*等待进程id与pid相等的子进程*/ pid == 0; /*等待组id等于调用进程组id的任一子程序*/ pid \u003c -1; /*等待组id等于pid绝对值的任一子程序*/ options参数进一步控制waitpid的操作： c WCONTINUED /*若实现支持作业控制，那么由pid指定的任一子进程在停止后已经继续，但其状态尚未报告，则返回其状态*/ WNOHANG /*若没有等待的子进程，waitpid不阻塞 此时返回值为0*/ WUNTRACED /*若实现支持作业控制，那么由pid指定的任一子进程停止，但其状态紫停止以来尚未报告，则返回其状态*/ waitpid提供了wait函数没有的三个功能 waitpid可以等待特定进程 waitpid提供了一个wait的非阻塞版本 waitpid支持作业控制 ","date":"2019-09-26","objectID":"/linux-system-programming/:5:4","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#54-函数wait和waitpid"},{"categories":["program"],"content":" 5.5 函数execfork函数创建子进程后，子进程可以调用exec函数以执行另一个程序。exec只是用磁盘上的一个程序替换当前程序的正文段，数据段，堆段和栈段 c #include \u003cunistd.h\u003e int execl(const char *pathname, const char * arg0, ... /* (char *)0 */); int execv(const char *pathname, char *const argv[]); int execle(const char *pathname, const char *arg0, ... /* (char *)0 , char *const envp[] */); int execve(const char *pathname, char *const argv[], char *const envp[]) int execlp(const char *filename, const char *arg0, ... /* (char *)0 */); int execvp(const char *filename, char *const argv[]); int fexecve(int fd, char *const argv[], char *const envp[]); //7个函数失败返回-1，若成功不返回 这些函数的第一个区别是前4个函数去路径名作为参数，后两个取文件名，最后一个取文件描述符 当指定filename作为参数时： 如果filename中包含/，就将其视为路径名 否则就按PATH环境变量搜寻 如果execlp或execvp使用路径前缀中的一个找到了可执行文件，但是不是二进制文件，就认为时shell脚本，调用/bin/sh执行 c execl(“/bin/ls”,”ls”,”-l”,NULL); //ls -l 第一个参数描述命令path char* av[]={\"ls\",\"-l\",NULL}; execv(\"/bin/ls\",av); //ls -l execlp(“ls”,”ls”,”-l”,NULL); char* argin[]={\"ls\", \"-l\", NULL}; execvp(argin[0],argin); // ls -l; //execlp 和 execvp 的区别是不用完整path，会在系统path环境变量中搜索 ","date":"2019-09-26","objectID":"/linux-system-programming/:5:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#55-函数exec"},{"categories":["program"],"content":" 5.6 进程时间我们可以度量的时间有三个，墙上的时钟，用户CPU时间，系统CPU时间 c #include \u003csys/times.h\u003e clock_t times(struct tms *buf); //成功返回流逝的墙上的时间，出错返回-1 //1970 年 1 月 1 日 00:00:00 到当前时间的秒数 64bit struct tms { clock_t tms_utime; /* user CPU time */ clock_t tms_stime; /* system CPU time */ clock_t tms_cutime; /* user CPU time,terminated children */ clock_t tms_cstime; /* system cpu time, terminated children */ }; ","date":"2019-09-26","objectID":"/linux-system-programming/:5:6","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#56-进程时间"},{"categories":["program"],"content":" 6 进程关系POSIX.1要求向新孤儿进程组中处于停止状态的每一个进程发送挂断信号(SIGHUP)，接着发送继续信号(SIGCONT) SIGHUB的默认动作是终止进程 ","date":"2019-09-26","objectID":"/linux-system-programming/:6:0","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#6-进程关系"},{"categories":["program"],"content":" 7 信号","date":"2019-09-26","objectID":"/linux-system-programming/:7:0","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#7-信号"},{"categories":["program"],"content":" 7.1 信号概念信号是软件中断。每个信号都有一个名字。 bash 1) SIGHUP: #当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程 2）SIGINT：#当用户按下了\u003cCtrl+C\u003e组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止里程。 3）SIGQUIT：#当用户按下\u003cctrl+\\\u003e组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。 4）SIGILL：#CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件 5）SIGTRAP：#该信号由断点指令或其他trap指令产生。默认动作为终止里程并产生core文件。 6 ) SIGABRT:#调用abort函数时产生该信号。默认动作为终止进程并产生core文件。 7）SIGBUS：#非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。 8）SIGFPE：#在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。 9）SIGKILL：#无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。 10）SIGUSE1：#用户定义的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。 11）SIGSEGV：#指示进程进行了无效内存访问。默认动作为终止进程并产生core文件。 12）SIGUSR2：#这是另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。1 13）SIGPIPE：#Broken pipe向一个没有读端的管道写数据。默认动作为终止进程。 14) SIGALRM:#定时器超时，超时的时间由系统调用alarm设置。默认动作为终止进程。 15）SIGTERM：#程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程。 16）SIGCHLD：#子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。 17）SIGCONT：#停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为终止进程。 18）SIGTTIN：#后台进程读终端控制台。默认动作为暂停进程。 19）SIGTSTP：#停止进程的运行。按下\u003cctrl+z\u003e组合键时发出这个信号。默认动作为暂停进程。 21）SIGTTOU:#该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。 22）SIGURG：#套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。 23）SIGXFSZ：#进程执行时间超过了分配给该进程的CPU时间，系统产生该信号并发送给该进程。默认动作为终止进程。 24）SIGXFSZ：#超过文件的最大长度设置。默认动作为终止进程。 25）SIGVTALRM：#虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。 26）SGIPROF：#类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。 27）SIGWINCH：#窗口变化大小时发出。默认动作为忽略该信号。 28）SIGIO：#此信号向进程指示发出了一个异步IO事件。默认动作为忽略。 29）SIGPWR：#关机。默认动作为终止进程。 30）SIGSYS：#无效的系统调用。默认动作为终止进程并产生core文件。 31）SIGRTMIN～（64）SIGRTMAX：#LINUX的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程 ","date":"2019-09-26","objectID":"/linux-system-programming/:7:1","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#71-信号概念"},{"categories":["program"],"content":" 7.2 函数signal安装信号处理函数 c #include \u003csignal.h\u003e void (*signal(int signo, void (*func)(int)))(int); //成功返回以前的信号配置，出错返回SIG_ERR //有的实现分开定义，但意思一样 typedef void Sigfunc(int); Sigfunc *signal(int, Sigfunc *); signo可以用上面的信号宏，也可以用 SIG_DFL， SIG_IGN ，表示默认动作和忽略 SIGCHLD信号处理： c #include \u003csignal.h\u003e #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e void handle_sig_child() { int status; pid_t pid; while(1){ pid = waitpid(-1, \u0026status, WUNTRACED | WCONTINUED | WNOHANG); if(pid \u003c= 0) break; printf(\"recv child pid %d \\n\", pid); if(WIFEXITED(status)) printf(\"child process exited with %d\\n\", WEXITSTATUS(status)); else if(WIFSIGNALED(status)) printf(\"child process signaled with %d\\n\", WTERMSIG(status)); else if(WIFSTOPPED(status)) printf(\"child process stoped\\n\"); else if(WIFCONTINUED(status)) printf(\"child process continued\\n\"); } } ","date":"2019-09-26","objectID":"/linux-system-programming/:7:2","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#72-函数signal"},{"categories":["program"],"content":" 7.3 函数kill和raise发送信号kill函数将信号发送给进程或进程组。raise函数向自身发送信号 c #include \u003csignal.h\u003e int kill(pid_t pid, int signo); int raise(int signo); //成功返回0 失败返回-1 raise(signo)等价于kill(getpid(),signo) kill的pid参数有4种不同信号 c pid \u003e 0 /*将信号发送给进程*/ pid == 0 /*将信号发送给同一进程组的所有进程*/ pid \u003c 0 /*发送给其他进程组，id为pid绝对值*/ pid == -1 /*发送给所有进程（前提有权限）*/ 信号编号0定义以为空信号，如果signo参数是0，kill仍执行错误检查，但不发送信号，这个特性常用来检查一个特定的进程是否仍然存在。如果向不存在的进程发送信号，返回-1，errno=ESRCH ","date":"2019-09-26","objectID":"/linux-system-programming/:7:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#73-函数kill和raise发送信号"},{"categories":["program"],"content":" 7.4 alarm和pause c #include \u003cunistd.h\u003e unsigned int alarm(unsigned int seconds); //返回值 0或以前设置的闹钟余留秒数 一个进程只能有一个闹钟时间，如果在调用alarm时，已有闹钟，返回余留时间，替换新的秒数 如果有以前注册的尚未超过的闹钟时间，seconds参数为0，则取消以前的闹钟时间，返回余留秒数 SIGALRM默认动作是终止进程 pause函数使调用进程挂起直到捕捉到一个信号 c #include \u003cunistd.h\u003e int pause(void); //返回-1，errno设置为EINTR，只有执行了一个信号处理程序并从其返回，pause才返回 ","date":"2019-09-26","objectID":"/linux-system-programming/:7:4","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#74-alarm和pause"},{"categories":["program"],"content":" 7.5 信号集需要一个能表示多个信号的数据类型——信号集（signal set） POSIX.1定义数据类型sigset_t以包含一个信号集，并定义5个信号集处理函数 c #include \u003csignal.h\u003e int sigemptyset(sigset_t *set); int sigfillset(sigset_t *set); int sigaddset(sigset_t *set, int signo); int sigdelset(sigset_t *set, int signo); //4个函数成功返回0，出错返回-1 int sigismember(const sigset_t *set, int signo); //若真，返回1，假返回0 7.5.1 函数sigprocmask检测或更改，或同时检测和更改进程的信号屏蔽字 信号屏蔽字规定了当前阻塞而不能递送给该进程的信号集 c #include \u003csignal.h\u003e int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset); //成功返回0，出错返回-1 若oset是非空指针，当前的信号屏蔽字通过oset返回。 若set是非空指针，参数how指示如何修改当前屏蔽字，否则how无效 bash SIG_BLOCK #新屏蔽字取set和老屏蔽字的并集 SIG_UNBLOCK #新屏蔽字取set和老屏蔽字的交集 SIG_SETMASK #新屏蔽字取set 不能阻塞SIGKILL和SIGSTOP信号 sigprocmask是仅为单线程定义的，多线程中的信号屏蔽使用另一个 7.5.2 函数sigpending返回以信号集，对于调用进程而言，其中的信号是阻塞不能递送的，因而也是当前未决的。通过set返回 c #include \u003csignal.h\u003e int sigpending(sigset_t *set); //成功返回0，出错返回-1 7.5.3 函数sigaction检查或（并）修改与指定信号相关联的处理动作 c #include \u003csignal.h\u003e int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact); //成功返回0，失败返回-1 signo是要检测或修改其具体动作的信号编号。 若act非空，则要修改其动作。 若oact非空，则返回该信号的上一个动作 c struct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; }; /* sa_handler : 早期的捕捉函数 sa_sigaction : 新添加的捕捉函数，可以传参, 和sa_handler互斥，两者通过sa_flags选择采用哪种捕捉函数 sa_mask : 在执行捕捉函数时，设置阻塞其它信号，sa_mask | 进程阻塞信号集，退出捕捉函数后，还原回原有的 阻塞信号集 sa_flags : SA_SIGINFO 或者 0 用来指定调用sa_handler还是sa_sigaction ,SA_SIGINFO 时为调用sa_sigaction， SA_RESTART 让被打断的系统调用重新开始 */ //如果设置了SA_SIGINFO,则按下列方式调用信号处理程序 void handler(int signo, siginfo_t *info, void *context); //一个栗子 struct sigaction act; act.sa_handler = sig_handle; act.sa_flags = 0; sigemptyset(\u0026act.sa_mask); sigaddset(\u0026act.sa_mask, SIGQUIT); //当进入信号处理函数的时候，屏蔽掉SIGQUIT的递达 sigaction(SIGINT, \u0026act, NULL); ","date":"2019-09-26","objectID":"/linux-system-programming/:7:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#75-信号集"},{"categories":["program"],"content":" 7.5 信号集需要一个能表示多个信号的数据类型——信号集（signal set） POSIX.1定义数据类型sigset_t以包含一个信号集，并定义5个信号集处理函数 c #include int sigemptyset(sigset_t *set); int sigfillset(sigset_t *set); int sigaddset(sigset_t *set, int signo); int sigdelset(sigset_t *set, int signo); //4个函数成功返回0，出错返回-1 int sigismember(const sigset_t *set, int signo); //若真，返回1，假返回0 7.5.1 函数sigprocmask检测或更改，或同时检测和更改进程的信号屏蔽字 信号屏蔽字规定了当前阻塞而不能递送给该进程的信号集 c #include int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset); //成功返回0，出错返回-1 若oset是非空指针，当前的信号屏蔽字通过oset返回。 若set是非空指针，参数how指示如何修改当前屏蔽字，否则how无效 bash SIG_BLOCK #新屏蔽字取set和老屏蔽字的并集 SIG_UNBLOCK #新屏蔽字取set和老屏蔽字的交集 SIG_SETMASK #新屏蔽字取set 不能阻塞SIGKILL和SIGSTOP信号 sigprocmask是仅为单线程定义的，多线程中的信号屏蔽使用另一个 7.5.2 函数sigpending返回以信号集，对于调用进程而言，其中的信号是阻塞不能递送的，因而也是当前未决的。通过set返回 c #include int sigpending(sigset_t *set); //成功返回0，出错返回-1 7.5.3 函数sigaction检查或（并）修改与指定信号相关联的处理动作 c #include int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact); //成功返回0，失败返回-1 signo是要检测或修改其具体动作的信号编号。 若act非空，则要修改其动作。 若oact非空，则返回该信号的上一个动作 c struct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; }; /* sa_handler : 早期的捕捉函数 sa_sigaction : 新添加的捕捉函数，可以传参, 和sa_handler互斥，两者通过sa_flags选择采用哪种捕捉函数 sa_mask : 在执行捕捉函数时，设置阻塞其它信号，sa_mask | 进程阻塞信号集，退出捕捉函数后，还原回原有的 阻塞信号集 sa_flags : SA_SIGINFO 或者 0 用来指定调用sa_handler还是sa_sigaction ,SA_SIGINFO 时为调用sa_sigaction， SA_RESTART 让被打断的系统调用重新开始 */ //如果设置了SA_SIGINFO,则按下列方式调用信号处理程序 void handler(int signo, siginfo_t *info, void *context); //一个栗子 struct sigaction act; act.sa_handler = sig_handle; act.sa_flags = 0; sigemptyset(\u0026act.sa_mask); sigaddset(\u0026act.sa_mask, SIGQUIT); //当进入信号处理函数的时候，屏蔽掉SIGQUIT的递达 sigaction(SIGINT, \u0026act, NULL); ","date":"2019-09-26","objectID":"/linux-system-programming/:7:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#751-函数sigprocmask"},{"categories":["program"],"content":" 7.5 信号集需要一个能表示多个信号的数据类型——信号集（signal set） POSIX.1定义数据类型sigset_t以包含一个信号集，并定义5个信号集处理函数 c #include int sigemptyset(sigset_t *set); int sigfillset(sigset_t *set); int sigaddset(sigset_t *set, int signo); int sigdelset(sigset_t *set, int signo); //4个函数成功返回0，出错返回-1 int sigismember(const sigset_t *set, int signo); //若真，返回1，假返回0 7.5.1 函数sigprocmask检测或更改，或同时检测和更改进程的信号屏蔽字 信号屏蔽字规定了当前阻塞而不能递送给该进程的信号集 c #include int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset); //成功返回0，出错返回-1 若oset是非空指针，当前的信号屏蔽字通过oset返回。 若set是非空指针，参数how指示如何修改当前屏蔽字，否则how无效 bash SIG_BLOCK #新屏蔽字取set和老屏蔽字的并集 SIG_UNBLOCK #新屏蔽字取set和老屏蔽字的交集 SIG_SETMASK #新屏蔽字取set 不能阻塞SIGKILL和SIGSTOP信号 sigprocmask是仅为单线程定义的，多线程中的信号屏蔽使用另一个 7.5.2 函数sigpending返回以信号集，对于调用进程而言，其中的信号是阻塞不能递送的，因而也是当前未决的。通过set返回 c #include int sigpending(sigset_t *set); //成功返回0，出错返回-1 7.5.3 函数sigaction检查或（并）修改与指定信号相关联的处理动作 c #include int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact); //成功返回0，失败返回-1 signo是要检测或修改其具体动作的信号编号。 若act非空，则要修改其动作。 若oact非空，则返回该信号的上一个动作 c struct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; }; /* sa_handler : 早期的捕捉函数 sa_sigaction : 新添加的捕捉函数，可以传参, 和sa_handler互斥，两者通过sa_flags选择采用哪种捕捉函数 sa_mask : 在执行捕捉函数时，设置阻塞其它信号，sa_mask | 进程阻塞信号集，退出捕捉函数后，还原回原有的 阻塞信号集 sa_flags : SA_SIGINFO 或者 0 用来指定调用sa_handler还是sa_sigaction ,SA_SIGINFO 时为调用sa_sigaction， SA_RESTART 让被打断的系统调用重新开始 */ //如果设置了SA_SIGINFO,则按下列方式调用信号处理程序 void handler(int signo, siginfo_t *info, void *context); //一个栗子 struct sigaction act; act.sa_handler = sig_handle; act.sa_flags = 0; sigemptyset(\u0026act.sa_mask); sigaddset(\u0026act.sa_mask, SIGQUIT); //当进入信号处理函数的时候，屏蔽掉SIGQUIT的递达 sigaction(SIGINT, \u0026act, NULL); ","date":"2019-09-26","objectID":"/linux-system-programming/:7:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#752-函数sigpending"},{"categories":["program"],"content":" 7.5 信号集需要一个能表示多个信号的数据类型——信号集（signal set） POSIX.1定义数据类型sigset_t以包含一个信号集，并定义5个信号集处理函数 c #include int sigemptyset(sigset_t *set); int sigfillset(sigset_t *set); int sigaddset(sigset_t *set, int signo); int sigdelset(sigset_t *set, int signo); //4个函数成功返回0，出错返回-1 int sigismember(const sigset_t *set, int signo); //若真，返回1，假返回0 7.5.1 函数sigprocmask检测或更改，或同时检测和更改进程的信号屏蔽字 信号屏蔽字规定了当前阻塞而不能递送给该进程的信号集 c #include int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset); //成功返回0，出错返回-1 若oset是非空指针，当前的信号屏蔽字通过oset返回。 若set是非空指针，参数how指示如何修改当前屏蔽字，否则how无效 bash SIG_BLOCK #新屏蔽字取set和老屏蔽字的并集 SIG_UNBLOCK #新屏蔽字取set和老屏蔽字的交集 SIG_SETMASK #新屏蔽字取set 不能阻塞SIGKILL和SIGSTOP信号 sigprocmask是仅为单线程定义的，多线程中的信号屏蔽使用另一个 7.5.2 函数sigpending返回以信号集，对于调用进程而言，其中的信号是阻塞不能递送的，因而也是当前未决的。通过set返回 c #include int sigpending(sigset_t *set); //成功返回0，出错返回-1 7.5.3 函数sigaction检查或（并）修改与指定信号相关联的处理动作 c #include int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact); //成功返回0，失败返回-1 signo是要检测或修改其具体动作的信号编号。 若act非空，则要修改其动作。 若oact非空，则返回该信号的上一个动作 c struct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; }; /* sa_handler : 早期的捕捉函数 sa_sigaction : 新添加的捕捉函数，可以传参, 和sa_handler互斥，两者通过sa_flags选择采用哪种捕捉函数 sa_mask : 在执行捕捉函数时，设置阻塞其它信号，sa_mask | 进程阻塞信号集，退出捕捉函数后，还原回原有的 阻塞信号集 sa_flags : SA_SIGINFO 或者 0 用来指定调用sa_handler还是sa_sigaction ,SA_SIGINFO 时为调用sa_sigaction， SA_RESTART 让被打断的系统调用重新开始 */ //如果设置了SA_SIGINFO,则按下列方式调用信号处理程序 void handler(int signo, siginfo_t *info, void *context); //一个栗子 struct sigaction act; act.sa_handler = sig_handle; act.sa_flags = 0; sigemptyset(\u0026act.sa_mask); sigaddset(\u0026act.sa_mask, SIGQUIT); //当进入信号处理函数的时候，屏蔽掉SIGQUIT的递达 sigaction(SIGINT, \u0026act, NULL); ","date":"2019-09-26","objectID":"/linux-system-programming/:7:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#753-函数sigaction"},{"categories":["program"],"content":" 7.6 信号名和编号数组下标是信号编号，数组元素是指向信号名字符串的指针 c extern char *sys_siglist[]; 可以使用psignal函数打印信号对应的字符串 c #include \u003csignal.h\u003e void psignal(int signo, const char *msg); //到标准错误 #include \u003cstring.h\u003e char *strsignal(int signo); //返回字符串指针 ","date":"2019-09-26","objectID":"/linux-system-programming/:7:6","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#76-信号名和编号"},{"categories":["program"],"content":" 8 线程","date":"2019-09-26","objectID":"/linux-system-programming/:8:0","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#8-线程"},{"categories":["program"],"content":" 8.1 线程标识每个线程有一个线程ID，线程ID只有在它所属的进程上下文中才有意义 线程ID使用pthread_t数据类型来表示的，不同实现可能定义不一样，linux用无符号长整形表示 c #include \u003cpthread.h\u003e int pthread_equal(pthread_t tid1, pthread_t tid2); //比较tid，相等返回非0，否则返回0 pthread_t pthread_self(void); //返回调用线程的tid ","date":"2019-09-26","objectID":"/linux-system-programming/:8:1","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#81-线程标识"},{"categories":["program"],"content":" 8.2 线程创建 c #include \u003cpthread.h\u003e int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg); //若成功返回0，否则返回错误编号 返回成功时，新建进程的ID会通过tidp传回 attr参数用于定制各种不同的线程属性，也可以填NULL，使用默认 新建进程从start_rtn函数的地址开始运行 arg是穿给start_rtn的参数，可以直接当值传也可当指针传一个结构体携带更多信息 新建线程继承调用线程的浮点环境和信号屏蔽字，但是挂起信号集会被清除 ","date":"2019-09-26","objectID":"/linux-system-programming/:8:2","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#82-线程创建"},{"categories":["program"],"content":" 8.3 线程终止如果进程中任意线程调用了exit，_Exit，_exit，那么整个进程就会终止 如果默认动作是终止进程，发送给线程的信号会终止整个进程 单个线程可以通过3种方式退出 线程可以简单地从启动例程中返回，返回值是线程退出码 被同一进程中的其他线程取消 线程调用pthread_exit 8.3.1 pthread_exit c #include \u003cpthread.h\u003e void pthread_exit(void *rval_ptr) rval_ptr参数是一个无类型指针。其他线程也可以通过pthread_join函数访问到这个指针 8.3.2 pthread_join c #include \u003cpthread.h\u003e int pthread_join(pthread_t thread, void **rval_ptr); //成功返回0，否则返回错误编号 调用线程将一直阻塞，直到指定的线程调用pthread_exit，从启动例程返回或被取消。 如果线程简单地从启动例程返回，rval_ptr就包含返回码。不关心可以穿NULL 如果线程被取消，有rval_ptr指定的内存单元就设置为PTHREAD_CANCELED 调用函数可以回收线程的资源，前提线程不能是分离态，否则返回EINVAL 8.3.3 pthread_cancel线程可以调用pthread_cancel函数来请求取消同一进程中其他线程 c #include \u003cpthread.h\u003e int pthread_cancel(pthread_t tid); //成功返回0，否则返回错误码 默认情况下pthread_cancel函数会使得有tid表示的线程行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit 函数 但是线程可以选择忽略取消或控制如何被取消，pthread_cancel并不等待线程终止，只提出请求 8.3.4 安装清理函数线程可以安排他退出时需要调用的函数，与进程的atexit函数类似 这样的函数叫做线程清理处理程序，可以建立多个，记录在栈中 c #include \u003cpthread.h\u003e void pthread_cleanup_push(void (*rtn)(void *), void *arg); void pthread_cleanup_pop(int execute); 只有当线程执行以下动作时，清理函数是由pthread_clean_push函数调度的，调用时只有一个参数arg 调用pthread_exit时 相应取消请求时 用非零execute参数调用pthread_cleanup_pop时 如果execute参数设置为0，清理函数不被调用，并且删除上次安装的处理程序 8.3.5 pthread_detach默认情况下，线程的终止状态会保存直到对该线程调用pthread_join。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被回收。在线程处于分离态调用pthread_join会产生未定义行为 可以调用pthread_detach分离线程 c #include \u003cpthread.h\u003e int pthread_detach(pthread_t tid); //成功返回0，失败返回错误编号 这个方法是在线程创建后分离，还可以在创建线程时候设置属性 ","date":"2019-09-26","objectID":"/linux-system-programming/:8:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#83-线程终止"},{"categories":["program"],"content":" 8.3 线程终止如果进程中任意线程调用了exit，_Exit，_exit，那么整个进程就会终止 如果默认动作是终止进程，发送给线程的信号会终止整个进程 单个线程可以通过3种方式退出 线程可以简单地从启动例程中返回，返回值是线程退出码 被同一进程中的其他线程取消 线程调用pthread_exit 8.3.1 pthread_exit c #include void pthread_exit(void *rval_ptr) rval_ptr参数是一个无类型指针。其他线程也可以通过pthread_join函数访问到这个指针 8.3.2 pthread_join c #include int pthread_join(pthread_t thread, void **rval_ptr); //成功返回0，否则返回错误编号 调用线程将一直阻塞，直到指定的线程调用pthread_exit，从启动例程返回或被取消。 如果线程简单地从启动例程返回，rval_ptr就包含返回码。不关心可以穿NULL 如果线程被取消，有rval_ptr指定的内存单元就设置为PTHREAD_CANCELED 调用函数可以回收线程的资源，前提线程不能是分离态，否则返回EINVAL 8.3.3 pthread_cancel线程可以调用pthread_cancel函数来请求取消同一进程中其他线程 c #include int pthread_cancel(pthread_t tid); //成功返回0，否则返回错误码 默认情况下pthread_cancel函数会使得有tid表示的线程行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit 函数 但是线程可以选择忽略取消或控制如何被取消，pthread_cancel并不等待线程终止，只提出请求 8.3.4 安装清理函数线程可以安排他退出时需要调用的函数，与进程的atexit函数类似 这样的函数叫做线程清理处理程序，可以建立多个，记录在栈中 c #include void pthread_cleanup_push(void (*rtn)(void *), void *arg); void pthread_cleanup_pop(int execute); 只有当线程执行以下动作时，清理函数是由pthread_clean_push函数调度的，调用时只有一个参数arg 调用pthread_exit时 相应取消请求时 用非零execute参数调用pthread_cleanup_pop时 如果execute参数设置为0，清理函数不被调用，并且删除上次安装的处理程序 8.3.5 pthread_detach默认情况下，线程的终止状态会保存直到对该线程调用pthread_join。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被回收。在线程处于分离态调用pthread_join会产生未定义行为 可以调用pthread_detach分离线程 c #include int pthread_detach(pthread_t tid); //成功返回0，失败返回错误编号 这个方法是在线程创建后分离，还可以在创建线程时候设置属性 ","date":"2019-09-26","objectID":"/linux-system-programming/:8:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#831-pthread_exit"},{"categories":["program"],"content":" 8.3 线程终止如果进程中任意线程调用了exit，_Exit，_exit，那么整个进程就会终止 如果默认动作是终止进程，发送给线程的信号会终止整个进程 单个线程可以通过3种方式退出 线程可以简单地从启动例程中返回，返回值是线程退出码 被同一进程中的其他线程取消 线程调用pthread_exit 8.3.1 pthread_exit c #include void pthread_exit(void *rval_ptr) rval_ptr参数是一个无类型指针。其他线程也可以通过pthread_join函数访问到这个指针 8.3.2 pthread_join c #include int pthread_join(pthread_t thread, void **rval_ptr); //成功返回0，否则返回错误编号 调用线程将一直阻塞，直到指定的线程调用pthread_exit，从启动例程返回或被取消。 如果线程简单地从启动例程返回，rval_ptr就包含返回码。不关心可以穿NULL 如果线程被取消，有rval_ptr指定的内存单元就设置为PTHREAD_CANCELED 调用函数可以回收线程的资源，前提线程不能是分离态，否则返回EINVAL 8.3.3 pthread_cancel线程可以调用pthread_cancel函数来请求取消同一进程中其他线程 c #include int pthread_cancel(pthread_t tid); //成功返回0，否则返回错误码 默认情况下pthread_cancel函数会使得有tid表示的线程行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit 函数 但是线程可以选择忽略取消或控制如何被取消，pthread_cancel并不等待线程终止，只提出请求 8.3.4 安装清理函数线程可以安排他退出时需要调用的函数，与进程的atexit函数类似 这样的函数叫做线程清理处理程序，可以建立多个，记录在栈中 c #include void pthread_cleanup_push(void (*rtn)(void *), void *arg); void pthread_cleanup_pop(int execute); 只有当线程执行以下动作时，清理函数是由pthread_clean_push函数调度的，调用时只有一个参数arg 调用pthread_exit时 相应取消请求时 用非零execute参数调用pthread_cleanup_pop时 如果execute参数设置为0，清理函数不被调用，并且删除上次安装的处理程序 8.3.5 pthread_detach默认情况下，线程的终止状态会保存直到对该线程调用pthread_join。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被回收。在线程处于分离态调用pthread_join会产生未定义行为 可以调用pthread_detach分离线程 c #include int pthread_detach(pthread_t tid); //成功返回0，失败返回错误编号 这个方法是在线程创建后分离，还可以在创建线程时候设置属性 ","date":"2019-09-26","objectID":"/linux-system-programming/:8:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#832-pthread_join"},{"categories":["program"],"content":" 8.3 线程终止如果进程中任意线程调用了exit，_Exit，_exit，那么整个进程就会终止 如果默认动作是终止进程，发送给线程的信号会终止整个进程 单个线程可以通过3种方式退出 线程可以简单地从启动例程中返回，返回值是线程退出码 被同一进程中的其他线程取消 线程调用pthread_exit 8.3.1 pthread_exit c #include void pthread_exit(void *rval_ptr) rval_ptr参数是一个无类型指针。其他线程也可以通过pthread_join函数访问到这个指针 8.3.2 pthread_join c #include int pthread_join(pthread_t thread, void **rval_ptr); //成功返回0，否则返回错误编号 调用线程将一直阻塞，直到指定的线程调用pthread_exit，从启动例程返回或被取消。 如果线程简单地从启动例程返回，rval_ptr就包含返回码。不关心可以穿NULL 如果线程被取消，有rval_ptr指定的内存单元就设置为PTHREAD_CANCELED 调用函数可以回收线程的资源，前提线程不能是分离态，否则返回EINVAL 8.3.3 pthread_cancel线程可以调用pthread_cancel函数来请求取消同一进程中其他线程 c #include int pthread_cancel(pthread_t tid); //成功返回0，否则返回错误码 默认情况下pthread_cancel函数会使得有tid表示的线程行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit 函数 但是线程可以选择忽略取消或控制如何被取消，pthread_cancel并不等待线程终止，只提出请求 8.3.4 安装清理函数线程可以安排他退出时需要调用的函数，与进程的atexit函数类似 这样的函数叫做线程清理处理程序，可以建立多个，记录在栈中 c #include void pthread_cleanup_push(void (*rtn)(void *), void *arg); void pthread_cleanup_pop(int execute); 只有当线程执行以下动作时，清理函数是由pthread_clean_push函数调度的，调用时只有一个参数arg 调用pthread_exit时 相应取消请求时 用非零execute参数调用pthread_cleanup_pop时 如果execute参数设置为0，清理函数不被调用，并且删除上次安装的处理程序 8.3.5 pthread_detach默认情况下，线程的终止状态会保存直到对该线程调用pthread_join。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被回收。在线程处于分离态调用pthread_join会产生未定义行为 可以调用pthread_detach分离线程 c #include int pthread_detach(pthread_t tid); //成功返回0，失败返回错误编号 这个方法是在线程创建后分离，还可以在创建线程时候设置属性 ","date":"2019-09-26","objectID":"/linux-system-programming/:8:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#833-pthread_cancel"},{"categories":["program"],"content":" 8.3 线程终止如果进程中任意线程调用了exit，_Exit，_exit，那么整个进程就会终止 如果默认动作是终止进程，发送给线程的信号会终止整个进程 单个线程可以通过3种方式退出 线程可以简单地从启动例程中返回，返回值是线程退出码 被同一进程中的其他线程取消 线程调用pthread_exit 8.3.1 pthread_exit c #include void pthread_exit(void *rval_ptr) rval_ptr参数是一个无类型指针。其他线程也可以通过pthread_join函数访问到这个指针 8.3.2 pthread_join c #include int pthread_join(pthread_t thread, void **rval_ptr); //成功返回0，否则返回错误编号 调用线程将一直阻塞，直到指定的线程调用pthread_exit，从启动例程返回或被取消。 如果线程简单地从启动例程返回，rval_ptr就包含返回码。不关心可以穿NULL 如果线程被取消，有rval_ptr指定的内存单元就设置为PTHREAD_CANCELED 调用函数可以回收线程的资源，前提线程不能是分离态，否则返回EINVAL 8.3.3 pthread_cancel线程可以调用pthread_cancel函数来请求取消同一进程中其他线程 c #include int pthread_cancel(pthread_t tid); //成功返回0，否则返回错误码 默认情况下pthread_cancel函数会使得有tid表示的线程行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit 函数 但是线程可以选择忽略取消或控制如何被取消，pthread_cancel并不等待线程终止，只提出请求 8.3.4 安装清理函数线程可以安排他退出时需要调用的函数，与进程的atexit函数类似 这样的函数叫做线程清理处理程序，可以建立多个，记录在栈中 c #include void pthread_cleanup_push(void (*rtn)(void *), void *arg); void pthread_cleanup_pop(int execute); 只有当线程执行以下动作时，清理函数是由pthread_clean_push函数调度的，调用时只有一个参数arg 调用pthread_exit时 相应取消请求时 用非零execute参数调用pthread_cleanup_pop时 如果execute参数设置为0，清理函数不被调用，并且删除上次安装的处理程序 8.3.5 pthread_detach默认情况下，线程的终止状态会保存直到对该线程调用pthread_join。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被回收。在线程处于分离态调用pthread_join会产生未定义行为 可以调用pthread_detach分离线程 c #include int pthread_detach(pthread_t tid); //成功返回0，失败返回错误编号 这个方法是在线程创建后分离，还可以在创建线程时候设置属性 ","date":"2019-09-26","objectID":"/linux-system-programming/:8:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#834-安装清理函数"},{"categories":["program"],"content":" 8.3 线程终止如果进程中任意线程调用了exit，_Exit，_exit，那么整个进程就会终止 如果默认动作是终止进程，发送给线程的信号会终止整个进程 单个线程可以通过3种方式退出 线程可以简单地从启动例程中返回，返回值是线程退出码 被同一进程中的其他线程取消 线程调用pthread_exit 8.3.1 pthread_exit c #include void pthread_exit(void *rval_ptr) rval_ptr参数是一个无类型指针。其他线程也可以通过pthread_join函数访问到这个指针 8.3.2 pthread_join c #include int pthread_join(pthread_t thread, void **rval_ptr); //成功返回0，否则返回错误编号 调用线程将一直阻塞，直到指定的线程调用pthread_exit，从启动例程返回或被取消。 如果线程简单地从启动例程返回，rval_ptr就包含返回码。不关心可以穿NULL 如果线程被取消，有rval_ptr指定的内存单元就设置为PTHREAD_CANCELED 调用函数可以回收线程的资源，前提线程不能是分离态，否则返回EINVAL 8.3.3 pthread_cancel线程可以调用pthread_cancel函数来请求取消同一进程中其他线程 c #include int pthread_cancel(pthread_t tid); //成功返回0，否则返回错误码 默认情况下pthread_cancel函数会使得有tid表示的线程行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit 函数 但是线程可以选择忽略取消或控制如何被取消，pthread_cancel并不等待线程终止，只提出请求 8.3.4 安装清理函数线程可以安排他退出时需要调用的函数，与进程的atexit函数类似 这样的函数叫做线程清理处理程序，可以建立多个，记录在栈中 c #include void pthread_cleanup_push(void (*rtn)(void *), void *arg); void pthread_cleanup_pop(int execute); 只有当线程执行以下动作时，清理函数是由pthread_clean_push函数调度的，调用时只有一个参数arg 调用pthread_exit时 相应取消请求时 用非零execute参数调用pthread_cleanup_pop时 如果execute参数设置为0，清理函数不被调用，并且删除上次安装的处理程序 8.3.5 pthread_detach默认情况下，线程的终止状态会保存直到对该线程调用pthread_join。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被回收。在线程处于分离态调用pthread_join会产生未定义行为 可以调用pthread_detach分离线程 c #include int pthread_detach(pthread_t tid); //成功返回0，失败返回错误编号 这个方法是在线程创建后分离，还可以在创建线程时候设置属性 ","date":"2019-09-26","objectID":"/linux-system-programming/:8:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#835-pthread_detach"},{"categories":["program"],"content":" 8.4 线程属性pthread_create的第二个参数不为NULL时，为指定线程的属性 这个参数的初始化和释放由下面函数控制 c #include \u003cpthread.h\u003e int pthread_attr_init(pthread_attr_t *attr); int pthread_attr_destory(pthread_attr_t *attr); //成功返回0，失败返回错误编号 POSIX.1定义了线程属性 shell detachstate #线程分离状态属性 guardsize #线程栈末尾的警戒缓冲区大小 stackaddr #线程栈的最低地址 stacksize #线程栈的最小长度 如果要线程在创建时就处于分离态，下面函数设置detachstate属性 c #include \u003cpthread.h\u003e int pthread_attr_getdetachstate(const pthread_attr_t *restrict attr, int *detachstate); int pthread_attr_setdetachstate(pthread_attr_t *attr, int *detachstate); //成功返回0，失败返回错误编号 detachstate参数取PTHREAD_CREATE_DETACHED或PTHREAD_CREATE_JOINABLE ","date":"2019-09-26","objectID":"/linux-system-programming/:8:4","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#84-线程属性"},{"categories":["program"],"content":" 8.5 线程同步当多个控制线程共享相同的内存时，要保证每个线程看到一致的数据视图。如果每个进程使用的变量都是其它线程不会读取的，那么就不存在一致性问题。同样如果变量是只读的，多个线程同时读取也没有问题。但是当一个线程可以修改的变量，其他线程也可以读取或修改，就需要对这些线程进行同步。 8.5.1 互斥量可以使用pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。 互斥量（mutex）本质是一把锁。 互斥变量用pthread_mutex_t数据类型表示。使用前必须初始化。 可以把它设置为常量PTHREAD_MUTEX_INITIALIZER（只适用于与静态分配的互斥量）。 也可以通过调用函数初始化。在释放内存前要调用pthread_mutex_destroy(动态分配) c #include \u003cpthread.h\u003e int pthread_mutex_init(pthread_mutex_t *restirct mutex, const pthread_mutexattr_t *restrict attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 要使用默认属性初始化互斥量，attr参数用NULL 互斥量的使用 c #include \u003cpthread.h\u003e int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 pthread_mutex_lock对互斥量加锁，如果互斥量已经上锁，调用线程阻塞直到互斥量被解锁 pthread_mutex_trylock加锁的非阻塞版本，不能加锁返回EBUSY 注意避免死锁 C #include \u003cpthread.h\u003e #include \u003ctime.h\u003e int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 设置超时的方式加锁 超时返回ETIMEDOUT 8.5.2 读写锁使用之前初始化，底层内存释放前必须销毁 c #include \u003cpthread.h\u003e int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 使用默认属性初始化attr传NULL 操作读写锁 c #include \u003cpthread.h\u003e int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 非阻塞方式 c #include \u003cpthread.h\u003e int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 不能得到锁返回EBUSY 带有超时的方式 c #include \u003cpthread.h\u003e #include \u003ctime.h\u003e int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 超时返回ETIMEDOUT 8.5.3 条件变量条件变量与互斥量一起使用时，运行进程以无竞争的方式等待特定条件发生。 初始化 静态初始化可以把常量PTHREAD_COND_INITIALIZER付给条件变量 动态分配使用函数初始化，在底层内存释放前destroy c #include \u003cpthread.h\u003e int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int phtread_cond_destroy(pthread_cond_t *cond); //成功返回0，否则返回错误编号 使用默认属性创建，addr参数穿NULL。 等待条件 c #include \u003cpthread.h\u003e #include \u003ctime.h\u003e int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 把锁住的互斥量传给函数，函数把线程放到等待条件变量的列表上，然后解锁互斥量。休眠等待条件 返回时互斥量再次被锁住。 通知条件满足 c #include \u003cpthread.h\u003e int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); //成功返回0，否则返回错误编号 通知等待条件的线程，signal唤醒至少一个，broadcast唤醒所有（顺序唤醒，因为等待线程返回时要给互斥量重新上锁） 一个栗子 c #include \u003cpthread.h\u003e struct msg { struct msg *m_next; /* ... more stuff here ... */ }; struct msg *workq; pthread_cond_t qready = PTHREAD_COND_INITIALIZER; pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER; void process_msg(void) { struct msg *mp; while (1) { pthread_mutex_lock(\u0026qlock); while (workq == NULL) pthread_cond_wait(\u0026qready, \u0026qlock); //消息队列没有消息就一直等待 mp = workq; workq = mp-\u003em_next; //取消息 pthread_mutex_unlock(\u0026qlock); } } void enqueue_msg(struct msg *mp){ pthread_mutex_lock(\u0026qlock); mp-\u003em_next = workq; workq = mp; //发消息 pthread_mutex_unlock(\u0026qlock); pthread_cond_signal(\u0026qready); //通知有新消息 } 8.5.4 自旋锁自旋锁与互斥量类似，但他不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。 自旋锁可用于以下情况：锁被持有的时间段，而且线程并不希望在重新调度上花费太多成本 自旋锁通常作为底层原语用于实现其他类型的锁 有些互斥锁实现很高效，在获取锁时先自旋一段时间，等时间到达某一阀值才会休眠。 c #include \u003cpthread.h\u003e int pthread_spin_init(pthread_spinlock_t *lock, int pshared); int pthread_spin_destroy(pthread_spinlock_t *lock); //成功返回0，否则返回错误编号 只有一个属性，pshared取PTHREAD_PROCESS_SHARED则自旋锁能被可以访问锁底层内存的线程锁获取,即便那些线程属于不同进程 取PTHREAD_PROCESS_PRIVATE则自旋锁只能被初始化该锁的进程内部的线程所访问 使用 c #include \u003cpthread.h\u003e int pthread_spin_lock(pthread_spinlock_t *lock); int pthread_spin_trylock(pthread_spinlock_t *lock); int ","date":"2019-09-26","objectID":"/linux-system-programming/:8:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#85-线程同步"},{"categories":["program"],"content":" 8.5 线程同步当多个控制线程共享相同的内存时，要保证每个线程看到一致的数据视图。如果每个进程使用的变量都是其它线程不会读取的，那么就不存在一致性问题。同样如果变量是只读的，多个线程同时读取也没有问题。但是当一个线程可以修改的变量，其他线程也可以读取或修改，就需要对这些线程进行同步。 8.5.1 互斥量可以使用pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。 互斥量（mutex）本质是一把锁。 互斥变量用pthread_mutex_t数据类型表示。使用前必须初始化。 可以把它设置为常量PTHREAD_MUTEX_INITIALIZER（只适用于与静态分配的互斥量）。 也可以通过调用函数初始化。在释放内存前要调用pthread_mutex_destroy(动态分配) c #include int pthread_mutex_init(pthread_mutex_t *restirct mutex, const pthread_mutexattr_t *restrict attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 要使用默认属性初始化互斥量，attr参数用NULL 互斥量的使用 c #include int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 pthread_mutex_lock对互斥量加锁，如果互斥量已经上锁，调用线程阻塞直到互斥量被解锁 pthread_mutex_trylock加锁的非阻塞版本，不能加锁返回EBUSY 注意避免死锁 C #include #include int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 设置超时的方式加锁 超时返回ETIMEDOUT 8.5.2 读写锁使用之前初始化，底层内存释放前必须销毁 c #include int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 使用默认属性初始化attr传NULL 操作读写锁 c #include int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 非阻塞方式 c #include int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 不能得到锁返回EBUSY 带有超时的方式 c #include #include int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 超时返回ETIMEDOUT 8.5.3 条件变量条件变量与互斥量一起使用时，运行进程以无竞争的方式等待特定条件发生。 初始化 静态初始化可以把常量PTHREAD_COND_INITIALIZER付给条件变量 动态分配使用函数初始化，在底层内存释放前destroy c #include int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int phtread_cond_destroy(pthread_cond_t *cond); //成功返回0，否则返回错误编号 使用默认属性创建，addr参数穿NULL。 等待条件 c #include #include int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 把锁住的互斥量传给函数，函数把线程放到等待条件变量的列表上，然后解锁互斥量。休眠等待条件 返回时互斥量再次被锁住。 通知条件满足 c #include int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); //成功返回0，否则返回错误编号 通知等待条件的线程，signal唤醒至少一个，broadcast唤醒所有（顺序唤醒，因为等待线程返回时要给互斥量重新上锁） 一个栗子 c #include struct msg { struct msg *m_next; /* ... more stuff here ... */ }; struct msg *workq; pthread_cond_t qready = PTHREAD_COND_INITIALIZER; pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER; void process_msg(void) { struct msg *mp; while (1) { pthread_mutex_lock(\u0026qlock); while (workq == NULL) pthread_cond_wait(\u0026qready, \u0026qlock); //消息队列没有消息就一直等待 mp = workq; workq = mp-\u003em_next; //取消息 pthread_mutex_unlock(\u0026qlock); } } void enqueue_msg(struct msg *mp){ pthread_mutex_lock(\u0026qlock); mp-\u003em_next = workq; workq = mp; //发消息 pthread_mutex_unlock(\u0026qlock); pthread_cond_signal(\u0026qready); //通知有新消息 } 8.5.4 自旋锁自旋锁与互斥量类似，但他不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。 自旋锁可用于以下情况：锁被持有的时间段，而且线程并不希望在重新调度上花费太多成本 自旋锁通常作为底层原语用于实现其他类型的锁 有些互斥锁实现很高效，在获取锁时先自旋一段时间，等时间到达某一阀值才会休眠。 c #include int pthread_spin_init(pthread_spinlock_t *lock, int pshared); int pthread_spin_destroy(pthread_spinlock_t *lock); //成功返回0，否则返回错误编号 只有一个属性，pshared取PTHREAD_PROCESS_SHARED则自旋锁能被可以访问锁底层内存的线程锁获取,即便那些线程属于不同进程 取PTHREAD_PROCESS_PRIVATE则自旋锁只能被初始化该锁的进程内部的线程所访问 使用 c #include int pthread_spin_lock(pthread_spinlock_t *lock); int pthread_spin_trylock(pthread_spinlock_t *lock); int ","date":"2019-09-26","objectID":"/linux-system-programming/:8:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#851-互斥量"},{"categories":["program"],"content":" 8.5 线程同步当多个控制线程共享相同的内存时，要保证每个线程看到一致的数据视图。如果每个进程使用的变量都是其它线程不会读取的，那么就不存在一致性问题。同样如果变量是只读的，多个线程同时读取也没有问题。但是当一个线程可以修改的变量，其他线程也可以读取或修改，就需要对这些线程进行同步。 8.5.1 互斥量可以使用pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。 互斥量（mutex）本质是一把锁。 互斥变量用pthread_mutex_t数据类型表示。使用前必须初始化。 可以把它设置为常量PTHREAD_MUTEX_INITIALIZER（只适用于与静态分配的互斥量）。 也可以通过调用函数初始化。在释放内存前要调用pthread_mutex_destroy(动态分配) c #include int pthread_mutex_init(pthread_mutex_t *restirct mutex, const pthread_mutexattr_t *restrict attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 要使用默认属性初始化互斥量，attr参数用NULL 互斥量的使用 c #include int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 pthread_mutex_lock对互斥量加锁，如果互斥量已经上锁，调用线程阻塞直到互斥量被解锁 pthread_mutex_trylock加锁的非阻塞版本，不能加锁返回EBUSY 注意避免死锁 C #include #include int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 设置超时的方式加锁 超时返回ETIMEDOUT 8.5.2 读写锁使用之前初始化，底层内存释放前必须销毁 c #include int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 使用默认属性初始化attr传NULL 操作读写锁 c #include int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 非阻塞方式 c #include int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 不能得到锁返回EBUSY 带有超时的方式 c #include #include int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 超时返回ETIMEDOUT 8.5.3 条件变量条件变量与互斥量一起使用时，运行进程以无竞争的方式等待特定条件发生。 初始化 静态初始化可以把常量PTHREAD_COND_INITIALIZER付给条件变量 动态分配使用函数初始化，在底层内存释放前destroy c #include int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int phtread_cond_destroy(pthread_cond_t *cond); //成功返回0，否则返回错误编号 使用默认属性创建，addr参数穿NULL。 等待条件 c #include #include int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 把锁住的互斥量传给函数，函数把线程放到等待条件变量的列表上，然后解锁互斥量。休眠等待条件 返回时互斥量再次被锁住。 通知条件满足 c #include int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); //成功返回0，否则返回错误编号 通知等待条件的线程，signal唤醒至少一个，broadcast唤醒所有（顺序唤醒，因为等待线程返回时要给互斥量重新上锁） 一个栗子 c #include struct msg { struct msg *m_next; /* ... more stuff here ... */ }; struct msg *workq; pthread_cond_t qready = PTHREAD_COND_INITIALIZER; pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER; void process_msg(void) { struct msg *mp; while (1) { pthread_mutex_lock(\u0026qlock); while (workq == NULL) pthread_cond_wait(\u0026qready, \u0026qlock); //消息队列没有消息就一直等待 mp = workq; workq = mp-\u003em_next; //取消息 pthread_mutex_unlock(\u0026qlock); } } void enqueue_msg(struct msg *mp){ pthread_mutex_lock(\u0026qlock); mp-\u003em_next = workq; workq = mp; //发消息 pthread_mutex_unlock(\u0026qlock); pthread_cond_signal(\u0026qready); //通知有新消息 } 8.5.4 自旋锁自旋锁与互斥量类似，但他不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。 自旋锁可用于以下情况：锁被持有的时间段，而且线程并不希望在重新调度上花费太多成本 自旋锁通常作为底层原语用于实现其他类型的锁 有些互斥锁实现很高效，在获取锁时先自旋一段时间，等时间到达某一阀值才会休眠。 c #include int pthread_spin_init(pthread_spinlock_t *lock, int pshared); int pthread_spin_destroy(pthread_spinlock_t *lock); //成功返回0，否则返回错误编号 只有一个属性，pshared取PTHREAD_PROCESS_SHARED则自旋锁能被可以访问锁底层内存的线程锁获取,即便那些线程属于不同进程 取PTHREAD_PROCESS_PRIVATE则自旋锁只能被初始化该锁的进程内部的线程所访问 使用 c #include int pthread_spin_lock(pthread_spinlock_t *lock); int pthread_spin_trylock(pthread_spinlock_t *lock); int ","date":"2019-09-26","objectID":"/linux-system-programming/:8:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#852-读写锁"},{"categories":["program"],"content":" 8.5 线程同步当多个控制线程共享相同的内存时，要保证每个线程看到一致的数据视图。如果每个进程使用的变量都是其它线程不会读取的，那么就不存在一致性问题。同样如果变量是只读的，多个线程同时读取也没有问题。但是当一个线程可以修改的变量，其他线程也可以读取或修改，就需要对这些线程进行同步。 8.5.1 互斥量可以使用pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。 互斥量（mutex）本质是一把锁。 互斥变量用pthread_mutex_t数据类型表示。使用前必须初始化。 可以把它设置为常量PTHREAD_MUTEX_INITIALIZER（只适用于与静态分配的互斥量）。 也可以通过调用函数初始化。在释放内存前要调用pthread_mutex_destroy(动态分配) c #include int pthread_mutex_init(pthread_mutex_t *restirct mutex, const pthread_mutexattr_t *restrict attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 要使用默认属性初始化互斥量，attr参数用NULL 互斥量的使用 c #include int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 pthread_mutex_lock对互斥量加锁，如果互斥量已经上锁，调用线程阻塞直到互斥量被解锁 pthread_mutex_trylock加锁的非阻塞版本，不能加锁返回EBUSY 注意避免死锁 C #include #include int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 设置超时的方式加锁 超时返回ETIMEDOUT 8.5.2 读写锁使用之前初始化，底层内存释放前必须销毁 c #include int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 使用默认属性初始化attr传NULL 操作读写锁 c #include int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 非阻塞方式 c #include int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 不能得到锁返回EBUSY 带有超时的方式 c #include #include int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 超时返回ETIMEDOUT 8.5.3 条件变量条件变量与互斥量一起使用时，运行进程以无竞争的方式等待特定条件发生。 初始化 静态初始化可以把常量PTHREAD_COND_INITIALIZER付给条件变量 动态分配使用函数初始化，在底层内存释放前destroy c #include int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int phtread_cond_destroy(pthread_cond_t *cond); //成功返回0，否则返回错误编号 使用默认属性创建，addr参数穿NULL。 等待条件 c #include #include int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 把锁住的互斥量传给函数，函数把线程放到等待条件变量的列表上，然后解锁互斥量。休眠等待条件 返回时互斥量再次被锁住。 通知条件满足 c #include int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); //成功返回0，否则返回错误编号 通知等待条件的线程，signal唤醒至少一个，broadcast唤醒所有（顺序唤醒，因为等待线程返回时要给互斥量重新上锁） 一个栗子 c #include struct msg { struct msg *m_next; /* ... more stuff here ... */ }; struct msg *workq; pthread_cond_t qready = PTHREAD_COND_INITIALIZER; pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER; void process_msg(void) { struct msg *mp; while (1) { pthread_mutex_lock(\u0026qlock); while (workq == NULL) pthread_cond_wait(\u0026qready, \u0026qlock); //消息队列没有消息就一直等待 mp = workq; workq = mp-\u003em_next; //取消息 pthread_mutex_unlock(\u0026qlock); } } void enqueue_msg(struct msg *mp){ pthread_mutex_lock(\u0026qlock); mp-\u003em_next = workq; workq = mp; //发消息 pthread_mutex_unlock(\u0026qlock); pthread_cond_signal(\u0026qready); //通知有新消息 } 8.5.4 自旋锁自旋锁与互斥量类似，但他不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。 自旋锁可用于以下情况：锁被持有的时间段，而且线程并不希望在重新调度上花费太多成本 自旋锁通常作为底层原语用于实现其他类型的锁 有些互斥锁实现很高效，在获取锁时先自旋一段时间，等时间到达某一阀值才会休眠。 c #include int pthread_spin_init(pthread_spinlock_t *lock, int pshared); int pthread_spin_destroy(pthread_spinlock_t *lock); //成功返回0，否则返回错误编号 只有一个属性，pshared取PTHREAD_PROCESS_SHARED则自旋锁能被可以访问锁底层内存的线程锁获取,即便那些线程属于不同进程 取PTHREAD_PROCESS_PRIVATE则自旋锁只能被初始化该锁的进程内部的线程所访问 使用 c #include int pthread_spin_lock(pthread_spinlock_t *lock); int pthread_spin_trylock(pthread_spinlock_t *lock); int ","date":"2019-09-26","objectID":"/linux-system-programming/:8:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#853-条件变量"},{"categories":["program"],"content":" 8.5 线程同步当多个控制线程共享相同的内存时，要保证每个线程看到一致的数据视图。如果每个进程使用的变量都是其它线程不会读取的，那么就不存在一致性问题。同样如果变量是只读的，多个线程同时读取也没有问题。但是当一个线程可以修改的变量，其他线程也可以读取或修改，就需要对这些线程进行同步。 8.5.1 互斥量可以使用pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。 互斥量（mutex）本质是一把锁。 互斥变量用pthread_mutex_t数据类型表示。使用前必须初始化。 可以把它设置为常量PTHREAD_MUTEX_INITIALIZER（只适用于与静态分配的互斥量）。 也可以通过调用函数初始化。在释放内存前要调用pthread_mutex_destroy(动态分配) c #include int pthread_mutex_init(pthread_mutex_t *restirct mutex, const pthread_mutexattr_t *restrict attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 要使用默认属性初始化互斥量，attr参数用NULL 互斥量的使用 c #include int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 pthread_mutex_lock对互斥量加锁，如果互斥量已经上锁，调用线程阻塞直到互斥量被解锁 pthread_mutex_trylock加锁的非阻塞版本，不能加锁返回EBUSY 注意避免死锁 C #include #include int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 设置超时的方式加锁 超时返回ETIMEDOUT 8.5.2 读写锁使用之前初始化，底层内存释放前必须销毁 c #include int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 使用默认属性初始化attr传NULL 操作读写锁 c #include int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 非阻塞方式 c #include int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 不能得到锁返回EBUSY 带有超时的方式 c #include #include int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 超时返回ETIMEDOUT 8.5.3 条件变量条件变量与互斥量一起使用时，运行进程以无竞争的方式等待特定条件发生。 初始化 静态初始化可以把常量PTHREAD_COND_INITIALIZER付给条件变量 动态分配使用函数初始化，在底层内存释放前destroy c #include int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int phtread_cond_destroy(pthread_cond_t *cond); //成功返回0，否则返回错误编号 使用默认属性创建，addr参数穿NULL。 等待条件 c #include #include int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 把锁住的互斥量传给函数，函数把线程放到等待条件变量的列表上，然后解锁互斥量。休眠等待条件 返回时互斥量再次被锁住。 通知条件满足 c #include int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); //成功返回0，否则返回错误编号 通知等待条件的线程，signal唤醒至少一个，broadcast唤醒所有（顺序唤醒，因为等待线程返回时要给互斥量重新上锁） 一个栗子 c #include struct msg { struct msg *m_next; /* ... more stuff here ... */ }; struct msg *workq; pthread_cond_t qready = PTHREAD_COND_INITIALIZER; pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER; void process_msg(void) { struct msg *mp; while (1) { pthread_mutex_lock(\u0026qlock); while (workq == NULL) pthread_cond_wait(\u0026qready, \u0026qlock); //消息队列没有消息就一直等待 mp = workq; workq = mp-\u003em_next; //取消息 pthread_mutex_unlock(\u0026qlock); } } void enqueue_msg(struct msg *mp){ pthread_mutex_lock(\u0026qlock); mp-\u003em_next = workq; workq = mp; //发消息 pthread_mutex_unlock(\u0026qlock); pthread_cond_signal(\u0026qready); //通知有新消息 } 8.5.4 自旋锁自旋锁与互斥量类似，但他不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。 自旋锁可用于以下情况：锁被持有的时间段，而且线程并不希望在重新调度上花费太多成本 自旋锁通常作为底层原语用于实现其他类型的锁 有些互斥锁实现很高效，在获取锁时先自旋一段时间，等时间到达某一阀值才会休眠。 c #include int pthread_spin_init(pthread_spinlock_t *lock, int pshared); int pthread_spin_destroy(pthread_spinlock_t *lock); //成功返回0，否则返回错误编号 只有一个属性，pshared取PTHREAD_PROCESS_SHARED则自旋锁能被可以访问锁底层内存的线程锁获取,即便那些线程属于不同进程 取PTHREAD_PROCESS_PRIVATE则自旋锁只能被初始化该锁的进程内部的线程所访问 使用 c #include int pthread_spin_lock(pthread_spinlock_t *lock); int pthread_spin_trylock(pthread_spinlock_t *lock); int ","date":"2019-09-26","objectID":"/linux-system-programming/:8:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#854-自旋锁"},{"categories":["program"],"content":" 8.5 线程同步当多个控制线程共享相同的内存时，要保证每个线程看到一致的数据视图。如果每个进程使用的变量都是其它线程不会读取的，那么就不存在一致性问题。同样如果变量是只读的，多个线程同时读取也没有问题。但是当一个线程可以修改的变量，其他线程也可以读取或修改，就需要对这些线程进行同步。 8.5.1 互斥量可以使用pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。 互斥量（mutex）本质是一把锁。 互斥变量用pthread_mutex_t数据类型表示。使用前必须初始化。 可以把它设置为常量PTHREAD_MUTEX_INITIALIZER（只适用于与静态分配的互斥量）。 也可以通过调用函数初始化。在释放内存前要调用pthread_mutex_destroy(动态分配) c #include int pthread_mutex_init(pthread_mutex_t *restirct mutex, const pthread_mutexattr_t *restrict attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 要使用默认属性初始化互斥量，attr参数用NULL 互斥量的使用 c #include int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 pthread_mutex_lock对互斥量加锁，如果互斥量已经上锁，调用线程阻塞直到互斥量被解锁 pthread_mutex_trylock加锁的非阻塞版本，不能加锁返回EBUSY 注意避免死锁 C #include #include int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 设置超时的方式加锁 超时返回ETIMEDOUT 8.5.2 读写锁使用之前初始化，底层内存释放前必须销毁 c #include int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 使用默认属性初始化attr传NULL 操作读写锁 c #include int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 非阻塞方式 c #include int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 不能得到锁返回EBUSY 带有超时的方式 c #include #include int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 超时返回ETIMEDOUT 8.5.3 条件变量条件变量与互斥量一起使用时，运行进程以无竞争的方式等待特定条件发生。 初始化 静态初始化可以把常量PTHREAD_COND_INITIALIZER付给条件变量 动态分配使用函数初始化，在底层内存释放前destroy c #include int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int phtread_cond_destroy(pthread_cond_t *cond); //成功返回0，否则返回错误编号 使用默认属性创建，addr参数穿NULL。 等待条件 c #include #include int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 把锁住的互斥量传给函数，函数把线程放到等待条件变量的列表上，然后解锁互斥量。休眠等待条件 返回时互斥量再次被锁住。 通知条件满足 c #include int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); //成功返回0，否则返回错误编号 通知等待条件的线程，signal唤醒至少一个，broadcast唤醒所有（顺序唤醒，因为等待线程返回时要给互斥量重新上锁） 一个栗子 c #include struct msg { struct msg *m_next; /* ... more stuff here ... */ }; struct msg *workq; pthread_cond_t qready = PTHREAD_COND_INITIALIZER; pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER; void process_msg(void) { struct msg *mp; while (1) { pthread_mutex_lock(\u0026qlock); while (workq == NULL) pthread_cond_wait(\u0026qready, \u0026qlock); //消息队列没有消息就一直等待 mp = workq; workq = mp-\u003em_next; //取消息 pthread_mutex_unlock(\u0026qlock); } } void enqueue_msg(struct msg *mp){ pthread_mutex_lock(\u0026qlock); mp-\u003em_next = workq; workq = mp; //发消息 pthread_mutex_unlock(\u0026qlock); pthread_cond_signal(\u0026qready); //通知有新消息 } 8.5.4 自旋锁自旋锁与互斥量类似，但他不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。 自旋锁可用于以下情况：锁被持有的时间段，而且线程并不希望在重新调度上花费太多成本 自旋锁通常作为底层原语用于实现其他类型的锁 有些互斥锁实现很高效，在获取锁时先自旋一段时间，等时间到达某一阀值才会休眠。 c #include int pthread_spin_init(pthread_spinlock_t *lock, int pshared); int pthread_spin_destroy(pthread_spinlock_t *lock); //成功返回0，否则返回错误编号 只有一个属性，pshared取PTHREAD_PROCESS_SHARED则自旋锁能被可以访问锁底层内存的线程锁获取,即便那些线程属于不同进程 取PTHREAD_PROCESS_PRIVATE则自旋锁只能被初始化该锁的进程内部的线程所访问 使用 c #include int pthread_spin_lock(pthread_spinlock_t *lock); int pthread_spin_trylock(pthread_spinlock_t *lock); int ","date":"2019-09-26","objectID":"/linux-system-programming/:8:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#855-屏障"},{"categories":["program"],"content":" 8.5 线程同步当多个控制线程共享相同的内存时，要保证每个线程看到一致的数据视图。如果每个进程使用的变量都是其它线程不会读取的，那么就不存在一致性问题。同样如果变量是只读的，多个线程同时读取也没有问题。但是当一个线程可以修改的变量，其他线程也可以读取或修改，就需要对这些线程进行同步。 8.5.1 互斥量可以使用pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。 互斥量（mutex）本质是一把锁。 互斥变量用pthread_mutex_t数据类型表示。使用前必须初始化。 可以把它设置为常量PTHREAD_MUTEX_INITIALIZER（只适用于与静态分配的互斥量）。 也可以通过调用函数初始化。在释放内存前要调用pthread_mutex_destroy(动态分配) c #include int pthread_mutex_init(pthread_mutex_t *restirct mutex, const pthread_mutexattr_t *restrict attr); int pthread_mutex_destroy(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 要使用默认属性初始化互斥量，attr参数用NULL 互斥量的使用 c #include int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); //成功返回0，否则返回错误编号 pthread_mutex_lock对互斥量加锁，如果互斥量已经上锁，调用线程阻塞直到互斥量被解锁 pthread_mutex_trylock加锁的非阻塞版本，不能加锁返回EBUSY 注意避免死锁 C #include #include int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 设置超时的方式加锁 超时返回ETIMEDOUT 8.5.2 读写锁使用之前初始化，底层内存释放前必须销毁 c #include int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 使用默认属性初始化attr传NULL 操作读写锁 c #include int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 非阻塞方式 c #include int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); //成功返回0，否则返回错误编号 不能得到锁返回EBUSY 带有超时的方式 c #include #include int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 超时返回ETIMEDOUT 8.5.3 条件变量条件变量与互斥量一起使用时，运行进程以无竞争的方式等待特定条件发生。 初始化 静态初始化可以把常量PTHREAD_COND_INITIALIZER付给条件变量 动态分配使用函数初始化，在底层内存释放前destroy c #include int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int phtread_cond_destroy(pthread_cond_t *cond); //成功返回0，否则返回错误编号 使用默认属性创建，addr参数穿NULL。 等待条件 c #include #include int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr); //成功返回0，否则返回错误编号 把锁住的互斥量传给函数，函数把线程放到等待条件变量的列表上，然后解锁互斥量。休眠等待条件 返回时互斥量再次被锁住。 通知条件满足 c #include int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); //成功返回0，否则返回错误编号 通知等待条件的线程，signal唤醒至少一个，broadcast唤醒所有（顺序唤醒，因为等待线程返回时要给互斥量重新上锁） 一个栗子 c #include struct msg { struct msg *m_next; /* ... more stuff here ... */ }; struct msg *workq; pthread_cond_t qready = PTHREAD_COND_INITIALIZER; pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER; void process_msg(void) { struct msg *mp; while (1) { pthread_mutex_lock(\u0026qlock); while (workq == NULL) pthread_cond_wait(\u0026qready, \u0026qlock); //消息队列没有消息就一直等待 mp = workq; workq = mp-\u003em_next; //取消息 pthread_mutex_unlock(\u0026qlock); } } void enqueue_msg(struct msg *mp){ pthread_mutex_lock(\u0026qlock); mp-\u003em_next = workq; workq = mp; //发消息 pthread_mutex_unlock(\u0026qlock); pthread_cond_signal(\u0026qready); //通知有新消息 } 8.5.4 自旋锁自旋锁与互斥量类似，但他不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。 自旋锁可用于以下情况：锁被持有的时间段，而且线程并不希望在重新调度上花费太多成本 自旋锁通常作为底层原语用于实现其他类型的锁 有些互斥锁实现很高效，在获取锁时先自旋一段时间，等时间到达某一阀值才会休眠。 c #include int pthread_spin_init(pthread_spinlock_t *lock, int pshared); int pthread_spin_destroy(pthread_spinlock_t *lock); //成功返回0，否则返回错误编号 只有一个属性，pshared取PTHREAD_PROCESS_SHARED则自旋锁能被可以访问锁底层内存的线程锁获取,即便那些线程属于不同进程 取PTHREAD_PROCESS_PRIVATE则自旋锁只能被初始化该锁的进程内部的线程所访问 使用 c #include int pthread_spin_lock(pthread_spinlock_t *lock); int pthread_spin_trylock(pthread_spinlock_t *lock); int ","date":"2019-09-26","objectID":"/linux-system-programming/:8:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#856-pthread_once"},{"categories":["program"],"content":" 9 网络IPC：套接字","date":"2019-09-26","objectID":"/linux-system-programming/:9:0","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#9-网络ipc套接字"},{"categories":["program"],"content":" 9.1 套接字描述符socket套接字是通信端点的抽象。类UNIX系统中套接字被当做一种文件描述符 许多处理文件的函数（如read/wirte）也可以用于处理套接字描述符。 套接字的创建 c #include \u003csys/socket.h\u003e int socket(int domain, int type, int protocol); //成功返回文件（套接字）描述符，出错返回-1 参数domain（域）确定通信的特性，包括地址格式 下面总结了POSIX.1指定的域，都已AF_开头，意为地址族（address family） shell AF_INET # IPv4因特网域 AF_INET6 # IPv6因特网域 AF_UNIX # UNIX域 AF_UPSPEC # 未指定 参数type确定套接字的类型，进一步确定通信特征，下面是POSIX.1定义的类型，在实现中可以自由增加其他类型的支持 bash SOCK_DGRAM # 固定长度的，无连接的，不可靠的报文传递 SOCK_STREAM # 有序的，可靠地，双向的，面向连接的字节流 SOCK_RAW # IP协议的数据报接口（在POSIX.1中为可选） SOCK_SEQPACKET # 固定长度的，有序的，可靠的，面向连接的报文传递 参数protocol通常是0，表示为给定的域和套接字类型选择默认协议。 在AF_INET中SOCK_STREAM默认TCP，SOCK_DGRAM默认UDP shell IPPROTO_IP # IPv4网际协议 IPPROTO_IPV6 # IPv6网际协议（在POSIX.1中为可选） IPPROTO_ICMP # 因特网控制报文协议 IPPROTO_RAW # 原始ip数据包协议（在POSIX.1中为可选） IPPROTO_TCP # 传输控制协议 IPPROTO_UDP # 用户数据报协议 套接字通信是双向的，可以用shutdown函数来禁止一个套接字的I/O c #include \u003csys/socket.h\u003e int shutdown(int sockfd, int how); //成功返回0，出错返回-1 参数how： shell SHUT_RD # 关闭读端 SHUT_WR # 关闭写端 SHUT_RDWR # 同时关闭读端写端 能够关闭（close）一个套接字，为何还要使用shutdown。 只有最后一个活动引用关闭时，close才释放网络端点。这意味着复制一个套接字（如dup），要直到关闭了最后 一个引用它的文件描述符才会释放这个套接字。而shutdown允许一个套接字处于不活动状态，和引用它的文件描述符数目无关。其次可以关闭套接字双向传输的一个方向。 ","date":"2019-09-26","objectID":"/linux-system-programming/:9:1","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#91-套接字描述符socket"},{"categories":["program"],"content":" 9.2 寻址 9.2.1 字节序字节序分为大端字节序和小端字节序 大端字节序： 是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。 小端字节序： 是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。 x86框架采用小端字节序，ARM架构启动时可以 设置大小端字节序。 网络字节序采用大端字节序。 字节序的转换： c #include \u003carpa/inet.h\u003e uint32_t htonl(uint32_t hostlong); uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint16_t netshort); h表示host，n表示network，l表示32位长整数，s表示16位短整数。 9.2.2 地址格式与IP转换很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。 在linux中的实现： c #include \u003csys/socket.h\u003e struct sockaddr { sa_family_t sa_family; /* 地址族 */ char sa_data[14]; /*地址值，实际可能更长*/ }; /*IPV4*/ struct sockaddr_in { __kernel_sa_family_t sin_family; /* AF_INET4 */ __be16 sin_port; /*端头号*/ struct in_addr sin_addr; /* IPv4 地址 */ /* 8字节填充 */ unsigned char __pad[__SOCK_SIZE__ ‐ sizeof(short int) ‐ sizeof(unsigned short int) ‐ sizeof(struct in_addr)]; }; struct in_addr { __be32 s_addr; }; /*IPV6*/ struct sockaddr_in6 { unsigned short int sin6_family; /*AF_INET6*/ __be16 sin6_port; /* 端口 # */ __be32 sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 地址 128bit*/ __u32 sin6_scope_id; /* scope id (new in RFC2553) */ }; struct in6_addr { union { __u8 u6_addr8[16]; __be16 u6_addr16[8]; __be32 u6_addr32[4]; } in6_u; #define s6_addr in6_u.u6_addr8 #define s6_addr16 in6_u.u6_addr16 #define s6_addr32 in6_u.u6_addr32 }; #define UNIX_PATH_MAX 108 /*本地socket通信*/ struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */ }; ipv4以及的ipv6点分十进制表达法与二进制整数之间的互转。 c #include \u003carpa/inet.h\u003e int inet_pton(int af, const char *src, void *dst); const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); //成功返回1，格式无效返回0，出错返回-1 inet_pton把字符串src转换成ip地址保存在 dst 中。该函数调用成功返回大于0的整数。 inet_ntop() 把网络字节序的ip地址 src 转换成字符串保存在 dst 中作为返回值返回，参数 size 为dst所包含的字节数。 af 用来指定要转换的ip属于什么协议族 栗子 c #include \u003carpa/inet.h\u003e #include \u003csys/socket.h\u003e #include \u003cstring.h\u003e int main(int argc, char** argv) { struct sockaddr_in sin; char buf[16]; memset(\u0026sin, 0, sizeof(sin)); sin.sin_family=AF_INET; sin.sin_port=htons(3001); inet_pton(AF_INET, \"192.168.1.111\", \u0026sin.sin_addr.s_addr); printf(\"%s\\n\", inet_ntop(AF_INET, \u0026sin.sin_addr, buf, sizeof(buf))); return 0; } 9.2.3 地址查询gethostbyname和gethostbyaddr被认为是过时的。 gethostbyname, gethostbyaddr是不可重入函数；已经被getaddrinfo, getnameinfo替代 c #include \u003csys/socket.h\u003e #include \u003cnetdb.h\u003e int getaddrinfo(const char *host, const char *service, const struct addrinfo *hint, struct addrinfo **res); //成功返回0，出错返回非0错误码 void freeaddrinfo(struct addrinfo *ai); hostname:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串) service：服务名可以是十进制的端口号（字符串），也可以是已定义的服务名称，如ftp、http等 hints：可以是一个空指针，也可以是一个指向某个addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。 result：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。必须用freeaddrinfo释放 hostname和service不能同时为NULL 出错不能使用perror或strerror来生成错误信息，而是调用gai_strerror将返回的错误码转换成错误消息 c #include \u003cnetdb.h\u003e const char *gai_strerror(int error); //返回错误信息字符串 addrinfo结构体定义至少包含以下成员 c struct addrinfo { int ai_flags; int ai_family; /* AF_INET,AF_INET6或者AF_UNSPEC */ int ai_socktype; /* SOCK_STREAM SOCK_DGRAM ... */ int ai_protocol; /* 一般填0 使用默认 */ socklen_t ai_addrlen; /* length in bytes of address*/ struct sockaddr *ai_addr; /* address */ char *ai_canonname; /* canonical name of host */ struct addrinfo *ai_next; /* next in list */ }; 可以提供一个可选的hint来选择符合条件的地址，包括ai_family,ai_flags,ai_protocol,ai_socktype，其余字段必须为0，ai_flags可以用 shell AI_ADDRCONFIG #查询配置的地址类型（ipv4或ipv6） AI_ALL #查找IPv4和IPv6地址（仅用于AI_V4MAPPED） AI_CANONNAME #需要一个规范的名字（与别名相对） AI_NUMERICHOST #以数字格式指定主机地址，不翻译 AI_NUMERICSERV #将服务指定为数字端口号，不翻译 AI_PASSIVE #套接字地址用于监听绑定 AI_V4MAPPED #如果没有找到IPv6地址，返回映射到IPv6格式的IPv4地址 getnameinfo函数将一个地址转换成一个主机名和一个服务名 c #include \u003csys/socket.h\u003e #include \u003cnetdb.h\u003e int getnameinfo(const struct sockaddr *addr, socklen_t alen, char *host, socklen_t hostlen, char *service, socklen_t ","date":"2019-09-26","objectID":"/linux-system-programming/:9:2","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#92-寻址"},{"categories":["program"],"content":" 9.2 寻址 9.2.1 字节序字节序分为大端字节序和小端字节序 大端字节序： 是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。 小端字节序： 是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。 x86框架采用小端字节序，ARM架构启动时可以 设置大小端字节序。 网络字节序采用大端字节序。 字节序的转换： c #include uint32_t htonl(uint32_t hostlong); uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint16_t netshort); h表示host，n表示network，l表示32位长整数，s表示16位短整数。 9.2.2 地址格式与IP转换很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。 在linux中的实现： c #include struct sockaddr { sa_family_t sa_family; /* 地址族 */ char sa_data[14]; /*地址值，实际可能更长*/ }; /*IPV4*/ struct sockaddr_in { __kernel_sa_family_t sin_family; /* AF_INET4 */ __be16 sin_port; /*端头号*/ struct in_addr sin_addr; /* IPv4 地址 */ /* 8字节填充 */ unsigned char __pad[__SOCK_SIZE__ ‐ sizeof(short int) ‐ sizeof(unsigned short int) ‐ sizeof(struct in_addr)]; }; struct in_addr { __be32 s_addr; }; /*IPV6*/ struct sockaddr_in6 { unsigned short int sin6_family; /*AF_INET6*/ __be16 sin6_port; /* 端口 # */ __be32 sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 地址 128bit*/ __u32 sin6_scope_id; /* scope id (new in RFC2553) */ }; struct in6_addr { union { __u8 u6_addr8[16]; __be16 u6_addr16[8]; __be32 u6_addr32[4]; } in6_u; #define s6_addr in6_u.u6_addr8 #define s6_addr16 in6_u.u6_addr16 #define s6_addr32 in6_u.u6_addr32 }; #define UNIX_PATH_MAX 108 /*本地socket通信*/ struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */ }; ipv4以及的ipv6点分十进制表达法与二进制整数之间的互转。 c #include int inet_pton(int af, const char *src, void *dst); const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); //成功返回1，格式无效返回0，出错返回-1 inet_pton把字符串src转换成ip地址保存在 dst 中。该函数调用成功返回大于0的整数。 inet_ntop() 把网络字节序的ip地址 src 转换成字符串保存在 dst 中作为返回值返回，参数 size 为dst所包含的字节数。 af 用来指定要转换的ip属于什么协议族 栗子 c #include #include #include int main(int argc, char** argv) { struct sockaddr_in sin; char buf[16]; memset(\u0026sin, 0, sizeof(sin)); sin.sin_family=AF_INET; sin.sin_port=htons(3001); inet_pton(AF_INET, \"192.168.1.111\", \u0026sin.sin_addr.s_addr); printf(\"%s\\n\", inet_ntop(AF_INET, \u0026sin.sin_addr, buf, sizeof(buf))); return 0; } 9.2.3 地址查询gethostbyname和gethostbyaddr被认为是过时的。 gethostbyname, gethostbyaddr是不可重入函数；已经被getaddrinfo, getnameinfo替代 c #include #include int getaddrinfo(const char *host, const char *service, const struct addrinfo *hint, struct addrinfo **res); //成功返回0，出错返回非0错误码 void freeaddrinfo(struct addrinfo *ai); hostname:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串) service：服务名可以是十进制的端口号（字符串），也可以是已定义的服务名称，如ftp、http等 hints：可以是一个空指针，也可以是一个指向某个addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。 result：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。必须用freeaddrinfo释放 hostname和service不能同时为NULL 出错不能使用perror或strerror来生成错误信息，而是调用gai_strerror将返回的错误码转换成错误消息 c #include const char *gai_strerror(int error); //返回错误信息字符串 addrinfo结构体定义至少包含以下成员 c struct addrinfo { int ai_flags; int ai_family; /* AF_INET,AF_INET6或者AF_UNSPEC */ int ai_socktype; /* SOCK_STREAM SOCK_DGRAM ... */ int ai_protocol; /* 一般填0 使用默认 */ socklen_t ai_addrlen; /* length in bytes of address*/ struct sockaddr *ai_addr; /* address */ char *ai_canonname; /* canonical name of host */ struct addrinfo *ai_next; /* next in list */ }; 可以提供一个可选的hint来选择符合条件的地址，包括ai_family,ai_flags,ai_protocol,ai_socktype，其余字段必须为0，ai_flags可以用 shell AI_ADDRCONFIG #查询配置的地址类型（ipv4或ipv6） AI_ALL #查找IPv4和IPv6地址（仅用于AI_V4MAPPED） AI_CANONNAME #需要一个规范的名字（与别名相对） AI_NUMERICHOST #以数字格式指定主机地址，不翻译 AI_NUMERICSERV #将服务指定为数字端口号，不翻译 AI_PASSIVE #套接字地址用于监听绑定 AI_V4MAPPED #如果没有找到IPv6地址，返回映射到IPv6格式的IPv4地址 getnameinfo函数将一个地址转换成一个主机名和一个服务名 c #include #include int getnameinfo(const struct sockaddr *addr, socklen_t alen, char *host, socklen_t hostlen, char *service, socklen_t ","date":"2019-09-26","objectID":"/linux-system-programming/:9:2","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#921-字节序"},{"categories":["program"],"content":" 9.2 寻址 9.2.1 字节序字节序分为大端字节序和小端字节序 大端字节序： 是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。 小端字节序： 是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。 x86框架采用小端字节序，ARM架构启动时可以 设置大小端字节序。 网络字节序采用大端字节序。 字节序的转换： c #include uint32_t htonl(uint32_t hostlong); uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint16_t netshort); h表示host，n表示network，l表示32位长整数，s表示16位短整数。 9.2.2 地址格式与IP转换很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。 在linux中的实现： c #include struct sockaddr { sa_family_t sa_family; /* 地址族 */ char sa_data[14]; /*地址值，实际可能更长*/ }; /*IPV4*/ struct sockaddr_in { __kernel_sa_family_t sin_family; /* AF_INET4 */ __be16 sin_port; /*端头号*/ struct in_addr sin_addr; /* IPv4 地址 */ /* 8字节填充 */ unsigned char __pad[__SOCK_SIZE__ ‐ sizeof(short int) ‐ sizeof(unsigned short int) ‐ sizeof(struct in_addr)]; }; struct in_addr { __be32 s_addr; }; /*IPV6*/ struct sockaddr_in6 { unsigned short int sin6_family; /*AF_INET6*/ __be16 sin6_port; /* 端口 # */ __be32 sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 地址 128bit*/ __u32 sin6_scope_id; /* scope id (new in RFC2553) */ }; struct in6_addr { union { __u8 u6_addr8[16]; __be16 u6_addr16[8]; __be32 u6_addr32[4]; } in6_u; #define s6_addr in6_u.u6_addr8 #define s6_addr16 in6_u.u6_addr16 #define s6_addr32 in6_u.u6_addr32 }; #define UNIX_PATH_MAX 108 /*本地socket通信*/ struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */ }; ipv4以及的ipv6点分十进制表达法与二进制整数之间的互转。 c #include int inet_pton(int af, const char *src, void *dst); const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); //成功返回1，格式无效返回0，出错返回-1 inet_pton把字符串src转换成ip地址保存在 dst 中。该函数调用成功返回大于0的整数。 inet_ntop() 把网络字节序的ip地址 src 转换成字符串保存在 dst 中作为返回值返回，参数 size 为dst所包含的字节数。 af 用来指定要转换的ip属于什么协议族 栗子 c #include #include #include int main(int argc, char** argv) { struct sockaddr_in sin; char buf[16]; memset(\u0026sin, 0, sizeof(sin)); sin.sin_family=AF_INET; sin.sin_port=htons(3001); inet_pton(AF_INET, \"192.168.1.111\", \u0026sin.sin_addr.s_addr); printf(\"%s\\n\", inet_ntop(AF_INET, \u0026sin.sin_addr, buf, sizeof(buf))); return 0; } 9.2.3 地址查询gethostbyname和gethostbyaddr被认为是过时的。 gethostbyname, gethostbyaddr是不可重入函数；已经被getaddrinfo, getnameinfo替代 c #include #include int getaddrinfo(const char *host, const char *service, const struct addrinfo *hint, struct addrinfo **res); //成功返回0，出错返回非0错误码 void freeaddrinfo(struct addrinfo *ai); hostname:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串) service：服务名可以是十进制的端口号（字符串），也可以是已定义的服务名称，如ftp、http等 hints：可以是一个空指针，也可以是一个指向某个addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。 result：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。必须用freeaddrinfo释放 hostname和service不能同时为NULL 出错不能使用perror或strerror来生成错误信息，而是调用gai_strerror将返回的错误码转换成错误消息 c #include const char *gai_strerror(int error); //返回错误信息字符串 addrinfo结构体定义至少包含以下成员 c struct addrinfo { int ai_flags; int ai_family; /* AF_INET,AF_INET6或者AF_UNSPEC */ int ai_socktype; /* SOCK_STREAM SOCK_DGRAM ... */ int ai_protocol; /* 一般填0 使用默认 */ socklen_t ai_addrlen; /* length in bytes of address*/ struct sockaddr *ai_addr; /* address */ char *ai_canonname; /* canonical name of host */ struct addrinfo *ai_next; /* next in list */ }; 可以提供一个可选的hint来选择符合条件的地址，包括ai_family,ai_flags,ai_protocol,ai_socktype，其余字段必须为0，ai_flags可以用 shell AI_ADDRCONFIG #查询配置的地址类型（ipv4或ipv6） AI_ALL #查找IPv4和IPv6地址（仅用于AI_V4MAPPED） AI_CANONNAME #需要一个规范的名字（与别名相对） AI_NUMERICHOST #以数字格式指定主机地址，不翻译 AI_NUMERICSERV #将服务指定为数字端口号，不翻译 AI_PASSIVE #套接字地址用于监听绑定 AI_V4MAPPED #如果没有找到IPv6地址，返回映射到IPv6格式的IPv4地址 getnameinfo函数将一个地址转换成一个主机名和一个服务名 c #include #include int getnameinfo(const struct sockaddr *addr, socklen_t alen, char *host, socklen_t hostlen, char *service, socklen_t ","date":"2019-09-26","objectID":"/linux-system-programming/:9:2","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#922-地址格式与ip转换"},{"categories":["program"],"content":" 9.2 寻址 9.2.1 字节序字节序分为大端字节序和小端字节序 大端字节序： 是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。 小端字节序： 是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。 x86框架采用小端字节序，ARM架构启动时可以 设置大小端字节序。 网络字节序采用大端字节序。 字节序的转换： c #include uint32_t htonl(uint32_t hostlong); uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint16_t netshort); h表示host，n表示network，l表示32位长整数，s表示16位短整数。 9.2.2 地址格式与IP转换很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。 在linux中的实现： c #include struct sockaddr { sa_family_t sa_family; /* 地址族 */ char sa_data[14]; /*地址值，实际可能更长*/ }; /*IPV4*/ struct sockaddr_in { __kernel_sa_family_t sin_family; /* AF_INET4 */ __be16 sin_port; /*端头号*/ struct in_addr sin_addr; /* IPv4 地址 */ /* 8字节填充 */ unsigned char __pad[__SOCK_SIZE__ ‐ sizeof(short int) ‐ sizeof(unsigned short int) ‐ sizeof(struct in_addr)]; }; struct in_addr { __be32 s_addr; }; /*IPV6*/ struct sockaddr_in6 { unsigned short int sin6_family; /*AF_INET6*/ __be16 sin6_port; /* 端口 # */ __be32 sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 地址 128bit*/ __u32 sin6_scope_id; /* scope id (new in RFC2553) */ }; struct in6_addr { union { __u8 u6_addr8[16]; __be16 u6_addr16[8]; __be32 u6_addr32[4]; } in6_u; #define s6_addr in6_u.u6_addr8 #define s6_addr16 in6_u.u6_addr16 #define s6_addr32 in6_u.u6_addr32 }; #define UNIX_PATH_MAX 108 /*本地socket通信*/ struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */ }; ipv4以及的ipv6点分十进制表达法与二进制整数之间的互转。 c #include int inet_pton(int af, const char *src, void *dst); const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); //成功返回1，格式无效返回0，出错返回-1 inet_pton把字符串src转换成ip地址保存在 dst 中。该函数调用成功返回大于0的整数。 inet_ntop() 把网络字节序的ip地址 src 转换成字符串保存在 dst 中作为返回值返回，参数 size 为dst所包含的字节数。 af 用来指定要转换的ip属于什么协议族 栗子 c #include #include #include int main(int argc, char** argv) { struct sockaddr_in sin; char buf[16]; memset(\u0026sin, 0, sizeof(sin)); sin.sin_family=AF_INET; sin.sin_port=htons(3001); inet_pton(AF_INET, \"192.168.1.111\", \u0026sin.sin_addr.s_addr); printf(\"%s\\n\", inet_ntop(AF_INET, \u0026sin.sin_addr, buf, sizeof(buf))); return 0; } 9.2.3 地址查询gethostbyname和gethostbyaddr被认为是过时的。 gethostbyname, gethostbyaddr是不可重入函数；已经被getaddrinfo, getnameinfo替代 c #include #include int getaddrinfo(const char *host, const char *service, const struct addrinfo *hint, struct addrinfo **res); //成功返回0，出错返回非0错误码 void freeaddrinfo(struct addrinfo *ai); hostname:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串) service：服务名可以是十进制的端口号（字符串），也可以是已定义的服务名称，如ftp、http等 hints：可以是一个空指针，也可以是一个指向某个addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。 result：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。必须用freeaddrinfo释放 hostname和service不能同时为NULL 出错不能使用perror或strerror来生成错误信息，而是调用gai_strerror将返回的错误码转换成错误消息 c #include const char *gai_strerror(int error); //返回错误信息字符串 addrinfo结构体定义至少包含以下成员 c struct addrinfo { int ai_flags; int ai_family; /* AF_INET,AF_INET6或者AF_UNSPEC */ int ai_socktype; /* SOCK_STREAM SOCK_DGRAM ... */ int ai_protocol; /* 一般填0 使用默认 */ socklen_t ai_addrlen; /* length in bytes of address*/ struct sockaddr *ai_addr; /* address */ char *ai_canonname; /* canonical name of host */ struct addrinfo *ai_next; /* next in list */ }; 可以提供一个可选的hint来选择符合条件的地址，包括ai_family,ai_flags,ai_protocol,ai_socktype，其余字段必须为0，ai_flags可以用 shell AI_ADDRCONFIG #查询配置的地址类型（ipv4或ipv6） AI_ALL #查找IPv4和IPv6地址（仅用于AI_V4MAPPED） AI_CANONNAME #需要一个规范的名字（与别名相对） AI_NUMERICHOST #以数字格式指定主机地址，不翻译 AI_NUMERICSERV #将服务指定为数字端口号，不翻译 AI_PASSIVE #套接字地址用于监听绑定 AI_V4MAPPED #如果没有找到IPv6地址，返回映射到IPv6格式的IPv4地址 getnameinfo函数将一个地址转换成一个主机名和一个服务名 c #include #include int getnameinfo(const struct sockaddr *addr, socklen_t alen, char *host, socklen_t hostlen, char *service, socklen_t ","date":"2019-09-26","objectID":"/linux-system-programming/:9:2","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#923-地址查询"},{"categories":["program"],"content":" 9.3 将套接字与地址关联bind将一个客户端的套接字关联上一个地址没有多大意义，可以让系统选一个默认地址。 然而对于服务器，需要一个众所周知的地址。 bind函数来关联地址和套接字 C #include \u003csys/socket.h\u003e int bind(int sockfd, const struct sockaddr *addr, socklen_t len); //成功返回0，出错返回-1 使用的地址的一些限制： 在进程正在运行的计算机上，指定地址必须有效，必须是本机地址 地址必须和创建套接字时支持的地址族格式匹配 地址端口号不小于1024，0-1023只能root权限使用 一般只能将一个套接字端点绑定到一个给定地址上，尽管有些协议允许多重绑定 对于因特网域，如果指定IP地址为INADDR_ANY(\u003cnetinet/in.h\u003e)，这意味着这可以接收任意网卡数据 如果调用connect或 listen，但没有将地址绑定到套接字上，系统会自动分配地址。 getsockname函数来发现绑定到套接字上的地址 c #include \u003csys/socket.h\u003e int getsockname(int sockfd, struct sockaddr *addr, socklen_t *alenp); //成功返回0，出错返回-1 addr和alenp既做传入参数，也做传出参数。 getpeername函数来找到对方的地址 c #include \u003csys/socket.h\u003e int getpeername(int sockfd, struct sockaddr *addr, socklen_t *alenp) //成功返回0，出错返回-1 除了返回的是对方的地址，其他和getsockname一样 ","date":"2019-09-26","objectID":"/linux-system-programming/:9:3","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#93-将套接字与地址关联bind"},{"categories":["program"],"content":" 9.4 建立连接connect如果要处理一个面向连接的网络服务(SOCK_STREAM或SOCK_SEQPACKET)，那么交换数据前要与服务器（套接字）建立连接。 connect c #include \u003csys/socket.h\u003e int connect(int sockfd, const struct sockaddr *addr, socklent_t len); //成功返回0，出错返回-1 如果sockfd没有绑定地址，connect会给调用者绑定一个默认地址 如果connect失败，可迁移的应用程序需要关闭套接字，如果想重试必须新打开一个套接字 如果套接字描述符处于非阻塞模式，那么连接不能马上建立时connect返回-1，errno设为EINPROGRESS 可以poll或select来判断文件描述符何时可写，如果可写，连接完成 connect还可以用于无连接的网络服务(SOCK_DGRAM)，这看起来有点矛盾，实际是个不错的选择，如果SOCK_DGRAM套接字调用connect，传送的报文地址会设置成connect调用指定的地址，这样每次传送报文时就不需要再提供地址，另外仅能接收来自指定地址的报文。 ","date":"2019-09-26","objectID":"/linux-system-programming/:9:4","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#94-建立连接connect"},{"categories":["program"],"content":" 9.5 接受连接请求listen accept listen函数宣告愿意接收连接请求 c #include \u003csys/socket.h\u003e int listen(int sockfd, int backlog); //成功返回0，出错返回-1 backlog提供了一个提示,提示系统该进所要入队的未完成连接数量。其实际值由系统决定，上限由\u003csys/socket.h\u003e中的SOMAXCONN指定，队列满后，系统会拒绝多余连接请求。一般SOMAXCONN 一旦服务器调用listen，所用的套接字就能接收连接请求 accept函数获得连接请求并建立连接 c #include \u003csys/socket.h\u003e int accept(int sockfd, struct sockaddr *addr, socklen_t *len); //成功返回套接字描述符，出错返回-1 accept返回的描述符是套接字描述符，这个新的描述符和原始套接字sockfd具有相同的类型和地址族， 传给accept的原始描述符没有关联到这个连接，而是继续保持可以状态并接收其他连接请求 如果不关心客户端标识，可将参数addr和len设为NULL，否则accept会吧客户端地址填充到缓冲区 如果没有连接请求在等待，accept会阻塞直到一个请求到来 如果sockfd处于非阻塞模式，accept会返回-1，errno设置为EAGAIN ","date":"2019-09-26","objectID":"/linux-system-programming/:9:5","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#95-接受连接请求listen-accept"},{"categories":["program"],"content":" 9.6 数据传输可以通过read和write交换数据 但如果想指定选项，从多个客户端接收数据包，或者发送带外数据，需要使用6个专门为数据传递而设计的函数 3个用来发送数据，3个用来接收数据 9.6.1 send sendto sendmsg send，和write很像，但是可以指定标志来改变处理传输数据的方式 c #include \u003csys/socket.h\u003e ssize_t send(int sockfd, const void *buf, size_t nbyges, int flags); //成功返回发送的字节数，出错返回-1 类似write，多个flags flags： shell MSG_CONFIRM # 提供链路层反馈以保持地址映射有效 MSG_DONTROUTE # 勿将数据包路由出本地网络 MSG_DONTWAIT # 运行非阻塞操作(等价于使用O_NONBLOCK) MSG_EOF # 发送数据后关闭套接字发送端 MSG_EOR # 如果协议支持，标记记录结束 MSG_MORE # 延迟发送数据包允许写更多数据 MSG_NOSIGNAL # 在写无连接的套接字时不产生SIGPIPE信号 MSG_OOB # 如果协议支持，发送带外数据 对支持报文边界的协议，报文长度唱过协议支持，send失败，errno为EMSGSIZE sendto，和send类似，区别是可以在无连接的套接字上指定一个目标地址 c #include \u003csys/socket.h\u003e ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, const struct sockaddr *destaddr, socklen_t destlen); //成功返回发送的字节数，出错返回-1 对于面向连接的套接字，目标地址destaddr是被忽略的 对于无连接的套接字，除非先调用了connect设置了目标地址，否则不能用send。要有sendto sendmsg 略 9.6.2 recv recvfrom recvmsg recv，和read相似，但是可以指定标志来控制如何接收数据 c #include \u003csys/socket.h\u003e ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags); //返回读到数据的字节长度，若无可以数据或对方已经按序结束，返回0，出错返回-1 flags: shell MSG_CMSG_CLOEXEC # 为unix域套接字上接收的文件描述符设置执行时关闭标志 MSG_DONTWAIT # 启用非阻塞操作（相当于使用O_NONVLOCK） MSG_ERRQUEUE # 接收错误信息作为辅助数据 MSG_OOB # 如果协议支持，获取带外数据 MSG_PEEK # 返回数据包内容而不真正取走数据包，偷窥 MSG_TRUNC # 使数据包被截断，也返回数据包的实际长度 MSG_WAITALL # 等待直到所有的数据可用（仅SOCK_STREAM），buf填满nbytes才返回 recvfrom，可以得到数据发送者的源地址 c #include \u003csys/socket.h\u003e ssize_t recvfrom(int sockfd, void *buf, size_t nbytes, int flags, struct sockaddr *addr, socklen_t *addrlen); //返回读到数据的字节长度，若无可以数据或对方已经按序结束，返回0，出错返回-1 flags与recv一样，addr不为NULL，会填充另一端的地址 recvmsg 略 ","date":"2019-09-26","objectID":"/linux-system-programming/:9:6","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#96-数据传输"},{"categories":["program"],"content":" 9.6 数据传输可以通过read和write交换数据 但如果想指定选项，从多个客户端接收数据包，或者发送带外数据，需要使用6个专门为数据传递而设计的函数 3个用来发送数据，3个用来接收数据 9.6.1 send sendto sendmsg send，和write很像，但是可以指定标志来改变处理传输数据的方式 c #include ssize_t send(int sockfd, const void *buf, size_t nbyges, int flags); //成功返回发送的字节数，出错返回-1 类似write，多个flags flags： shell MSG_CONFIRM # 提供链路层反馈以保持地址映射有效 MSG_DONTROUTE # 勿将数据包路由出本地网络 MSG_DONTWAIT # 运行非阻塞操作(等价于使用O_NONBLOCK) MSG_EOF # 发送数据后关闭套接字发送端 MSG_EOR # 如果协议支持，标记记录结束 MSG_MORE # 延迟发送数据包允许写更多数据 MSG_NOSIGNAL # 在写无连接的套接字时不产生SIGPIPE信号 MSG_OOB # 如果协议支持，发送带外数据 对支持报文边界的协议，报文长度唱过协议支持，send失败，errno为EMSGSIZE sendto，和send类似，区别是可以在无连接的套接字上指定一个目标地址 c #include ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, const struct sockaddr *destaddr, socklen_t destlen); //成功返回发送的字节数，出错返回-1 对于面向连接的套接字，目标地址destaddr是被忽略的 对于无连接的套接字，除非先调用了connect设置了目标地址，否则不能用send。要有sendto sendmsg 略 9.6.2 recv recvfrom recvmsg recv，和read相似，但是可以指定标志来控制如何接收数据 c #include ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags); //返回读到数据的字节长度，若无可以数据或对方已经按序结束，返回0，出错返回-1 flags: shell MSG_CMSG_CLOEXEC # 为unix域套接字上接收的文件描述符设置执行时关闭标志 MSG_DONTWAIT # 启用非阻塞操作（相当于使用O_NONVLOCK） MSG_ERRQUEUE # 接收错误信息作为辅助数据 MSG_OOB # 如果协议支持，获取带外数据 MSG_PEEK # 返回数据包内容而不真正取走数据包，偷窥 MSG_TRUNC # 使数据包被截断，也返回数据包的实际长度 MSG_WAITALL # 等待直到所有的数据可用（仅SOCK_STREAM），buf填满nbytes才返回 recvfrom，可以得到数据发送者的源地址 c #include ssize_t recvfrom(int sockfd, void *buf, size_t nbytes, int flags, struct sockaddr *addr, socklen_t *addrlen); //返回读到数据的字节长度，若无可以数据或对方已经按序结束，返回0，出错返回-1 flags与recv一样，addr不为NULL，会填充另一端的地址 recvmsg 略 ","date":"2019-09-26","objectID":"/linux-system-programming/:9:6","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#961-send-sendto-sendmsg"},{"categories":["program"],"content":" 9.6 数据传输可以通过read和write交换数据 但如果想指定选项，从多个客户端接收数据包，或者发送带外数据，需要使用6个专门为数据传递而设计的函数 3个用来发送数据，3个用来接收数据 9.6.1 send sendto sendmsg send，和write很像，但是可以指定标志来改变处理传输数据的方式 c #include ssize_t send(int sockfd, const void *buf, size_t nbyges, int flags); //成功返回发送的字节数，出错返回-1 类似write，多个flags flags： shell MSG_CONFIRM # 提供链路层反馈以保持地址映射有效 MSG_DONTROUTE # 勿将数据包路由出本地网络 MSG_DONTWAIT # 运行非阻塞操作(等价于使用O_NONBLOCK) MSG_EOF # 发送数据后关闭套接字发送端 MSG_EOR # 如果协议支持，标记记录结束 MSG_MORE # 延迟发送数据包允许写更多数据 MSG_NOSIGNAL # 在写无连接的套接字时不产生SIGPIPE信号 MSG_OOB # 如果协议支持，发送带外数据 对支持报文边界的协议，报文长度唱过协议支持，send失败，errno为EMSGSIZE sendto，和send类似，区别是可以在无连接的套接字上指定一个目标地址 c #include ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, const struct sockaddr *destaddr, socklen_t destlen); //成功返回发送的字节数，出错返回-1 对于面向连接的套接字，目标地址destaddr是被忽略的 对于无连接的套接字，除非先调用了connect设置了目标地址，否则不能用send。要有sendto sendmsg 略 9.6.2 recv recvfrom recvmsg recv，和read相似，但是可以指定标志来控制如何接收数据 c #include ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags); //返回读到数据的字节长度，若无可以数据或对方已经按序结束，返回0，出错返回-1 flags: shell MSG_CMSG_CLOEXEC # 为unix域套接字上接收的文件描述符设置执行时关闭标志 MSG_DONTWAIT # 启用非阻塞操作（相当于使用O_NONVLOCK） MSG_ERRQUEUE # 接收错误信息作为辅助数据 MSG_OOB # 如果协议支持，获取带外数据 MSG_PEEK # 返回数据包内容而不真正取走数据包，偷窥 MSG_TRUNC # 使数据包被截断，也返回数据包的实际长度 MSG_WAITALL # 等待直到所有的数据可用（仅SOCK_STREAM），buf填满nbytes才返回 recvfrom，可以得到数据发送者的源地址 c #include ssize_t recvfrom(int sockfd, void *buf, size_t nbytes, int flags, struct sockaddr *addr, socklen_t *addrlen); //返回读到数据的字节长度，若无可以数据或对方已经按序结束，返回0，出错返回-1 flags与recv一样，addr不为NULL，会填充另一端的地址 recvmsg 略 ","date":"2019-09-26","objectID":"/linux-system-programming/:9:6","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#962-recv-recvfrom-recvmsg"},{"categories":["program"],"content":" 9.7 套接字选项","date":"2019-09-26","objectID":"/linux-system-programming/:9:7","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#97-套接字选项"},{"categories":["program"],"content":" 命令行命令 od（1）命令观察该文件的实际内容，-c参数表示以字符方式打印内容，括号里数字是查看man页码 size（1）命令报告正文段，数据段和bss段长度 ","date":"2019-09-26","objectID":"/linux-system-programming/:10:0","series":null,"tags":["linux"],"title":"Linux系统编程","uri":"/linux-system-programming/#命令行命令"},{"categories":["program"],"content":" Redis操作手册 官网 redis是单线程事件驱动 redis没有命名空间概念，可通过key的名字自由发挥 在线练习 https://try.redis.io/ ","date":"2019-08-16","objectID":"/redis-operation-manual/:0:0","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#redis操作手册"},{"categories":["program"],"content":" 1 安装","date":"2019-08-16","objectID":"/redis-operation-manual/:1:0","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#1-安装"},{"categories":["program"],"content":" 1.1 linux上安装 ubuntu bash $ sudo apt install redis-server 配置文件位于：/etc/redis/redis.conf 配置文件中放开requirepass的注释可以设置密码，有密码时连接要认证redis-cli -a passwd 注释掉bind 127.0.0.1 ::1，允许外部连接 redis默认端口：6379 ","date":"2019-08-16","objectID":"/redis-operation-manual/:1:1","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#11-linux上安装"},{"categories":["program"],"content":" 2 使用连接redis-server可以使用自带客户端redis-cli，或者某种语言的api bash $ redis-cli -h redis-cli 4.0.9 Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]] -h \u003chostname\u003e Server hostname (default: 127.0.0.1). -p \u003cport\u003e Server port (default: 6379). -s \u003csocket\u003e Server socket (overrides hostname and port). -a \u003cpassword\u003e Password to use when connecting to the server. -x Read last argument from STDIN. -n \u003cdb\u003e Database number. ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:0","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#2-使用"},{"categories":["program"],"content":" 2.1 全局命令直接在redis-cli执行可以看到结果： 查看所有键 - keys * 输出所有键值对，慎用 键总数 - dbsize 无需遍历，这是个O(1)的操作 检查键是否存在 - exists key 存在返回1，不存在返回0 删除键 - del key 通用命令，什么数据类型都可以删，可以跟多个key一次删除 返回成功删除的个数，不存在的键不计数 设置过期 - expire key seconds 设置seconds秒后删除key，设置成功返回1 ttl key 返回剩余时间，大于0表示声音时间，-1表示没设置超时，-2键不存在 数据类型 - type key 返回key中的数据类型，不存在返回none 数据类型有string,hash,list,set,zset 内部编码 - object encoding key 每种数据类型都有多种内部实现方式，查询key的内部实现 ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:1","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#21-全局命令"},{"categories":["program"],"content":" 2.2 字符串 设置值 txt set key value [ex seconds] [px milliseconds] [nx|xx] ex seconds - 选项，设置秒级过期时间 px milliseconds - 设置毫秒级过期时间 nx - 键必须不存在，才能设置成功，用于添加 xx - 键值必须存在，用于更新 获取值 txt get key 如果键不存在，返回nil 批量设置值 cpp mset key value [key value ...] 批量获取值 txt mget key [key ...] 如果有些键不存在，值为nil 计数，增加值(string的实现必须是int),自减 txt incr key // +1 decr key // -1 incrby key n // +n decrby key n // -n incrbyfloat key n.m // +n.m 浮点数 内部实现是 embstr 值不是整数，返回错误 值是整数，返回自增后的结果 键不存在，按照值为0自增 追加 txt append key value 向字符串尾部拼接值，返回拼接后长度 如果键不存在，当成向空字符串后拼接 获取长度 txt strlen key 键不存在返回0 设置并返回原值 txt getset key value 设置新值，把原来的值返回 键不存在，返回nil 设置指定位置字符 txt setrange key offeset value 把key里面的字符串偏移offeset的位置的字符设置为value 长度超出，填充0x00, 键不存在按空串处理 获取部分字符串 txt getrange key start end 返会落在范围内的字符，范围大只返回实际有的字符串 键不存在当空串处理，范围多大都返回\"\" 2.2.1 内部编码 int - 8字节长整型(有符号) embstr - 小于等于39个字节的字符串 raw - 大于39个字节的串 ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:2","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#22-字符串"},{"categories":["program"],"content":" 2.2 字符串 设置值 txt set key value [ex seconds] [px milliseconds] [nx|xx] ex seconds - 选项，设置秒级过期时间 px milliseconds - 设置毫秒级过期时间 nx - 键必须不存在，才能设置成功，用于添加 xx - 键值必须存在，用于更新 获取值 txt get key 如果键不存在，返回nil 批量设置值 cpp mset key value [key value ...] 批量获取值 txt mget key [key ...] 如果有些键不存在，值为nil 计数，增加值(string的实现必须是int),自减 txt incr key // +1 decr key // -1 incrby key n // +n decrby key n // -n incrbyfloat key n.m // +n.m 浮点数 内部实现是 embstr 值不是整数，返回错误 值是整数，返回自增后的结果 键不存在，按照值为0自增 追加 txt append key value 向字符串尾部拼接值，返回拼接后长度 如果键不存在，当成向空字符串后拼接 获取长度 txt strlen key 键不存在返回0 设置并返回原值 txt getset key value 设置新值，把原来的值返回 键不存在，返回nil 设置指定位置字符 txt setrange key offeset value 把key里面的字符串偏移offeset的位置的字符设置为value 长度超出，填充0x00, 键不存在按空串处理 获取部分字符串 txt getrange key start end 返会落在范围内的字符，范围大只返回实际有的字符串 键不存在当空串处理，范围多大都返回\"\" 2.2.1 内部编码 int - 8字节长整型(有符号) embstr - 小于等于39个字节的字符串 raw - 大于39个字节的串 ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:2","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#221-内部编码"},{"categories":["program"],"content":" 2.3 哈希哈希类型是指键值本身又是一个键值对结构 形如value = { {field1，value1}, ...{fieldn,valuen} } 设置值 txt hset key field value hset user:1 name kirito 向键值为key的字典中加入一个键值对 成功返回1，否则0 提供了hsetnx命令，用于添加 获取值 text hget key field 不存在返回nil 删除field txt hdel key field [field ...] 返回成功删除的个数 计算field个数 txt hlen key 不存在返回0，键的内容不是哈希返回错误信息 批量设置，获取 field-value txt hmget key field [field ...] hmset key field value [field value ...] 判断field是否存在 txt hexists key field 获取所有field txt hkeys key 这个命令应该叫hfields更为恰当 获取所有value txt hvals key 获取所有的 field-value txt hgetall key 如果数量多，慎用 如果一定要获取全部field-value，可以使用hscan命令 value自增 txt hincrby key field n hincrbyfloat key field n.m 像incrby和incrbyfloat命令一样，但是它们作用的是filed 计算value的字符串长度（3.2版本以上） txt hstrlen key field 2.3.1 内部编码 ziplist - 压缩列表，紧凑的结构实现多个元素的连续存储，所以在节省内 存方面比hashtable更加优秀，元素少的时候用这个 hashtable - 哈希表 ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:3","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#23-哈希"},{"categories":["program"],"content":" 2.3 哈希哈希类型是指键值本身又是一个键值对结构 形如value = { {field1，value1}, ...{fieldn,valuen} } 设置值 txt hset key field value hset user:1 name kirito 向键值为key的字典中加入一个键值对 成功返回1，否则0 提供了hsetnx命令，用于添加 获取值 text hget key field 不存在返回nil 删除field txt hdel key field [field ...] 返回成功删除的个数 计算field个数 txt hlen key 不存在返回0，键的内容不是哈希返回错误信息 批量设置，获取 field-value txt hmget key field [field ...] hmset key field value [field value ...] 判断field是否存在 txt hexists key field 获取所有field txt hkeys key 这个命令应该叫hfields更为恰当 获取所有value txt hvals key 获取所有的 field-value txt hgetall key 如果数量多，慎用 如果一定要获取全部field-value，可以使用hscan命令 value自增 txt hincrby key field n hincrbyfloat key field n.m 像incrby和incrbyfloat命令一样，但是它们作用的是filed 计算value的字符串长度（3.2版本以上） txt hstrlen key field 2.3.1 内部编码 ziplist - 压缩列表，紧凑的结构实现多个元素的连续存储，所以在节省内 存方面比hashtable更加优秀，元素少的时候用这个 hashtable - 哈希表 ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:3","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#231-内部编码"},{"categories":["program"],"content":" 2.4 列表一个列表最多可以存储$2^{32} -1$个元素。可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等 操作类型 操纵 添加 rpush lpush linsert 查询 lrange lindex llen 删除 lpop rpop lrem ltrim 修改 lset 阻塞操作 blpop brpop 2.4.1 添加操作 从右边插入(向后插入) text rpush key value [value ...] 返回插入后列表元素个数 从左边插入(向前插入) text lpush key value [value ...] 返回插入后元素个数 向某个元素前或后插入元素 cpp linsert key before|after pivot value 找到等于pivot的元素，在其前或后插入value 返回插入后长度 pivot不存在返回-1，不插入 获取指定范围元素 text lrange key start end key 不存在，返回空 区间过大，只返回实际拥有的元素 0是第一个元素，-1是最后一个元素，-2是倒数第二个元素，打印所有使用lrange key 0 -1 获取指定下标的元素 text lindex key index 不存在返回nil 下标与区间范围一样，可以用负数 获取列表长度 text llen key key不存在返回0 删除，从列表左侧弹出元素（删除列表头） text lpop key 返回被弹出的元素 列表为空或不存在返回nil 删除，从右侧弹出（删除尾部元素） text rpop key 删除指定元素 text lrem key count value count \u003e 0，从左到右删除，删除最多count个等于value元素 count \u003c 0，从右到左删除 count = 0，删除所有 返回实际删除个数 按照索引范围修剪列表 text ltrim key start end [start, end]范围内的元素保留，其余删除 修改指定下标的元素 text lset key index newValue 不存在，或超出范围，返回失败信息 阻塞式弹出 text blpop key [key ...] timeout brpop key [key ...] timeout 是lpop和rpop的阻塞版本，使用方法相同 key 任意多个键，timeout 阻塞时间 一旦有一个key可以弹出元素，就立即返回，否则超时返回 某个key弹出成功，返回key名字和弹出元素，超时返回nil和时间 如果多个客户端对同一个键执行brpop，那么最先执行命令的客户端可以获取到弹出的值 阻塞可以实现消息队列 2.4.2 内部编码 ziplist linkedlist quicklist ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:4","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#24-列表"},{"categories":["program"],"content":" 2.4 列表一个列表最多可以存储$2^{32} -1$个元素。可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等 操作类型 操纵 添加 rpush lpush linsert 查询 lrange lindex llen 删除 lpop rpop lrem ltrim 修改 lset 阻塞操作 blpop brpop 2.4.1 添加操作 从右边插入(向后插入) text rpush key value [value ...] 返回插入后列表元素个数 从左边插入(向前插入) text lpush key value [value ...] 返回插入后元素个数 向某个元素前或后插入元素 cpp linsert key before|after pivot value 找到等于pivot的元素，在其前或后插入value 返回插入后长度 pivot不存在返回-1，不插入 获取指定范围元素 text lrange key start end key 不存在，返回空 区间过大，只返回实际拥有的元素 0是第一个元素，-1是最后一个元素，-2是倒数第二个元素，打印所有使用lrange key 0 -1 获取指定下标的元素 text lindex key index 不存在返回nil 下标与区间范围一样，可以用负数 获取列表长度 text llen key key不存在返回0 删除，从列表左侧弹出元素（删除列表头） text lpop key 返回被弹出的元素 列表为空或不存在返回nil 删除，从右侧弹出（删除尾部元素） text rpop key 删除指定元素 text lrem key count value count \u003e 0，从左到右删除，删除最多count个等于value元素 count \u003c 0，从右到左删除 count = 0，删除所有 返回实际删除个数 按照索引范围修剪列表 text ltrim key start end [start, end]范围内的元素保留，其余删除 修改指定下标的元素 text lset key index newValue 不存在，或超出范围，返回失败信息 阻塞式弹出 text blpop key [key ...] timeout brpop key [key ...] timeout 是lpop和rpop的阻塞版本，使用方法相同 key 任意多个键，timeout 阻塞时间 一旦有一个key可以弹出元素，就立即返回，否则超时返回 某个key弹出成功，返回key名字和弹出元素，超时返回nil和时间 如果多个客户端对同一个键执行brpop，那么最先执行命令的客户端可以获取到弹出的值 阻塞可以实现消息队列 2.4.2 内部编码 ziplist linkedlist quicklist ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:4","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#241-添加操作"},{"categories":["program"],"content":" 2.4 列表一个列表最多可以存储$2^{32} -1$个元素。可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等 操作类型 操纵 添加 rpush lpush linsert 查询 lrange lindex llen 删除 lpop rpop lrem ltrim 修改 lset 阻塞操作 blpop brpop 2.4.1 添加操作 从右边插入(向后插入) text rpush key value [value ...] 返回插入后列表元素个数 从左边插入(向前插入) text lpush key value [value ...] 返回插入后元素个数 向某个元素前或后插入元素 cpp linsert key before|after pivot value 找到等于pivot的元素，在其前或后插入value 返回插入后长度 pivot不存在返回-1，不插入 获取指定范围元素 text lrange key start end key 不存在，返回空 区间过大，只返回实际拥有的元素 0是第一个元素，-1是最后一个元素，-2是倒数第二个元素，打印所有使用lrange key 0 -1 获取指定下标的元素 text lindex key index 不存在返回nil 下标与区间范围一样，可以用负数 获取列表长度 text llen key key不存在返回0 删除，从列表左侧弹出元素（删除列表头） text lpop key 返回被弹出的元素 列表为空或不存在返回nil 删除，从右侧弹出（删除尾部元素） text rpop key 删除指定元素 text lrem key count value count \u003e 0，从左到右删除，删除最多count个等于value元素 count \u003c 0，从右到左删除 count = 0，删除所有 返回实际删除个数 按照索引范围修剪列表 text ltrim key start end [start, end]范围内的元素保留，其余删除 修改指定下标的元素 text lset key index newValue 不存在，或超出范围，返回失败信息 阻塞式弹出 text blpop key [key ...] timeout brpop key [key ...] timeout 是lpop和rpop的阻塞版本，使用方法相同 key 任意多个键，timeout 阻塞时间 一旦有一个key可以弹出元素，就立即返回，否则超时返回 某个key弹出成功，返回key名字和弹出元素，超时返回nil和时间 如果多个客户端对同一个键执行brpop，那么最先执行命令的客户端可以获取到弹出的值 阻塞可以实现消息队列 2.4.2 内部编码 ziplist linkedlist quicklist ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:4","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#242-内部编码"},{"categories":["program"],"content":" 2.5 集合集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。个集合最多 可以存储$2^{32} -1$个元素，Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。 集合可以实现tag，比如用户感兴趣的标签 2.5.1 集合内操作 添加元素 text sadd key element [element ...] 返回成功添加的元素个数 删除元素 text srem key element [element ...] 返回成功删除的个数 返回元素个数 text scard key O(1)复杂度，不会遍历，有内部变量记录 判断元素是否在集合中 text sismember key element 存在返回1，不存在返回0 随机从集合返回若干个元素 text srandmember key [count] count指定返回个数，默认为1，元素如果不够，仅返回全部 随机从集合弹出元素 text spop key [count] 返回弹出的元素，空集合返回空 获取所有元素 text smembers key 2.5.2 集合间操作 求多个集合的交集 text sinter key [key ...] 求多个集合的并集 text sunion key [key ...] 求多个集合的差集 text sdiff key [key ...] 保存运算结果到新的集合 text sinterstore destination key [key ...] suionstore destination key [key ...] sdiffstore destination key [key ...] 集合操作比较耗时，可以把结果保存到名为destination的键中 sinterstore set3 set1 set2 2.5.3 内部编码 intset - 集合较小且都为整数会用这个 hashtable ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:5","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#25-集合"},{"categories":["program"],"content":" 2.5 集合集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。个集合最多 可以存储$2^{32} -1$个元素，Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。 集合可以实现tag，比如用户感兴趣的标签 2.5.1 集合内操作 添加元素 text sadd key element [element ...] 返回成功添加的元素个数 删除元素 text srem key element [element ...] 返回成功删除的个数 返回元素个数 text scard key O(1)复杂度，不会遍历，有内部变量记录 判断元素是否在集合中 text sismember key element 存在返回1，不存在返回0 随机从集合返回若干个元素 text srandmember key [count] count指定返回个数，默认为1，元素如果不够，仅返回全部 随机从集合弹出元素 text spop key [count] 返回弹出的元素，空集合返回空 获取所有元素 text smembers key 2.5.2 集合间操作 求多个集合的交集 text sinter key [key ...] 求多个集合的并集 text sunion key [key ...] 求多个集合的差集 text sdiff key [key ...] 保存运算结果到新的集合 text sinterstore destination key [key ...] suionstore destination key [key ...] sdiffstore destination key [key ...] 集合操作比较耗时，可以把结果保存到名为destination的键中 sinterstore set3 set1 set2 2.5.3 内部编码 intset - 集合较小且都为整数会用这个 hashtable ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:5","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#251-集合内操作"},{"categories":["program"],"content":" 2.5 集合集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。个集合最多 可以存储$2^{32} -1$个元素，Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。 集合可以实现tag，比如用户感兴趣的标签 2.5.1 集合内操作 添加元素 text sadd key element [element ...] 返回成功添加的元素个数 删除元素 text srem key element [element ...] 返回成功删除的个数 返回元素个数 text scard key O(1)复杂度，不会遍历，有内部变量记录 判断元素是否在集合中 text sismember key element 存在返回1，不存在返回0 随机从集合返回若干个元素 text srandmember key [count] count指定返回个数，默认为1，元素如果不够，仅返回全部 随机从集合弹出元素 text spop key [count] 返回弹出的元素，空集合返回空 获取所有元素 text smembers key 2.5.2 集合间操作 求多个集合的交集 text sinter key [key ...] 求多个集合的并集 text sunion key [key ...] 求多个集合的差集 text sdiff key [key ...] 保存运算结果到新的集合 text sinterstore destination key [key ...] suionstore destination key [key ...] sdiffstore destination key [key ...] 集合操作比较耗时，可以把结果保存到名为destination的键中 sinterstore set3 set1 set2 2.5.3 内部编码 intset - 集合较小且都为整数会用这个 hashtable ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:5","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#252-集合间操作"},{"categories":["program"],"content":" 2.5 集合集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。个集合最多 可以存储$2^{32} -1$个元素，Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。 集合可以实现tag，比如用户感兴趣的标签 2.5.1 集合内操作 添加元素 text sadd key element [element ...] 返回成功添加的元素个数 删除元素 text srem key element [element ...] 返回成功删除的个数 返回元素个数 text scard key O(1)复杂度，不会遍历，有内部变量记录 判断元素是否在集合中 text sismember key element 存在返回1，不存在返回0 随机从集合返回若干个元素 text srandmember key [count] count指定返回个数，默认为1，元素如果不够，仅返回全部 随机从集合弹出元素 text spop key [count] 返回弹出的元素，空集合返回空 获取所有元素 text smembers key 2.5.2 集合间操作 求多个集合的交集 text sinter key [key ...] 求多个集合的并集 text sunion key [key ...] 求多个集合的差集 text sdiff key [key ...] 保存运算结果到新的集合 text sinterstore destination key [key ...] suionstore destination key [key ...] sdiffstore destination key [key ...] 集合操作比较耗时，可以把结果保存到名为destination的键中 sinterstore set3 set1 set2 2.5.3 内部编码 intset - 集合较小且都为整数会用这个 hashtable ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:5","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#253-内部编码"},{"categories":["program"],"content":" 2.6 有序集合有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个分数（score）作为排序的依据。 可以实现排行榜 2.6.1 集合内操作 添加(修改)成员 text zadd key [nx|xx] [ch] [incr] score member [score member ...] zadd key score member [score member ...] 多个成员分数可以相同，返回成功插入个数 incr - score的意义变为在原有分数上加分，不存在元素分数为0, 只支持加入一个，相当于zincrby ch - 返回此次操作后，分数发生变化的元素个数，新加入元素也算分数变化 nx - 元素必须不存在，添加操作 xx - 元素必须存在，修改操作 返回元素个数 text zcard key 返回某个成员分数 text zscore key member 元素不存在返回nil 计算成员排名 text zrank key member zrevrank key member zrank是从低分到高分排序，zrevrank反之 不存在返回nil，排名从0开始 删除成员 text zrem key member [member ...] 返回实际删除个数，不存在的元素忽略 增加成员的分数 text zincrby key increment member 给member增加increment分，不存在元素初始分当作0，返回增加后分数 返回指定排名范围的成员 text zrange key start end [withscores] zrevrange key start end [withscores] zrange从低到高排名，zrevrange从高到低排序 withscores同时返回分数 text 127.0.0.1:6379\u003e ZRANGE zset 1 -1 withscores 1) \"cpp\" 2) \"2\" 3) \"go\" 4) \"2\" 5) \"incr\" 6) \"3\" 7) \"mem\" 8) \"3\" 9) \"mem1\" 10) \"3\" -1表示最后一名,从0开始 返回指定分数范围的成员 text zrangebyscore key min max [withscores] [limit offset count] zrevrangebyscore key max min [withscores] [limit offset count] (min max 表示min用开区间 min (max 表示max用开区间 -inf 无限小 +inf 无限大 [limit offset count] - 从offset偏移位置输出，输出count个，相当于分页查询 返回指定分数范围成员个数 text zcount key min max 也支持开区间 (min (max 支持无限 删除指定排名内的升序元素 text zremrangebyrank key start end 删除排名在[start,end]的元素 返回删除个数 删除指定分数范围的成员 text zremrangebyscore key min max 支持开区间，无限 返回删除个数 2.6.2 集合间操作 交集 text zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max] destination - 交集计算结果保存到这个键 numkeys - 需要做交集计算键的个数 key[key...] - 需要做交集计算的键 weights weight[weight...] - 每个键的权重，在做交集计算时，每个键中的每个member会将自己分数乘以这个权重，每个键的权重默认是1 aggregate sum|min|max - 计算成员交集后，分值可以按照sum（和）、min（最小值）、max（最大值）做汇总，默认值是 sum。 返回交集元素个数，结果存在新键中 并集 text zunionstore ... 和上面其他参数一样 2.6.3 内部编码 ziplist skiplist ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:6","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#26-有序集合"},{"categories":["program"],"content":" 2.6 有序集合有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个分数（score）作为排序的依据。 可以实现排行榜 2.6.1 集合内操作 添加(修改)成员 text zadd key [nx|xx] [ch] [incr] score member [score member ...] zadd key score member [score member ...] 多个成员分数可以相同，返回成功插入个数 incr - score的意义变为在原有分数上加分，不存在元素分数为0, 只支持加入一个，相当于zincrby ch - 返回此次操作后，分数发生变化的元素个数，新加入元素也算分数变化 nx - 元素必须不存在，添加操作 xx - 元素必须存在，修改操作 返回元素个数 text zcard key 返回某个成员分数 text zscore key member 元素不存在返回nil 计算成员排名 text zrank key member zrevrank key member zrank是从低分到高分排序，zrevrank反之 不存在返回nil，排名从0开始 删除成员 text zrem key member [member ...] 返回实际删除个数，不存在的元素忽略 增加成员的分数 text zincrby key increment member 给member增加increment分，不存在元素初始分当作0，返回增加后分数 返回指定排名范围的成员 text zrange key start end [withscores] zrevrange key start end [withscores] zrange从低到高排名，zrevrange从高到低排序 withscores同时返回分数 text 127.0.0.1:6379\u003e ZRANGE zset 1 -1 withscores 1) \"cpp\" 2) \"2\" 3) \"go\" 4) \"2\" 5) \"incr\" 6) \"3\" 7) \"mem\" 8) \"3\" 9) \"mem1\" 10) \"3\" -1表示最后一名,从0开始 返回指定分数范围的成员 text zrangebyscore key min max [withscores] [limit offset count] zrevrangebyscore key max min [withscores] [limit offset count] (min max 表示min用开区间 min (max 表示max用开区间 -inf 无限小 +inf 无限大 [limit offset count] - 从offset偏移位置输出，输出count个，相当于分页查询 返回指定分数范围成员个数 text zcount key min max 也支持开区间 (min (max 支持无限 删除指定排名内的升序元素 text zremrangebyrank key start end 删除排名在[start,end]的元素 返回删除个数 删除指定分数范围的成员 text zremrangebyscore key min max 支持开区间，无限 返回删除个数 2.6.2 集合间操作 交集 text zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max] destination - 交集计算结果保存到这个键 numkeys - 需要做交集计算键的个数 key[key...] - 需要做交集计算的键 weights weight[weight...] - 每个键的权重，在做交集计算时，每个键中的每个member会将自己分数乘以这个权重，每个键的权重默认是1 aggregate sum|min|max - 计算成员交集后，分值可以按照sum（和）、min（最小值）、max（最大值）做汇总，默认值是 sum。 返回交集元素个数，结果存在新键中 并集 text zunionstore ... 和上面其他参数一样 2.6.3 内部编码 ziplist skiplist ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:6","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#261-集合内操作"},{"categories":["program"],"content":" 2.6 有序集合有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个分数（score）作为排序的依据。 可以实现排行榜 2.6.1 集合内操作 添加(修改)成员 text zadd key [nx|xx] [ch] [incr] score member [score member ...] zadd key score member [score member ...] 多个成员分数可以相同，返回成功插入个数 incr - score的意义变为在原有分数上加分，不存在元素分数为0, 只支持加入一个，相当于zincrby ch - 返回此次操作后，分数发生变化的元素个数，新加入元素也算分数变化 nx - 元素必须不存在，添加操作 xx - 元素必须存在，修改操作 返回元素个数 text zcard key 返回某个成员分数 text zscore key member 元素不存在返回nil 计算成员排名 text zrank key member zrevrank key member zrank是从低分到高分排序，zrevrank反之 不存在返回nil，排名从0开始 删除成员 text zrem key member [member ...] 返回实际删除个数，不存在的元素忽略 增加成员的分数 text zincrby key increment member 给member增加increment分，不存在元素初始分当作0，返回增加后分数 返回指定排名范围的成员 text zrange key start end [withscores] zrevrange key start end [withscores] zrange从低到高排名，zrevrange从高到低排序 withscores同时返回分数 text 127.0.0.1:6379\u003e ZRANGE zset 1 -1 withscores 1) \"cpp\" 2) \"2\" 3) \"go\" 4) \"2\" 5) \"incr\" 6) \"3\" 7) \"mem\" 8) \"3\" 9) \"mem1\" 10) \"3\" -1表示最后一名,从0开始 返回指定分数范围的成员 text zrangebyscore key min max [withscores] [limit offset count] zrevrangebyscore key max min [withscores] [limit offset count] (min max 表示min用开区间 min (max 表示max用开区间 -inf 无限小 +inf 无限大 [limit offset count] - 从offset偏移位置输出，输出count个，相当于分页查询 返回指定分数范围成员个数 text zcount key min max 也支持开区间 (min (max 支持无限 删除指定排名内的升序元素 text zremrangebyrank key start end 删除排名在[start,end]的元素 返回删除个数 删除指定分数范围的成员 text zremrangebyscore key min max 支持开区间，无限 返回删除个数 2.6.2 集合间操作 交集 text zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max] destination - 交集计算结果保存到这个键 numkeys - 需要做交集计算键的个数 key[key...] - 需要做交集计算的键 weights weight[weight...] - 每个键的权重，在做交集计算时，每个键中的每个member会将自己分数乘以这个权重，每个键的权重默认是1 aggregate sum|min|max - 计算成员交集后，分值可以按照sum（和）、min（最小值）、max（最大值）做汇总，默认值是 sum。 返回交集元素个数，结果存在新键中 并集 text zunionstore ... 和上面其他参数一样 2.6.3 内部编码 ziplist skiplist ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:6","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#262-集合间操作"},{"categories":["program"],"content":" 2.6 有序集合有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个分数（score）作为排序的依据。 可以实现排行榜 2.6.1 集合内操作 添加(修改)成员 text zadd key [nx|xx] [ch] [incr] score member [score member ...] zadd key score member [score member ...] 多个成员分数可以相同，返回成功插入个数 incr - score的意义变为在原有分数上加分，不存在元素分数为0, 只支持加入一个，相当于zincrby ch - 返回此次操作后，分数发生变化的元素个数，新加入元素也算分数变化 nx - 元素必须不存在，添加操作 xx - 元素必须存在，修改操作 返回元素个数 text zcard key 返回某个成员分数 text zscore key member 元素不存在返回nil 计算成员排名 text zrank key member zrevrank key member zrank是从低分到高分排序，zrevrank反之 不存在返回nil，排名从0开始 删除成员 text zrem key member [member ...] 返回实际删除个数，不存在的元素忽略 增加成员的分数 text zincrby key increment member 给member增加increment分，不存在元素初始分当作0，返回增加后分数 返回指定排名范围的成员 text zrange key start end [withscores] zrevrange key start end [withscores] zrange从低到高排名，zrevrange从高到低排序 withscores同时返回分数 text 127.0.0.1:6379\u003e ZRANGE zset 1 -1 withscores 1) \"cpp\" 2) \"2\" 3) \"go\" 4) \"2\" 5) \"incr\" 6) \"3\" 7) \"mem\" 8) \"3\" 9) \"mem1\" 10) \"3\" -1表示最后一名,从0开始 返回指定分数范围的成员 text zrangebyscore key min max [withscores] [limit offset count] zrevrangebyscore key max min [withscores] [limit offset count] (min max 表示min用开区间 min (max 表示max用开区间 -inf 无限小 +inf 无限大 [limit offset count] - 从offset偏移位置输出，输出count个，相当于分页查询 返回指定分数范围成员个数 text zcount key min max 也支持开区间 (min (max 支持无限 删除指定排名内的升序元素 text zremrangebyrank key start end 删除排名在[start,end]的元素 返回删除个数 删除指定分数范围的成员 text zremrangebyscore key min max 支持开区间，无限 返回删除个数 2.6.2 集合间操作 交集 text zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max] destination - 交集计算结果保存到这个键 numkeys - 需要做交集计算键的个数 key[key...] - 需要做交集计算的键 weights weight[weight...] - 每个键的权重，在做交集计算时，每个键中的每个member会将自己分数乘以这个权重，每个键的权重默认是1 aggregate sum|min|max - 计算成员交集后，分值可以按照sum（和）、min（最小值）、max（最大值）做汇总，默认值是 sum。 返回交集元素个数，结果存在新键中 并集 text zunionstore ... 和上面其他参数一样 2.6.3 内部编码 ziplist skiplist ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:6","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#263-内部编码"},{"categories":["program"],"content":" 2.7 键管理按照单个键、遍历键、数据库管理三个维度对一些通用命令进行介绍 2.7.1 单个键管理 重命名 text rename key newkey renamenx key newkey newkey - 如果已经存在，会被直接覆盖 renamenx - 这个命令会检查newkey是否存在，不存在才会成功 重命名期间会执行del删除旧的键，如果数据量大，时间比较多(阻塞) 随机返回一个键 text randomkey 键过期 text expire key seconds // 在seconds秒后过期 expireat key timestamp // 在秒级时间戳timestamp过期 pexpire key milliseconds // 在毫秒后过期 pexpireat key milliseconds-timestamp // 在毫秒级时间戳过期 persist key // 清除过期时间 以上所有命令内部都是使用pexpireat，键不存在返回0 如果键不存在，返回0，过期时间为负值则立即删除 对于字符串类型的键，set命令会取消过期时间 ttl和pttl都有可以查询键的剩余过期时间，后者毫秒级 返回\u003e0，剩余时间 -1，键没有设置过期时间 -2，键不存在 迁移键 text move key db // move命令用于在Redis内部进行数据迁移 bash dump key restore key ttl value // ttl存活时间，0为永久 // 直接在cli里使用出来的是个字符串 \"\\x0b\\x16\\x02\\x00\\x...c1*\\x8d\" // 命令行里使用如下 $ redis-cli -a 123456 dump set1 | head -c -1 \u003e file # 备份，head去掉文件末尾换行符0x0a $ cat file | redis-cli -a 123456 -x restore newset 0 # 恢复 text migrate host port key|\"\" destination-db timeout [copy] [replace] [keys key [key ...]] MIGRATE host port key| destination-db timeout [COPY] [REPLACE] [KEYS key] host 目标redis主机，port端口 key|\"\" - 早期migrate只支持迁移一个键，所以此处是要迁移的键，但Redis3.0.6版本之后支持迁移多个键，如果当前需要迁移多个键，此处为空字符串\"\" destination-db - 目标Redis的数据库索引0 - 15 timeout - 迁移的超时时间，毫秒 copy - 如果添加此选项，迁移后并不删除源键 replace - 不管目标Redis是否存在该键都会正常迁移进行数据覆盖。 [KEYSkey[key...]] - 迁移多个键，例如要迁移key1、key2、key3，此处填写keys key1 key2 key3 2.7.2 遍历键 全量遍历键 text keys pattern * - 匹配任意个字符，就是遍历所有 \\ - 转义 [] [1,3] [1-3] , 匹配部分字符 ? - 任意字符 bash $ redis-cli keys set\\* | xargs redis-cli del # 删除所有 set 开头的键, bash里 * 需要转义 如果耗时，会阻塞其他业务 渐进式遍历 text scan cursor [match pattern] [count number] cursor - 游标，从0开始，每次遍历完返回当前游标值，使用新下标继续遍历，返回0表示遍历结束 match pattern - 匹配模式 count number - 要遍历的个数，默认10 如果在scan的过程中如果有键的变化（增加、删除、修改），那么遍历效果可能会重复，遍历不到 2.7.3 数据库管理Redis默认配置中是有16个数据库，编号0 - 15，默认登录都在0号数据库 切换数据库 text select dbIndex 清空数据库 text flushdb // 清空当前数据库 flushall // 清空所有 ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:7","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#27-键管理"},{"categories":["program"],"content":" 2.7 键管理按照单个键、遍历键、数据库管理三个维度对一些通用命令进行介绍 2.7.1 单个键管理 重命名 text rename key newkey renamenx key newkey newkey - 如果已经存在，会被直接覆盖 renamenx - 这个命令会检查newkey是否存在，不存在才会成功 重命名期间会执行del删除旧的键，如果数据量大，时间比较多(阻塞) 随机返回一个键 text randomkey 键过期 text expire key seconds // 在seconds秒后过期 expireat key timestamp // 在秒级时间戳timestamp过期 pexpire key milliseconds // 在毫秒后过期 pexpireat key milliseconds-timestamp // 在毫秒级时间戳过期 persist key // 清除过期时间 以上所有命令内部都是使用pexpireat，键不存在返回0 如果键不存在，返回0，过期时间为负值则立即删除 对于字符串类型的键，set命令会取消过期时间 ttl和pttl都有可以查询键的剩余过期时间，后者毫秒级 返回\u003e0，剩余时间 -1，键没有设置过期时间 -2，键不存在 迁移键 text move key db // move命令用于在Redis内部进行数据迁移 bash dump key restore key ttl value // ttl存活时间，0为永久 // 直接在cli里使用出来的是个字符串 \"\\x0b\\x16\\x02\\x00\\x...c1*\\x8d\" // 命令行里使用如下 $ redis-cli -a 123456 dump set1 | head -c -1 \u003e file # 备份，head去掉文件末尾换行符0x0a $ cat file | redis-cli -a 123456 -x restore newset 0 # 恢复 text migrate host port key|\"\" destination-db timeout [copy] [replace] [keys key [key ...]] MIGRATE host port key| destination-db timeout [COPY] [REPLACE] [KEYS key] host 目标redis主机，port端口 key|\"\" - 早期migrate只支持迁移一个键，所以此处是要迁移的键，但Redis3.0.6版本之后支持迁移多个键，如果当前需要迁移多个键，此处为空字符串\"\" destination-db - 目标Redis的数据库索引0 - 15 timeout - 迁移的超时时间，毫秒 copy - 如果添加此选项，迁移后并不删除源键 replace - 不管目标Redis是否存在该键都会正常迁移进行数据覆盖。 [KEYSkey[key...]] - 迁移多个键，例如要迁移key1、key2、key3，此处填写keys key1 key2 key3 2.7.2 遍历键 全量遍历键 text keys pattern * - 匹配任意个字符，就是遍历所有 \\ - 转义 [] [1,3] [1-3] , 匹配部分字符 ? - 任意字符 bash $ redis-cli keys set\\* | xargs redis-cli del # 删除所有 set 开头的键, bash里 * 需要转义 如果耗时，会阻塞其他业务 渐进式遍历 text scan cursor [match pattern] [count number] cursor - 游标，从0开始，每次遍历完返回当前游标值，使用新下标继续遍历，返回0表示遍历结束 match pattern - 匹配模式 count number - 要遍历的个数，默认10 如果在scan的过程中如果有键的变化（增加、删除、修改），那么遍历效果可能会重复，遍历不到 2.7.3 数据库管理Redis默认配置中是有16个数据库，编号0 - 15，默认登录都在0号数据库 切换数据库 text select dbIndex 清空数据库 text flushdb // 清空当前数据库 flushall // 清空所有 ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:7","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#271-单个键管理"},{"categories":["program"],"content":" 2.7 键管理按照单个键、遍历键、数据库管理三个维度对一些通用命令进行介绍 2.7.1 单个键管理 重命名 text rename key newkey renamenx key newkey newkey - 如果已经存在，会被直接覆盖 renamenx - 这个命令会检查newkey是否存在，不存在才会成功 重命名期间会执行del删除旧的键，如果数据量大，时间比较多(阻塞) 随机返回一个键 text randomkey 键过期 text expire key seconds // 在seconds秒后过期 expireat key timestamp // 在秒级时间戳timestamp过期 pexpire key milliseconds // 在毫秒后过期 pexpireat key milliseconds-timestamp // 在毫秒级时间戳过期 persist key // 清除过期时间 以上所有命令内部都是使用pexpireat，键不存在返回0 如果键不存在，返回0，过期时间为负值则立即删除 对于字符串类型的键，set命令会取消过期时间 ttl和pttl都有可以查询键的剩余过期时间，后者毫秒级 返回\u003e0，剩余时间 -1，键没有设置过期时间 -2，键不存在 迁移键 text move key db // move命令用于在Redis内部进行数据迁移 bash dump key restore key ttl value // ttl存活时间，0为永久 // 直接在cli里使用出来的是个字符串 \"\\x0b\\x16\\x02\\x00\\x...c1*\\x8d\" // 命令行里使用如下 $ redis-cli -a 123456 dump set1 | head -c -1 \u003e file # 备份，head去掉文件末尾换行符0x0a $ cat file | redis-cli -a 123456 -x restore newset 0 # 恢复 text migrate host port key|\"\" destination-db timeout [copy] [replace] [keys key [key ...]] MIGRATE host port key| destination-db timeout [COPY] [REPLACE] [KEYS key] host 目标redis主机，port端口 key|\"\" - 早期migrate只支持迁移一个键，所以此处是要迁移的键，但Redis3.0.6版本之后支持迁移多个键，如果当前需要迁移多个键，此处为空字符串\"\" destination-db - 目标Redis的数据库索引0 - 15 timeout - 迁移的超时时间，毫秒 copy - 如果添加此选项，迁移后并不删除源键 replace - 不管目标Redis是否存在该键都会正常迁移进行数据覆盖。 [KEYSkey[key...]] - 迁移多个键，例如要迁移key1、key2、key3，此处填写keys key1 key2 key3 2.7.2 遍历键 全量遍历键 text keys pattern * - 匹配任意个字符，就是遍历所有 \\ - 转义 [] [1,3] [1-3] , 匹配部分字符 ? - 任意字符 bash $ redis-cli keys set\\* | xargs redis-cli del # 删除所有 set 开头的键, bash里 * 需要转义 如果耗时，会阻塞其他业务 渐进式遍历 text scan cursor [match pattern] [count number] cursor - 游标，从0开始，每次遍历完返回当前游标值，使用新下标继续遍历，返回0表示遍历结束 match pattern - 匹配模式 count number - 要遍历的个数，默认10 如果在scan的过程中如果有键的变化（增加、删除、修改），那么遍历效果可能会重复，遍历不到 2.7.3 数据库管理Redis默认配置中是有16个数据库，编号0 - 15，默认登录都在0号数据库 切换数据库 text select dbIndex 清空数据库 text flushdb // 清空当前数据库 flushall // 清空所有 ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:7","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#272-遍历键"},{"categories":["program"],"content":" 2.7 键管理按照单个键、遍历键、数据库管理三个维度对一些通用命令进行介绍 2.7.1 单个键管理 重命名 text rename key newkey renamenx key newkey newkey - 如果已经存在，会被直接覆盖 renamenx - 这个命令会检查newkey是否存在，不存在才会成功 重命名期间会执行del删除旧的键，如果数据量大，时间比较多(阻塞) 随机返回一个键 text randomkey 键过期 text expire key seconds // 在seconds秒后过期 expireat key timestamp // 在秒级时间戳timestamp过期 pexpire key milliseconds // 在毫秒后过期 pexpireat key milliseconds-timestamp // 在毫秒级时间戳过期 persist key // 清除过期时间 以上所有命令内部都是使用pexpireat，键不存在返回0 如果键不存在，返回0，过期时间为负值则立即删除 对于字符串类型的键，set命令会取消过期时间 ttl和pttl都有可以查询键的剩余过期时间，后者毫秒级 返回\u003e0，剩余时间 -1，键没有设置过期时间 -2，键不存在 迁移键 text move key db // move命令用于在Redis内部进行数据迁移 bash dump key restore key ttl value // ttl存活时间，0为永久 // 直接在cli里使用出来的是个字符串 \"\\x0b\\x16\\x02\\x00\\x...c1*\\x8d\" // 命令行里使用如下 $ redis-cli -a 123456 dump set1 | head -c -1 \u003e file # 备份，head去掉文件末尾换行符0x0a $ cat file | redis-cli -a 123456 -x restore newset 0 # 恢复 text migrate host port key|\"\" destination-db timeout [copy] [replace] [keys key [key ...]] MIGRATE host port key| destination-db timeout [COPY] [REPLACE] [KEYS key] host 目标redis主机，port端口 key|\"\" - 早期migrate只支持迁移一个键，所以此处是要迁移的键，但Redis3.0.6版本之后支持迁移多个键，如果当前需要迁移多个键，此处为空字符串\"\" destination-db - 目标Redis的数据库索引0 - 15 timeout - 迁移的超时时间，毫秒 copy - 如果添加此选项，迁移后并不删除源键 replace - 不管目标Redis是否存在该键都会正常迁移进行数据覆盖。 [KEYSkey[key...]] - 迁移多个键，例如要迁移key1、key2、key3，此处填写keys key1 key2 key3 2.7.2 遍历键 全量遍历键 text keys pattern * - 匹配任意个字符，就是遍历所有 \\ - 转义 [] [1,3] [1-3] , 匹配部分字符 ? - 任意字符 bash $ redis-cli keys set\\* | xargs redis-cli del # 删除所有 set 开头的键, bash里 * 需要转义 如果耗时，会阻塞其他业务 渐进式遍历 text scan cursor [match pattern] [count number] cursor - 游标，从0开始，每次遍历完返回当前游标值，使用新下标继续遍历，返回0表示遍历结束 match pattern - 匹配模式 count number - 要遍历的个数，默认10 如果在scan的过程中如果有键的变化（增加、删除、修改），那么遍历效果可能会重复，遍历不到 2.7.3 数据库管理Redis默认配置中是有16个数据库，编号0 - 15，默认登录都在0号数据库 切换数据库 text select dbIndex 清空数据库 text flushdb // 清空当前数据库 flushall // 清空所有 ","date":"2019-08-16","objectID":"/redis-operation-manual/:2:7","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#273-数据库管理"},{"categories":["program"],"content":" 3 编程语言中使用","date":"2019-08-16","objectID":"/redis-operation-manual/:3:0","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#3-编程语言中使用"},{"categories":["program"],"content":" 3.1 go bash $ go get github.com/garyburd/redigo/redis go package main import ( \"fmt\" \"github.com/garyburd/redigo/redis\" \"os\" \"reflect\" ) func main() { c, err := redis.Dial(\"tcp\", \"192.168.0.101:6379\", ) if err != nil { fmt.Println(err) os.Exit(1) } defer c.Close() err = c.Send(\"auth\", \"123456\") if err != nil { fmt.Println(err) os.Exit(1) } ret, err := c.Do(\"set\", \"testkey\", \"my name is ??\") // ret, err := c.Do(\"set\", \"testkey\", \"my name is ??\", \"EX\", 5) 设置超时 if err != nil { fmt.Println(err) os.Exit(1) } fmt.Println(reflect.TypeOf(ret), ret) name, err := redis.String(c.Do(\"get\", \"testkey\")) if err != nil { fmt.Println(err) os.Exit(1) } fmt.Println(name) } /* string OK my name is ?? */ ","date":"2019-08-16","objectID":"/redis-operation-manual/:3:1","series":null,"tags":["nosql","redis"],"title":"Redis操作手册","uri":"/redis-operation-manual/#31-go"},{"categories":["default"],"content":" 第一章 概率论的基本概念","date":"2019-06-23","objectID":"/probability-theory-note/:1:0","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#第一章--概率论的基本概念"},{"categories":["default"],"content":" 1.1 样本空间，随机事件 样本空间 样本空间：随机试验$E $所有可能的结果组成的集合称为样本空间，记为$S$（或者称为$Ω$） 样本点：样本空间的元素, 即试验$E $的每个可能的结果, 称为样本点 (or基本事件) 常记为$e $，$S = {e1,e2…..}$ 随机事件 随机事件： 样本空间$S$的子集,用大写字母$Ａ、Ｂ、Ｃ$等表示 事件发生：所谓事件$A$发生，当且仅当这个子集中的一个样本点出现 基本事件：仅含一个样本点的随机事件 事件之间的运算 交换律：$A\\cup B=B\\cup A$，$AB=BA$ 结合律：$(A\\cup B)\\cap C=A\\cup (B\\cup C)$ 分配律：$A(B\\cup C)=(AB)\\cup (AC)$，$A\\cup(BC)=(A\\cup B)(A\\cup C)$ 德·摩根律：$\\overline{AB}=\\overline{A}\\cup\\overline{B}​$，$\\overline{A\\cup B}=\\overline{A} \\overline{B}​$ ","date":"2019-06-23","objectID":"/probability-theory-note/:1:1","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#11--样本空间随机事件"},{"categories":["default"],"content":" 1.2 频率与概率随机事件德频率：$f_n(A)=\\frac{事件A出现的次数m}{实验总次数n}$ 概率性质： $P(\\varnothing)=0​$ 有限可加性：$P(\\cup^n_{i=1}A_i)=\\sum^n_{i=1}P(A_i)​$，$A_i​$互不相容，$P(A \\cup B)=P(A)+P(B),AB=\\Phi_{零事件}​$ $P(B-A)=P(B)-P(AB)$ $P(A \\cup B)=P(A)+P(B)-P(AB)$ 加法定理：$P(A \\cup B\\cup C)=P(A)+P(B)+P(C)-P(AB)-P(BC)-P(AC)+P(ABC)​$ $P(\\overline{A})=1-P(A)$ 一般地，设盒中有$N$个球，其中有$M$个白球，现从中任抽$n$个球，则这$n$个球中恰有$k$个白球的概率是：$P=\\frac{C^k_MC^{n-k}_{N-M}}{C^n_n}​$ ","date":"2019-06-23","objectID":"/probability-theory-note/:1:2","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#12-频率与概率"},{"categories":["default"],"content":" 1.3 条件概率与贝叶斯公式条件概率：$P(B|A)=\\frac{P(AB)}{P(A)}$ 性质： $P(B|A)\\ge0$ $P(S_{整体}|A)=1​$ 可列可加性：$P(\\cup^n_{i=1}B_i|A_i)=\\sum^n_{i=1}P(B_i|A_i)$，$B_i$互不相容 $P(B_1\\cup B_2|A)=P(B_1|A)+P(B_2|A)-P(B_1B_2|A)$ $P(\\overline{B}|A)=1-P(B|A)$ $P(B_1-B_2|A)=P(B_1|A)-P(B_1B_2|A)$ 乘法法则：$P(ABC)=P(A)P(B|A)P(C|AB)$ 全概率公式 设$B_1,B_2,…,B_n$是$S$的一个划分，且$P(S_i)\u003e0$，则对于任意事件$A\\in S$有： $P(A)=\\sum^n_{i=1}P(B_i)P(A|B_i)$，每个划分上$A$出现的概率相加就是$A在S$上出现的概率 贝叶斯公式 设$B_1,B_2,…,B_n$是$S$的一个划分，且$P(S_i)\u003e0$，$A$为$ S$任意事件，$P(A)\u003e0$,则： $P(B_i|A)=\\frac{P(B_i)P(A|B_i)}{sum^n_{j=1}P(B_j)P(A|B_j)}=\\frac{P(B_i)P(A|B_i)}{P(A)}$ $A$已经发生，求$A$发生在划分$B_i$上的概率，就是$A$发生在划分$B_i$上的概率除以$A$在$S$上发生的概率. ","date":"2019-06-23","objectID":"/probability-theory-note/:1:3","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#13--条件概率与贝叶斯公式"},{"categories":["default"],"content":" 1.4 事件独立性定义：事件$A$发生对$B$发生的概率没有影响，可视为事件$A$与$B$相互独立，即： $P(B|A)=P(B),P(AB)=P(A)P(B)$ 性质：事件$A，B$独立 和 事件$A，B$互不相容 不能同时成立。 下列四组事件，有相同独立性：一组互相独立，其他也独立 $A与B$ $A与\\overline{B}$ $\\overline{A}与B$ $\\overline{A}与\\overline{B}​$ 事件$A，B，C$相互独立与事件$A，B，C$两两独立不同 ","date":"2019-06-23","objectID":"/probability-theory-note/:1:4","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#14--事件独立性"},{"categories":["default"],"content":" 第二章 随机变量及其分布","date":"2019-06-23","objectID":"/probability-theory-note/:2:0","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#第二章--随机变量及其分布"},{"categories":["default"],"content":" 2.1 随机变量分布律的性质： 非负性：$p_k\\ge0,k=1,2,…$ 归一性：$\\sum^\\infty_{k=1}p_k=1$ ","date":"2019-06-23","objectID":"/probability-theory-note/:2:1","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#21-随机变量"},{"categories":["default"],"content":" 2.2 离散随机变量及其分布0-1分布： $X$ $0$ $1$ $P$ $1-p$ $p$ 二项分布：$X\\sim b(n,p)​$ $P{X=k}=C^k_np^kq^{n-k},k=0,1,2,…,n$ 泊松定理：当二项分布$n$较大，$p$较小（一般$n\u003e20,p\u003c0.05$）,有 $C^k_np^k(1-p)^{n-k}\\approx\\frac{e^{-\\lambda}\\lambda^k}{k!},k=0,1,2…$ 式中$\\lambda=np​$ 泊松分布：$X\\sim \\pi(\\lambda)$ $P{X=k}=e^{-\\lambda}\\frac{\\lambda^k}{k!}$ ","date":"2019-06-23","objectID":"/probability-theory-note/:2:2","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#22-离散随机变量及其分布"},{"categories":["default"],"content":" 2.3 随机变量的分布函数定义：设$X$为随机变量，$x$是任意实数，称函数 $F(x)=P{X\\le x},-\\infty\u003cx\u003c+\\infty$ 为X的分布函数 离散型：点点计较 $F(X)=P{X\\le x}=\\sum_{k:x_k\u003cx}p_k$ 连续型：$F(X)=P{X\\le x}=\\int_{-\\infty}^xf(t)dt$ ","date":"2019-06-23","objectID":"/probability-theory-note/:2:3","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#23--随机变量的分布函数"},{"categories":["default"],"content":" 2.4 连续随机变量及其概率密度连续型：$F(X)=P{X\\le x}=\\int_{-\\infty}^xf(t)dt$ 其中$f(x)$称为$X$的概率密度函数，常写为 $X\\sim f(x)$ 概率密度函数性质： 非负性：$f(x)\\ge0,\\forall x\\in(-\\infty,+\\infty)$ 规范性：$\\int^{+\\infty}_{-\\infty}f(x)dx=1$ 几个常用连续性分布 均匀分布： $$ X\\sim f(x)= \\left \\{ \\begin{aligned} {\\frac{1}{b-a}} ,a\\lt x\\lt b\\\\ 0,其他 \\end{aligned} \\right. $$ 指数分布：$X\\sim E(\\theta)$ $$ f(x)=\\left\\{ \\begin{aligned} {\\frac{1}{\\theta}}e^{-\\frac{x}{\\theta}},x\u003e0\\\\ 0,x\\le 0 \\end{aligned} \\right. $$ 分布函数 $$ f(x)=\\left\\{ \\begin{aligned} {1-}e^{-\\frac{x}{\\theta}},x\u003e0\\\\ 0,x\\le 0 \\end{aligned} \\right. $$ 指数分布无记忆性：$P{X\u003es+t|X\u003es}=P{X\u003et}$ 正态分布：$X\\sim N(\\mu,\\sigma^2)$ $$ f(X)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-u)^2}{2\\sigma^2}} $$ 定义 $X\\sim N(0,1)$为标准正太分布，密度函数$\\varphi(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}$，分布函数$\\Phi(x)$ 一般正太分布标准化：$Z=\\frac{x-\\mu}{\\sigma}\\sim N(0,1)$ ","date":"2019-06-23","objectID":"/probability-theory-note/:2:4","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#24-连续随机变量及其概率密度"},{"categories":["default"],"content":" 2.5 随机变量的函数的分布对于离散型，用分布表 连续型随机变量的函数的分布 设X为一个连续型随机变量，其概率密度函数为$f(X)$，$y=g(x)$为一个连续函数，求随机变量$Y=g(X)$的概率密度函数 求$Y$的分布函数$F_Y(y)$ $F_Y(y)=P(Y\\le y)=P{g(X)\u003c=y}=\\int_{g(x)\\le y}f(x)dx​$ 对$F_Y(y)$求导，得到$f_Y(y)$ $f_Y(y)=(F_Y(y))‘​$ 定理：正态分布的线性函数仍服从正态分布 设$X \\sim N(\\mu,\\sigma^2),Y=aX+bY(a\\ne 0)$，则$Y \\sim N(a\\mu+b,(a\\sigma)^2)$ ","date":"2019-06-23","objectID":"/probability-theory-note/:2:5","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#25--随机变量的函数的分布"},{"categories":["default"],"content":" 第三章 二维随机变量及其分布","date":"2019-06-23","objectID":"/probability-theory-note/:3:0","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#第三章--二维随机变量及其分布"},{"categories":["default"],"content":" 3.1 二维随机变量定义：设$X、Y$ 为定义在同一样本空间$Ω$上的随机变量，则称向量$(X,Y)$为$Ω$上的一个二维随机变量。 二维变量联合分布函数： $F(x,y)=P{X\\le x \\cap Y\\le y}=^{记作}P{X\\le x,Y\\le y}​$ 离散型：$F(x,y)=\\sum_{x_i\u003cx}\\sum_{y_j\u003cy}p_{ij}$ 连续型：$F(x,y)=\\int_{-\\infty}^x\\int_{-\\infty}^yf(u,v)dudv​$ $f(x,y)$称为联合密度函数 ","date":"2019-06-23","objectID":"/probability-theory-note/:3:1","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#31--二维随机变量"},{"categories":["default"],"content":" 3.2 边缘分布设二维随机变量$(X,Y)$的分布函数为$F(x,y)$， $F_X(x)=P{X\\le x}=P{X\\le x,Y\u003c+\\infty}=F(x,+\\infty)​$ $F_Y(y)=P{Y\\le y}=P{X\u003c +\\infty,Y\\le y}=F(+\\infty,y)$ 连续型： $F_X(x)=F(x,+\\infty)=\\int^x_{-\\infty}[\\int^{+\\infty}_{-\\infty}f(x,y)dy]dx$ 边缘概率密度函数： $f_X(x)=\\int^{+\\infty}_{-\\infty}f(x,y)dy​$ $f_Y(y)=\\int^{+\\infty}_{-\\infty}f(x,y)dx$ ","date":"2019-06-23","objectID":"/probability-theory-note/:3:2","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#32--边缘分布"},{"categories":["default"],"content":" 3.3 条件分布","date":"2019-06-23","objectID":"/probability-theory-note/:3:3","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#33--条件分布"},{"categories":["default"],"content":" 3.4 独立性若$F(x,y)=F_X(x)F_Y(y)$，则$X,y$相互独立，$f(x,y)=f_X(x)f_Y(y)$ ","date":"2019-06-23","objectID":"/probability-theory-note/:3:4","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#34--独立性"},{"categories":["default"],"content":" 第四章 随机变量的数字特征","date":"2019-06-23","objectID":"/probability-theory-note/:4:0","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#第四章--随机变量的数字特征"},{"categories":["default"],"content":" 4.1 数学期望离散型随机变量数学期望：$E(x)=\\sum^{+\\infty}_{k=1}x_kp_k​$ 连续性随机变量数学期望：$E(X)=\\int^{+\\infty}_{-\\infty}xf(x)dx$ 随机变量的函数的数学期望 一维情形：设$Y=g(X)$是随机变量$X$的函数 ​ 离散型：$E(Y)=E[g(X)]=\\sum^\\infty_{k=1}g(x_k)p_k$ ​ 连续型：概率密度为$f(x)$，$E(Y)=E[g(X)]=\\int^{+\\infty}_{-\\infty}g(x)f(x)dx$ 二维情形：设$Z=g(X,Y)$是随机变量$X,Y$的函数 ​ 离散型：$P{X=x_i,Y=y_i}=p_{ij}$，$E[g(X,Y)]=\\sum_i\\sum_jg(x_i,y_j)p_{ij}$ ​ 连续型：联合概率密度$f(x,y)$，$E[g(X,Y)]=\\int^{+\\infty}_{-\\infty}\\int^{+\\infty} _{-\\infty}g(x,y)f(x,y)dxdy$ 数学期望的性质 $E(C)=C​$，$C​$为常数 $E(CX)=CE(X)​$ $E(X+Y)=E(X)+E(Y)​$ $X,Y$相互独立时：$E(XY)=E(X)E(Y)$ ","date":"2019-06-23","objectID":"/probability-theory-note/:4:1","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#41--数学期望"},{"categories":["default"],"content":" 4.2 方差定义：若$E{[X-E(X)]^2}$存在，则称其为随机变量$X$的方差，记为$D(X)$。 若$X$为离散型：$D(X)=\\sum^{+\\infty}_{k=1}(x_k-E(X))^2p_k$ 若$X$为连续型：$D(X)=\\int^{+\\infty}_{-\\infty}(x-E(X))^2f(x)dx$ 计算方差常用公式：$D(X)=E(X^2)-E(X)^2$ 方差的性质 $D(C)=0$ $D(aX+b)=a^2D(X)$ $D(X\\pm Y)=D(X)+D(Y)\\pm 2E((X-E(X))(Y-E(Y)))​$ 若$X,Y$相互独立：$D(X\\pm Y)=D(X)+D(Y)$ 二维随机变量方差： $D(X,Y)=(D(X),D(Y))$ $D(X)=\\int^{+\\infty} _{-\\infty}[x-E(X)]^2f_x(x)dx=\\int^{+\\infty} _{-\\infty}\\int^{+\\infty} _{-\\infty}[x-E(X)]^2f(x,y)dxdy​$ $D(Y)=\\int^{+\\infty} _{-\\infty}[y-E(Y)]^2f_y(y)dx=\\int^{+\\infty} _{-\\infty}\\int^{+\\infty} _{-\\infty}[y-E(Y)]^2f(x,y)dxdy​$ 常用：若$X_i\\sim N(\\mu_i,\\sigma_i^2),i=1,2,…,n​$，且他们相互独立，他们的线性组合$C_1X_1+C_2X_2+…+C_nX_n​$仍然服从正态分布：$C_1X_1+C_2X_2+…+C_nX_n\\sim N(C_1\\mu_1+C_2\\mu_2+…+C_n\\mu_n,\\sigma^2_1+\\sigma^2_2+…+\\sigma^2_n)​$ 分布 密度函数 期望 方差 二项分布$X\\sim B(n,p)$ $p{X=k}=C^k_np^k(1-p)^{n-k}$ $np$ $np(1-p)$ 泊松分布$X\\sim P(\\lambda)$ $p{X=k}=\\frac{\\lambda^k}{k!}e^{-\\lambda}$ $\\lambda$ $\\lambda$ 均匀分布 $f(x)=\\left\\{\\begin{aligned}\\frac{1}{b-a}，a\u003cx\u003cb\\\\ 0,其他\\end{aligned}\\right.$ $\\frac{a+b}{2}$ $\\frac{1}{12}(b-a)^2$ 正态分布$X\\sim N(\\mu,\\sigma^2)$ $f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$ $\\mu$ $\\sigma ^2$ 指数分布 $f(x)=\\left\\{\\begin{aligned}\\frac{1}{\\theta}e^{-\\frac{x}{\\theta}}，x\u003e0\\\\0,x\\le0\\end{aligned}\\right.$ $\\theta$ $\\theta^2$ ","date":"2019-06-23","objectID":"/probability-theory-note/:4:2","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#42-方差"},{"categories":["default"],"content":" 4.3 协方差及相关系数定义：称$E([X-E(X)][Y-E(Y)])​$为$X,Y​$的协方差，记为$cov(X,Y)=E([X-E(X)][Y-E(Y)])​$ 离散型： $cov(X,Y)=\\sum^{+\\infty}_{i=1}\\sum^{+\\infty}_{j=1}[x_i-E(X)][y_j-E(Y)]p_{ij}$ 连续型： $cov(X,Y)=\\int^{+\\infty}_{-\\infty}\\int^{+\\infty}_{-\\infty}[x-E(X)][y-E(Y)]f(x,y)dxdy​$ 当$COV(X,Y)\u003e0$时，称$X$与$Y$正相关；当$COV(X,Y)\u003c0$时，称$X$与$Y$负相关；当$COV(X,Y)=0$时，称$X$与$Y$不相关 协方差计算：$cov(X,Y)=E(XY)-E(X)E(Y)$，或方差性质计算 性质： $cov(X,Y)=cov(Y,X)$ $cov(aX,bY)=abcov(X,Y)$ $cov(X+Y,Z)=cov(X,Z)+cov(Y,Z)$ $cov(X,X)=D(X)​$ 相关系数：$\\rho_{XY}=\\frac{cov(X,Y)}{\\sqrt{D(X)}\\sqrt{D(Y)}}$ $|\\rho_{XY}|\\le1$ $|\\rho_{XY}=1|$称$X$与$Y$全相关，存在常数$a,b$,使$P{Y=aX+b}=1$ ","date":"2019-06-23","objectID":"/probability-theory-note/:4:3","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#43--协方差及相关系数"},{"categories":["default"],"content":" 第五章 大数定律及中心极限定理","date":"2019-06-23","objectID":"/probability-theory-note/:5:0","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#第五章-大数定律及中心极限定理"},{"categories":["default"],"content":" 5.1 大数定律 切比雪夫不等式 设随机变量$X$的方差$D(X)$存在，则对于任意实数$\\varepsilon\u003e0$： $$P(|X-E(X)|\\ge\\varepsilon)\\le\\frac{D(X)}{\\varepsilon^2}$$，等价于：$P(|X-E(X)|\u003c\\varepsilon)\\ge1-\\frac{D(X)}{\\varepsilon^2}$ 说明：粗鲁哦估计$X$与均值之间范围的关系，实际很少运用 ","date":"2019-06-23","objectID":"/probability-theory-note/:5:1","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#51--大数定律"},{"categories":["default"],"content":" 5.2 中心极限定理客观背景：客观实际中，许多随机变量是由大量 相互独立的偶然因素的综合影响所形成，每一个微小 因素，在总的影响中所起的作用是很小的，但总起来， 却对总和有显著影响，这种随机变量往往近似地服从正态分布。 研究在什么条件下，大量独立随机变量和的分布以正态分布为极限，这一类定理称为中心极限定理。 定理1 应用： 对于独立的随机变量序列${X_n}$，不管$X_i(i=1,2,…,n)$服从什么分布，只要他们是独立同分布，且有相同的数学期望和方差，那么，当$n$充分大时，这些随机变量之和$\\sum^n_{i=1}X_i\\sim^{近似}N(n\\mu,n\\sigma^2)$。$\\bar{X} \\sim N(\\mu,\\frac{\\sigma^2}{n})$ 定理2 二项分布的极限分布是正态分布：当n很大，p不是很小时，不能再用泊松定理 设$Y_n \\sim B(n,p)$，当$n$很大时，$Y_n \\sim^{近似} N(np,np(1-p))$。 ","date":"2019-06-23","objectID":"/probability-theory-note/:5:2","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#52--中心极限定理"},{"categories":["default"],"content":" 第六章 样本与统计量","date":"2019-06-23","objectID":"/probability-theory-note/:6:0","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#第六章--样本与统计量"},{"categories":["default"],"content":" 6.1 随机样本 总体和样本 总体 —— 所研究的对象的某个(或某些)数量指标的全体,它是一个随机变量(或多维随机变量). 记为X. 个体 ——即总体的每个数量指标,可看作随机变量$X$ 的某个取值.用$X_i$表示. 容量 ——总体中所包含个体的个数 有限总体 ——容量为有限的总体 无限总体—— 容量为无限的总体 样本 —— 从总体中抽取的部分个体.用$(X1,X2,…Xn)​$表示,$ n​$为样本容量。在数理统计中，有意义的样本容量一般要求$n≥50​$才有统计意义 设总体$X$的分布函数为$F(X)$,则样本$(X_1,X_2…X_n)$的联合分布函数为： $$ F_总(X_1,X_2,…,X_n)=\\prod^n_{i=1}F(x_i)​$$ 若总体$X$的概率密度为$f(X)$,则样本的联合概率密度为： $$ f_总(X_1,X_2,…,X_n)=\\prod^n_{i=1}f(x_i)$$ 统计量 样本是统计推断的依据，但在实际问题中，往往不是直接使用样本本身，而是针对不同的问题构造不同的样本函数，利用这种样本的函数进行统计推断。这个构造出来的函数，就是统计量 ！ 设$(X_1,X_2,…X_n)$是取自总体$X$的一个样本，$g(X_1,X_2,…X_n)$是$(X_1,X_2,…X_n)$且步含有未知参数的实值连续函数，则称随机变量$g(X_1,X_2,…X_n)$为统计量 若$(x_1,x_2,…x_n)$是一个样本值，称$g(x_1,x_2,…x_n)​$为统计量的一个样本值 几个常用的统计量： 样本均值(sample mean)：$\\bar{X}=\\frac{1}{n}\\sum^n_{i=1}X_i​$ 样本方差(sample variance)：$S^2=\\frac{1}{n-1}\\sum^n_{i=1}(X_i-\\bar{X})^2=\\frac{1}{n-1}(\\sum^n_{i=1}X_i^2-n\\bar{X}^2)$ 样本均方差或标准差：$S=\\sqrt{\\frac{1}{n-1}\\sum^n_{i=1}(X_i-\\bar{X})^2}​$ 样本$K$阶原点矩：$A_k=\\frac{1}{n}\\sum^n_{i=1}X^k_i$ 样本$K​$阶中心距：$\\frac{1}{n}\\sum^n_{i=1}(X_i-\\bar{X})^k​$ $k$阶矩的概念： 定义：设$X$为随机变量，若$E(|X|^k)$存在，则称$E(X^k)$为$X$的$k$阶原点矩，记作$\\mu^k=E(X^k)$ 样本的$k$阶原点矩，记作$A_k=\\frac{1}{n}\\sum^n_{i=1}X_i^k​$ 结论：$A^k\\xrightarrow{P}\\mu^k,(n\\rightarrow\\infty),k=1,2…​$ 辛钦大数定理 矩估计法的理论依据 ","date":"2019-06-23","objectID":"/probability-theory-note/:6:1","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#61--随机样本"},{"categories":["default"],"content":" 6.2 抽样分布统计量的分布称为抽样分布。在使用统计量进行统计推断时常需要知道它的分布。当总体的分布函数为已知时，抽样分布是确定的，然而要求出统计量的精确分布，一般来说是困难的。 由于正态总体是最常见的总体，因此这里主要讨论正态总体下的抽样分布 数理统计的三大分布：$\\chi^2分布$ $t分布$ $F分布$，他们都与正太分布有密切的联系。 $\\chi^2分布​$ 定义：设总体$X\\sim N(0,1)​$，$(X_1,X_2,…,X_n)​$是$X​$的一个样本，则称统计量$\\chi^2=X_1^2+X_2^2+…+X_n^2​$服从自由度为$n​$的$\\chi^2分布​$,记作$\\chi^2\\sim \\chi^2(n)​$ 自由度是指独立随机变量的个数，$\\chi^2分布$的密度函数为： $$ f(y)=\\left\\{ \\begin{aligned} {\\frac{1}{2^{n/2}\\Gamma(n/2)}y^{n/2-1}e^{-y/2}},y\\ge0\\\\ 0,y\u003c0 \\end{aligned} \\right.。。。\\Gamma(n+1)=n! $$ 其图形随自由度的不同而有所改变.也就是说，当样本量超过10的时候很接近了正态分布！ $\\chi^2分布$的上$\\alpha$分位点：满足$P{\\chi^2(n)\u003e\\chi_\\alpha^2(n)}=\\int_{\\chi^2(n)}^{+\\infty}f(y)dy=\\alpha$的数$\\chi^2_\\alpha(n)$为$\\chi^2$分布的上$\\alpha$分位点。 性质： 期望与方差：设$\\chi^2 \\sim \\chi^2(n)​$，则$E(\\chi^2)=n​$，$D(\\chi^2)=2n​$ $\\chi^2分布$的可加性：设$\\chi^2_1 \\sim \\chi^2(n_1)$，$\\chi^2_2 \\sim \\chi^2(n_2)$，$\\chi^2_1 $与$\\chi^2_1 $ 相互独立，则$\\chi^2_1+\\chi^2_1 \\sim \\chi^2(n_1+n_2) $ 若$X_1,X_2,…,X_n$相互独立，都服从$N(0,1)$， 则$X_1^2+X_2^2+…+X_n^ 2~ \\chi^2 (n)$，反之若$X \\sim \\chi^2 (n)$ ，则$X$可以分解成$ n $个相互独立的标准正态随机变量的平方和。 $t分布​$ 定义：设随机变量$X \\sim N(0,1)​$，$Y \\sim \\chi^2(n)​$，且$X​$与$Y​$相互独立，则称统计量$T=\\frac{X}{\\sqrt{Y/n}}​$服从自由度为$n​$的$t​$分布或学生氏分布，记作$T \\sim t(n)​$. $t$分布的概率密度为：$f(t)=\\frac{\\Gamma(\\frac{n+1}{2})}{\\sqrt{n\\pi}\\Gamma(\\frac{n}{2})}(1+\\frac{t^2}{n})^{-\\frac{n+1}{2}},-\\infty\u003ct\u003c+\\infty$ 其形状类似标准正太分布，$n​$较大时，$t​$分布近似于标准正太分布，当$n\u003e30​$时，$t​$分布与标准正态分布$N(0，1)​$就非常接近. 性质： 若$X \\sim N(0,1)​$，$Y \\sim \\chi^2(n)​$，且$X​$与$Y​$相互独立，则$T=\\frac{X}{\\sqrt{Y/n}}​$。反之若$T=\\frac{X}{\\sqrt{Y/n}}​$，则有互相独立的$X \\sim N(0,1)​$，$Y \\sim \\chi^2(n)​$，使得$T=\\frac{X}{\\sqrt{Y/n}}​$。 $f(t)​$是偶函数 对于给定的$\\alpha(0\u003c\\alpha\u003c1)​$，称满足条件$P{T\u003et_\\alpha(n)}=\\int_{t_\\alpha{n}}^{+\\infty}f(t)dt=\\alpha​$的数$t_\\alpha(n)​$为$t​$分布的上$\\alpha​$分位点。 $F分布$ 定义：设随机变量$X \\sim \\chi^2(n_1)$，$Y \\sim \\chi^2(n_2)$，且相互独立，则称随机变量$F=\\frac{X/n_1}{Y/n_2}$服从第一自由度为$n_1$，第二自由度为$n_2$的$F$分布，记作$F \\sim F(n_1,n_2)​$。 性质：若$X \\sim F(n_1,n_2)​$，则$\\frac{1}{X} \\sim F(n_2,n_1)​$。 $F$ 分布的上$\\alpha$分位点：对于给定的$0\u003c\\alpha\u003c1$，称满足条件$P{F(n_1,n_2)\u003eF_\\alpha(n_1,n_2)}=\\alpha$的数$F_\\alpha(n_1,n_2)$为$F$分布的上$\\alpha$分位点。 ","date":"2019-06-23","objectID":"/probability-theory-note/:6:2","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#62--抽样分布"},{"categories":["default"],"content":" 第七章 参数估计数理统计问题：如何选取样本来对总体的种种统计特征作出判断。 参数估计问题：知道随机变量（总体）的分布类型，但它的一个或多个参数未知，根据样本来估计总体的参数，这类问题称为参数估计(paramentric estimation) 参数估计的类型——点估计、区间估计 ","date":"2019-06-23","objectID":"/probability-theory-note/:7:0","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#第七章--参数估计"},{"categories":["default"],"content":" 7.1 点估计方法设总体$X$的分布函数的形式已知，但含有一个或多个未知参数：$\\theta_1,\\theta_2,…,\\theta_k$ 设$X_1,X_2,…,X_n​$为总体的一个样本，构造$k​$个统计量： $$ \\left. \\begin{aligned} \\theta_1(X_1,X_2,...,X_n)\\\\ \\theta_2(X_1,X_2,...,X_n)\\\\ ..............\\\\ \\theta_k(X_1,X_2,...,X_n)\\\\ \\end{aligned} \\right\\}随机变量 $$ 当测得样本值$(x_1,x_2,…,x_n)$时，代入上述统计量，即可得到$k$个数： $$ \\left. \\begin{aligned} \\hat{\\theta_1}(x_1,x_2,...,x_n)\\\\ \\hat{\\theta_2}(x_1,x_2,...,x_n)\\\\ ..............\\\\ \\hat{\\theta_k}(x_1,x_2,...,x_n)\\\\ \\end{aligned} \\right\\}数值 $$ 称数$\\hat{\\theta_1}…\\hat{\\theta_k}$为未知参数${\\theta_1}…{\\theta_k}$的估计值 对应统计量为未知参数${\\theta_1}…{\\theta_k}$的估计量 ","date":"2019-06-23","objectID":"/probability-theory-note/:7:1","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#71---点估计方法"},{"categories":["default"],"content":" 7.2 参数的矩法估计用样本的矩作为总体距的估计量，集体做法如下： $$ \\left\\{ \\begin{aligned} \\mu_1=\\mu_1(\\theta_1,...,\\theta_k)\\\\ \\mu_2=\\mu_2(\\theta_1,...,\\theta_k)\\\\ ................\\\\ \\mu_k=\\mu_k(\\theta_1,...,\\theta_k) \\end{aligned} \\right. $$ 这里总体$X$的分布函数中含有$K$个参数。从上式解出这$K$个参数可得 $$ \\left\\{ \\begin{aligned} \\theta_1=\\theta_1(\\mu_1,...,\\mu_k)\\\\ \\theta_2=\\theta_2(\\mu_1,...,\\mu_k)\\\\ ................\\\\ \\theta_k=\\theta_k(\\mu_1,...,\\mu_k) \\end{aligned} \\right. $$ 用$A_i$代替上式中的$\\mu_i$： $$ \\left. \\begin{aligned} \\hat{\\theta}_1=\\theta_1(A_1,...,A_k)\\\\ \\hat{\\theta}_2=\\theta_2(A_1,...,A_k)\\\\ ................\\\\ \\hat{\\theta}_k=\\theta_k(A_1,...,A_k) \\end{aligned} \\right \\}未知参数\\theta_1...\\theta_k的矩估计量 $$ 代入一组样本值得$k$个数，可得矩估计量的观察值矩估计值 例题：设某总体$X$得数学期望为$E(X)=\\mu$，方差$D(X)=\\sigma^2$，$X_1,X_2,…,X_n$为样本，试求$\\mu$和$\\sigma^2$的矩估计量。 解：总体的$K$阶原点矩为 $\\mu_1=\\mu$ $\\mu_2=E(X^2)=D(X)+E(X)^2=\\sigma^2+\\mu^2$ 可得：$\\mu=\\mu_1$ $\\sigma^2=\\mu_2-\\mu_1^2$ 样本的$K​$阶原点矩为 $A_1=\\bar{X}​$ $A_2=\\frac{1}{n}\\sum^n_{i=1}X_i^2​$ 由矩法估计，领$A_i$代替$\\mu_i$，可得$\\mu$和$\\sigma^2$的矩估计量为：$\\hat{u}=\\bar{X}$ ， $\\hat{\\sigma}^2=\\frac{1}{n}\\sum^n_{i=1}X_i^2-\\bar{X}^2=\\frac{1}{n}\\sum^n_{i=1}(X_i-\\bar{X})^2​$ ","date":"2019-06-23","objectID":"/probability-theory-note/:7:2","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#72--参数的矩法估计"},{"categories":["default"],"content":" 7.3 极大似然估计","date":"2019-06-23","objectID":"/probability-theory-note/:7:3","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#73--极大似然估计"},{"categories":["default"],"content":" 7.4 区间估计","date":"2019-06-23","objectID":"/probability-theory-note/:7:4","series":null,"tags":["math"],"title":"概率论笔记","uri":"/probability-theory-note/#74--区间估计"},{"categories":["algorithm"],"content":"大一还是大二学线性代数的时候，感觉这玩意怎么这么无聊，这破矩阵能干啥？老师讲课跟催眠一样。后来学习OpenGL的时候才感受到矩阵的魅力，原来3D世界的平移、旋转、缩放都可以用一个小小的四阶矩阵的运算来完成，AMAZING 啊！！！(比老师上课有意思多了) 矩阵快速幂也是打ACM期间学到的，思想上和整数的快速幂一样，操作替换成了矩阵运算而已。 没错，课堂上的时间都用来睡觉、刷手机了 ","date":"2019-03-25","objectID":"/matrix-fast-power/:0:0","series":null,"tags":["algorithm","math"],"title":"矩阵快速幂","uri":"/matrix-fast-power/#"},{"categories":["algorithm"],"content":" 解决哪些问题求解一些递推公式的第n项的时候，通过递推公式构造转移矩阵，并用矩阵快速幂可以快速得到第n项的值。特别对于n很大的时候不能循环迭代，可用矩阵快速幂解决。 比如斐波那契数列： $F_0=0,F_1=1,F_n=F_n-1+F_n-2,(n \\ge2,n \\in N^*)$ 0 1 1 2 3 5 8… 如果要求第n项，n比较小的话，可以直接循环迭代出来。 如果n比较大，第一亿个是多少，用循环就太慢了，矩阵快速幂更快更适合。 根据矩阵乘法性质，构造转移矩阵 $$ \\begin{bmatrix} 1\u00261\\\\ 1\u00260\\end{bmatrix} \\times\\begin{bmatrix} F_{n-1}\\\\ F_{n-2} \\end{bmatrix} = \\begin{bmatrix} F_{n}\\\\ F_{n-1} \\end{bmatrix} $$ 那么 $$ \\begin{bmatrix} 1\u00261\\\\ 1\u00260\\end{bmatrix}^{n-1} \\times\\begin{bmatrix} F_{1}\\\\ F_{0} \\end{bmatrix} = \\begin{bmatrix} F_{n}\\\\ F_{n-1} \\end{bmatrix} $$ 这样问题就变成了求转移矩阵的幂。这个转移矩阵一定构造成方阵。 ","date":"2019-03-25","objectID":"/matrix-fast-power/:1:0","series":null,"tags":["algorithm","math"],"title":"矩阵快速幂","uri":"/matrix-fast-power/#解决哪些问题"},{"categories":["algorithm"],"content":" 矩阵快速幂 cpp #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #define MATRIX_SIZE 2 const int mod = 1e9+7; struct Matrix //构造一个方阵 { int data[MATRIX_SIZE][MATRIX_SIZE]; Matrix(){ memset(data, 0, sizeof(data)); for(int i=0; i\u003cMATRIX_SIZE; i++){ data[i][i]=1; // 初始化为单位矩阵 } } Matrix operator + (Matrix o)const{ //(a+b)%mod Matrix re; for(int i=0; i\u003cMATRIX_SIZE; i++){ for(int j=0; j\u003cMATRIX_SIZE; j++){ re.data[i][j] = (this-\u003edata[i][j] + o.data[i][j]) % mod; } } return re; } Matrix operator * (Matrix o)const{ //(a*b)%mod Matrix re; for(int i=0; i\u003cMATRIX_SIZE; i++){ for(int j=0; j\u003cMATRIX_SIZE; j++){ re.data[i][j] = 0; for(int k=0; k\u003cMATRIX_SIZE; k++) re.data[i][j] = (re.data[i][j] + ((this-\u003edata[i][k] * o.data[k][j]) % mod)) % mod; } } return re; } Matrix operator ^ (int n)const{ // (a^n)%mod Matrix re,base; base = *this; while(n){ if(n\u00261) re = re * base; n\u003e\u003e=1; base = base * base; } return re; } Matrix Psum(int n)const{ //(a+a^2+a^3.....+a^n)%mod Matrix a,ans,pre; int m; a = *this; if(n==1) return a; m = n/2; pre = a.Psum(m); // a^[1,n/2] 相加 ans = pre + (pre * (a^m)); // ans = [1,n/2] + a^(n/2)*[1,n/2] if(n\u00261) ans = ans + (a^n); //n为奇数时候a^n会漏掉，补上 return ans; } void out(){ for(int i=0; i\u003cMATRIX_SIZE; i++){ for(int j=0; j\u003cMATRIX_SIZE; j++){ printf(\"%d \",data[i][j]); }printf(\"\\n\"); } } }; int main(){ Matrix ma,swa; ma.data[0][0]=1; ma.data[0][1]=1; ma.data[1][0]=1; ma.data[1][1]=0; int n; ma.out(); while(scanf(\"%d\" , \u0026n) , n\u003e=1){ swa = ma^(n-1); //swa.out(); printf(\"is %d\\n\", swa.data[0][0]*1 + swa.data[0][1]*0 ); } return 0; } ","date":"2019-03-25","objectID":"/matrix-fast-power/:2:0","series":null,"tags":["algorithm","math"],"title":"矩阵快速幂","uri":"/matrix-fast-power/#矩阵快速幂"},{"categories":["algorithm"],"content":" 构造矩阵例题hdu6470 Farmer John有n头奶牛. 某天奶牛想要数一数有多少头奶牛,以一种特殊的方式: 第一头奶牛为1号,第二头奶牛为2号,第三头奶牛之后,假如当前奶牛是第n头,那么他的编号就是2倍的第n-2头奶牛的编号加上第n-1头奶牛的编号再加上自己当前的n的三次方为自己的编号. 现在Farmer John想知道,第n头奶牛的编号是多少,估计答案会很大,你只要输出答案对于123456789取模. 根据题意可以得到递推公式： $$ F_n=\\begin{cases} 1\u0026 n=1\\\\ 2\u0026 n=2\\\\ 2\\times F_{n-2} + F_{n-1}+n^3\u0026 n\\ge3 \\end{cases} $$ 由于$n^3$的存在，这个递推公式并不是线性的，所以要想办法把$n^3$展开： $$ n^3=(n-1+1)^3=C^0_3(n-1)^3+C^1_3(n-1)^2+C^2_3(n-1)^1+C^3_3(n-1)^0 \\\\=1\\times(n-1)^3+3\\times (n-1)^2+3\\times(n-1)^1+1\\times(n-1)^0 $$ 那么转移矩阵$M$为： $$ \\begin{bmatrix} 0\u00261\u00260\u00260\u00260\u00260\\\\ 2\u00261\u0026C_3^0\u0026C_3^1\u0026C_3^2\u0026C_3^3\\\\ 0\u00260\u0026C_3^0\u0026C_3^1\u0026C_3^2\u0026C_3^3\\\\ 0\u00260\u00260\u0026C_2^0\u0026C_2^1\u0026C_2^2\\\\ 0\u00260\u00260\u00260\u0026C_1^0 \u0026C_1^1\\\\ 0\u00260\u00260\u00260\u00260\u00261 \\end{bmatrix}\\times \\begin{bmatrix} F_{n-2}\\\\F_{n-1}\\\\(n-1)^3\\\\(n-1)^2\\\\(n-1)^1\\\\(n-1)^0 \\end{bmatrix} = \\begin{bmatrix} F_{n-1}\\\\F_{n}\\\\(n)^3\\\\(n)^2\\\\(n)^1\\\\(n)^0 \\end{bmatrix} $$ 取$n=3$： $$ \\begin{bmatrix} F_{n-2}\\\\F_{n-1}\\\\(n-1)^3\\\\(n-1)^2\\\\(n-1)^1\\\\(n-1)^0 \\end{bmatrix}=\\begin{bmatrix} F_{1}\\\\F_{2 }\\\\2^3\\\\ 2^2\\\\ 2^1\\\\ 2^0 \\end{bmatrix} $$ 所以： $$ F_n = M^{n-2 } \\times \\begin{bmatrix} F_{1}\\\\F_{2 }\\\\2^3\\\\ 2^2\\\\ 2^1\\\\ 2^0 \\end{bmatrix},n \\ge 2 $$ AC代码： cpp #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003ciostream\u003e #define MATRIX_SIZE 6 using namespace std; const int mod = 123456789; struct Matrix //构造一个方阵 { long long data[MATRIX_SIZE][MATRIX_SIZE]; Matrix(){ memset(data, 0, sizeof(data)); for(int i=0; i\u003cMATRIX_SIZE; i++){ data[i][i]=1; // 初始化为单位矩阵 } } Matrix operator * (Matrix o)const{ //(a*b)%mod Matrix re; for(int i=0; i\u003cMATRIX_SIZE; i++){ for(int j=0; j\u003cMATRIX_SIZE; j++){ re.data[i][j] = 0; for(int k=0; k\u003cMATRIX_SIZE; k++) re.data[i][j] = (re.data[i][j] + ((this-\u003edata[i][k] * o.data[k][j]) % mod)) % mod; } } return re; } Matrix operator ^ (long long n)const{ // (a^n)%mod Matrix re,base; base = *this; while(n){ if(n\u00261) re = re * base; n\u003e\u003e=1; base = base * base; } return re; } }; Matrix ma,swa; int main(){ int mm[6][6]={ {0,1,0,0,0,0}, {2,1,1,3,3,1}, {0,0,1,3,3,1}, {0,0,0,1,2,1}, {0,0,0,0,1,1}, {0,0,0,0,0,1} }; for(int i=0;i\u003c6;i++) for(int j=0;j\u003c6;j++) ma.data[i][j]=mm[i][j]; long long t,a; cin\u003e\u003et; while(t--){ cin\u003e\u003ea; swa = ma^(a-2); long long ac; ac= swa.data[1][0]*1; ac+=swa.data[1][1]*2; ac+=swa.data[1][2]*8; ac+=swa.data[1][3]*4; ac+=swa.data[1][4]*2; ac+=swa.data[1][5]*1; cout\u003c\u003cac%mod\u003c\u003cendl; } return 0; } ","date":"2019-03-25","objectID":"/matrix-fast-power/:3:0","series":null,"tags":["algorithm","math"],"title":"矩阵快速幂","uri":"/matrix-fast-power/#构造矩阵例题"},{"categories":["algorithm"],"content":" 附赠！这个方程怎么用矩阵计算，可以试着练练手。 $$ f(x)= \\begin{cases} 1\u0026 x=0 \\\\ 1\u0026 x=1 \\\\ 9\\times f(x-1) + 9\\times f(x-2) + 6\u0026 x\u003e1 \\end{cases} $$ ","date":"2019-03-25","objectID":"/matrix-fast-power/:4:0","series":null,"tags":["algorithm","math"],"title":"矩阵快速幂","uri":"/matrix-fast-power/#附赠"},{"categories":["algorithm"],"content":" 最大流","date":"2019-03-22","objectID":"/network-flow/:1:0","series":null,"tags":["graph","algorithm"],"title":"网络流","uri":"/network-flow/#最大流"},{"categories":["algorithm"],"content":" EdmondsKarpbfs找路，途中记录前驱节点 让后从汇点遍历到起点，找到最小flow 再次遍历，更新沿途边 累加答案，继续bfs cpp #define mem(x,y) memset(x,y,sizeof(x)) #define SIZE 1005 const int INF=0x3f3f3f3f; int G[SIZE][SIZE],pre[SIZE]; bool vst[SIZE]; bool bfs(int s,int t){ queue\u003cint\u003e que; mem(vst,0); mem(pre,-1); pre[s]=s; vst[s]=true; que.push(s); while (!que.empty()) { int u=que.front();que.pop(); for(int i=s;i\u003c=t;++i){//遍历所有点 if(G[u][i]\u0026\u0026!vst[i]){ pre[i]=u; vst[i]=true; if(i==t)return true; que.push(i); } } } return false; } int EK(int s,int t){ int ans=0; while (bfs(s,t)) { int minflow=INF; for(int i=t;i!=s;i=pre[i]){ minflow=min(minflow,G[pre[i]][i]); } for(int i=t;i!=s;i=pre[i]){ G[pre[i]][i]-=minflow; G[i][pre[i]]+=minflow; // 一定记得反向边 } ans+=minflow; } return ans; } ","date":"2019-03-22","objectID":"/network-flow/:1:1","series":null,"tags":["graph","algorithm"],"title":"网络流","uri":"/network-flow/#edmondskarp"},{"categories":["algorithm"],"content":" dinic多路增广+当前弧优化 建图时候建反向边（前向星边id从0开始，这样edge[i^1]就是反边） 首先bfs分层，维护每个点到汇点的距离（每个边距离都看做1） 然后对分过层的图dfs，每找到一条通路，沿途边边权减去流量，反边加上流量，反复找直到没有 再次bfs直到没有 for(int \u0026i=curedge[u];i!=-1;i=edge[i].nxt) 这句当前弧优化可能看不懂，代码中有详细注释 head[] edge[] 是链式前向星存图 curedge[] 当前弧优化使用 cpp #include \u003cqueue\u003e #include \u003cstring.h\u003e #define mem(x,y) memset(x,y,sizeof(x)) #define SIZE 1000 struct node{ int v,nxt,w;//指向那个点 下条边id 权值 }edge[SIZE*2]; int head[SIZE],curedge[SIZE],dis[SIZE],ecnt,s,t; inline void init(){ ecnt=0;//从偶数开始都行 mem(head,-1); } inline void addedge(int u,int v,int w){ edge[ecnt].v=v; edge[ecnt].w=w; edge[ecnt].nxt=head[u]; head[u]=ecnt; ecnt++; swap(u,v);//添加反边 edge[ecnt].v=v; edge[ecnt].w=0; edge[ecnt].nxt=head[u]; head[u]=ecnt; ecnt++; } bool bfs(){ mem(dis,-1);//不能少 dis[t]=0;//s是起点，t是终点，分层 queue\u003cint\u003e que; que.push(t); while(!que.empty()){ int u=que.front();que.pop(); for(int i=head[u];i!=-1;i=edge[i].nxt){ if(dis[edge[i].v]==-1\u0026\u0026edge[i^1].w\u003e0){ dis[edge[i].v]=dis[u]+1; que.push(edge[i].v); } } } return dis[s]!=-1;//没有办法从s到t返回false } int dfs(int u,int v,int flow){ if(u==t)return flow; int delta=flow;//表示前面输送过来的流量有多少被挡住了，初始化为所有 for(int \u0026i=curedge[u];i!=-1;i=edge[i].nxt){ //当前弧优化，\u0026 引用是重点 if(dis[u]==dis[edge[i].v]+1\u0026\u0026edge[i].w\u003e0){ int d=dfs(edge[i].v,v,min(delta,edge[i].w)); edge[i].w-=d;edge[i^1].w+=d; delta-=d;//可以放行d的流量，被挡住的流量变少了 if(delta==0)break;//这句对当前弧优化很重要，这时进来的流量全都放行了，那么当前这条路可能刚好被填满，也可能还有宽裕（如果delta！=0，说明这条路肯定占满了） //因为可能有宽裕，所以这条路以后还要走，这时候break;curedge[u]=i，前面的路因为都满了，所以直接舍去，下次到这个点直接从第i个边开始，这就是当前弧优化。 } } return flow-delta;//送进来的 - 挡住的 = 有效流量 } int dinic(){ int ans=0; while (bfs()) {//分层（计算距离） for(int i=s;i\u003c=t;i++)//每bfs一次，层次就刷新，所以也要重置当前弧 curedge[i]=head[i]; ans+=dfs(s,t,INF);//从点1到点n最大流，输入流量无穷大 } return ans; } ","date":"2019-03-22","objectID":"/network-flow/:1:2","series":null,"tags":["graph","algorithm"],"title":"网络流","uri":"/network-flow/#dinic"},{"categories":["algorithm"],"content":" 费用流","date":"2019-03-22","objectID":"/network-flow/:2:0","series":null,"tags":["graph","algorithm"],"title":"网络流","uri":"/network-flow/#费用流"},{"categories":["algorithm"],"content":" spfa求最小费用最大流 建边时候反边cost是原来的负数 用spfa求出一条s到t的最短路，途中 pre[]数组记录当前点是从哪个边过来的（放了一个边id） 然后通过pre[]从t一直遍历到s，找到途中最小流量Min 再遍历一次，更新途中边的容量，更新答案 再次spfa直到没有通路 cpp #include \u003cqueue\u003e #include \u003cstring.h\u003e #define mem(x,y) memset(x,y,sizeof(x)) #define SIZE 1000 struct node{ int v,nxt,cap,cost;//指向那个点 下条边id 流通容量 这条路花费(看情况有时候是单价，记得改dfs里面的跟新) }edge[40010]; int head[SIZE],dis[SIZE],pre[SIZE],ecnt,s,t; bool vst[SIZE]; inline void init(){ ecnt=0;//从偶数开始都行 mem(head,-1); } inline void addedge(int u,int v,int cap,int cost){ edge[ecnt].v=v; edge[ecnt].cap=cap; edge[ecnt].cost=cost; edge[ecnt].nxt=head[u]; head[u]=ecnt; ecnt++; swap(u,v);//添加反边 edge[ecnt].v=v; edge[ecnt].cap=0; edge[ecnt].cost=-cost;//注意反边花费为负 edge[ecnt].nxt=head[u]; head[u]=ecnt; ecnt++; } bool spfa(){ mem(dis,INF);//不能少 mem(vst,0); mem(pre,-1); dis[s]=0;//s是起点，t是终点，分层 vst[s]=true; queue\u003cint\u003e que; que.push(s); while(!que.empty()){ int u=que.front();que.pop(); vst[u]=false; for(int i=head[u];i!=-1;i=edge[i].nxt){ if(dis[u]+edge[i].cost\u003cdis[edge[i].v]\u0026\u0026edge[i].cap\u003e0){ //通过点u更短 dis[edge[i].v]=dis[u]+edge[i].cost; pre[edge[i].v]=i; if(!vst[edge[i].v]){ vst[edge[i].v]=true; que.push(edge[i].v); } } } } return pre[t]!=-1;//没有办法从s到t返回false } int mfmc(int \u0026 cost){//cost 按引用更新 int flow=0; cost=0; while (spfa()) { int Min=INF; for(int i=pre[t];i!=-1;i=pre[edge[i^1].v]){//i是边的id，得到另一个顶点edge[i^1].v if(Min\u003eedge[i].cap){ Min=edge[i].cap; } } for(int i=pre[t];i!=-1;i=pre[edge[i^1].v]){ edge[i].cap-=Min; edge[i^1].cap+=Min; } cost+=dis[t]*Min; flow+=Min; } return flow; } ","date":"2019-03-22","objectID":"/network-flow/:2:1","series":null,"tags":["graph","algorithm"],"title":"网络流","uri":"/network-flow/#spfa"},{"categories":["algorithm"],"content":"链式前向星，存图方法 cpp #include \u003cstring.h\u003e /*for memset*/ //最大顶点数与最大边数 const int V=100; const int E=100; //边结构体定义 struct Edge{ int to; // 这条边的另一个顶点 int next; // 指向下一条边的数组下标，-1为不存在； int len; // 权值 }; //head[i] 表示顶点i的边的数组下标，-1表示无边； int head[V];//第一条边 Edge edge[E]; //链式前向星初始化，之初始化顶点数组 void init(){ memset(head, -1, sizeof(head)); } //增加边的方式 //加入a—\u003eb,权值l; int id; inline void AddEdge(int a,int b,int l=0){ edge[id].to=b; edge[id].next=head[a]; //和下面一行将新边作为a的第一条边; head[a]=id; edge[id].len=l; id++;//只给edge数组开新空间用 } //遍历从a出发的边 得到下一个点和权值 for(int i=head[a];i!=-1;i=edge[i].next){ //edge[i] 即为当前边 } ","date":"2019-03-22","objectID":"/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/:0:0","series":null,"tags":["graph","algorithm"],"title":"链式前向星","uri":"/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/#"},{"categories":["program"],"content":"此文为个人笔记，大学时候的总结难免有错，不代表本人目前水平[手动doge] (by 2021) 本来这总结已经被我从网络上删除了，看在可能是本文迄今为止唯一读者老田园的份上重新发布，方便老人查阅。 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:0:0","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#"},{"categories":["program"],"content":" MySQL操作手册 MySQL命令不区分大小写 空格符复制有时会出现格式错误，删掉空格再自己打一个 `(反引号)是转义字符，当你自定义名字和关键字冲突可以 `name` 括起来 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:0:0","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#mysql操作手册"},{"categories":["program"],"content":" 1 MySQL安装","date":"2019-03-19","objectID":"/mysql-operation-manual/:1:0","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#1-mysql安装"},{"categories":["program"],"content":" 1.1 linux安装 Ubuntu下用apt，Centos用yum shell sudo apt‐get install mysql‐server sudo apt‐get install mysql‐client sudo apt‐get install libmysqlclient‐dev 配置文件目录 /etc/mysql/mysql.conf.d/mysqld.cnf ","date":"2019-03-19","objectID":"/mysql-operation-manual/:1:1","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#11-linux安装"},{"categories":["program"],"content":" 1.2 密码修改 shell kirito@host:~$ mysqladmin ‐u用户名 ‐p旧密码 password 新密码 kirito@host:~$ mysqladmin ‐uroot ‐p111111 password 123456 如果修改不了，sudo mysql -uroot，进入数据库 mysql mysql\u003e update mysql.user set authentication_string=PASSWORD('newPwd'), plugin='mysql_native_password' where user='root'; mysql\u003e flush privileges; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:1:2","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#12-密码修改"},{"categories":["program"],"content":" 1.3 MySQL登陆 shell kirito@host:~$ mysql ‐h数据库服务器安装的主机 ‐P数据库端口 ‐u账户 ‐p密码 kirito@host:~$ mysql ‐h127.0.0.1 ‐P3306 ‐uroot ‐p123456 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:1:3","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#13-mysql登陆"},{"categories":["program"],"content":" 2 数据库基础","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:0","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#2-数据库基础"},{"categories":["program"],"content":" 2.1 库操作 mysql # 查看数据库服务器存在哪些数据库 SHOW DATABASES; # 使用指定的数据库 USE database_name; # 查看指定的数据库中有哪些数据表 SHOW TABLES; # 创建指定名称的数据库 CREATE DATABASE database_name; # 删除数据库 DROP DATABASE database_name; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:1","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#21-库操作"},{"categories":["program"],"content":" 2.2 表操作 创建一个表 mysql CREATE TABLE 表名( 列名1 列的类型 [属性约束], 列名2 列的类型 [属性约束], .... 列名N 列的类型 [属性约束] ); # 如果名字和命令名冲突，此时使用反引号(`)括起来 查看表结构 mysql DESC name; 查看表的详细定义 mysql SHOW CREATE TABLE name; 删除表 mysql DROP TABLE name; 往表中插入一行数据 mysql # 为所有表单项赋值，插入 CREATE TABLE test(id INT,_date DATE); INSERT INTO test VALUES(1,'2008‐12‐2'); # 选择赋值 CREATE TABLE test4(id INT,_datetime DATETIME); INSERT INTO test4(id, _datetime) VALUES(1, '1990‐02‐10'); /* DATE可以通过CURDATE()来赋值当前的日期， TIME可以通过CURTIME()来赋值当前的时间， DATETIME与TIMESTAMP都可以通过函数NOW()来赋值当前的时间日期。 */ 修改已有表字符集 mysql ALTER TABLE 表名 CONVERT TO CHARACTER SET utf8; # or gbk # 若想仅修改某一列的字符集 使用列操作添加约束属性 CHARACTER SET name 修改表名 mysql ALTER TABLE 表名 RENAME TO 新表名; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:2","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#22-表操作"},{"categories":["program"],"content":" 2.3 列操作列（字段） 给表添加列 mysql ALTER TABLE 表名 ADD 列名 列的类型 [属性约束]; ALTER TABLE 表名 ADD 列名 列的类型 [属性约束] FIRST; /*放在第一位*/ ALTER TABLE 表名 ADD 列名 列的类型 AFTER 列名; /*放在某字段后面*/ 修改已有列数据类型，约束 mysql ALTER TABLE 表名 MODIFY 列名 列的类型 [属性约束]; 删除列 mysql ALTER TABLE 表名 DROP 列名; 修改列名，和类型 mysql ALTER TABLE 表名 CHANGE 列名 新_列名 列的类型 [属性约束]; # 列名不一定要新的， ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:3","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#23-列操作"},{"categories":["program"],"content":" 2.4 列.属性约束 MySOL关键字 含义 NULL 数据列可包含NULL值 ，默认不填即为NULL。 NOT NULL 数据列不允许包含NULL值 ，在操作数据库时如果输入该字段的数据为NULL ，就会报错。 DEFAULT 默认值，DATE，TIME不能使用函数默认值。DATETIME与TIMESTAMP可以使用NOW()函数默认值。 PRIMARY KEY 主键 ，您可以使用多列来定义主键，列间以逗号分隔。主键不管有没NOT NULL修饰，都不能为NULL，主键值不能重复。主键可以由多个字段组成。例如：PRIMARY KEY (id, name) AUTO_INCREMENT 定义列为自增的属性，数值会自动加1, 默认初始值为0。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集 2.4.1 列默认值 DEFAULT在未指定默认值的情况下，系统提供default null这样的约束。只有列中提供了default，在插入时，才可以省略。 mysql # 设置/删除 DEFAULT ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值; ALTER TABLE 表名 ALTER 列名 DROP DEFAULT; 2.4.2 非空约束 NOT NULLNULL存在的意义在于标志。 NULL类型特征:所有的类型的值都可以是null，包括int、float等数据类型,空字符串是不等于null，0也不等于null。 非空约束用于确保当前列的值不为空值，非空约束只能出现在表对象的列上。 mysql # 已有，设置 ALTER TABLE 表名 MODIFY 列名 INT NOT NULL DEFAULT 0; # 创建表 mysql\u003e CREATE TABLE stu2 ( id INT DEFAULT NULL, sex CHAR(2) NOT NULL ) # 效果 不能默认初始化 mysql\u003e INSERT INTO stu2 VALUES(); ERROR 1364 (HY000): Field 'sex' doesn't have a default value 2.4.3 唯一约束 UNIQUE KEY唯一约束是指定table的列或列组合不能重复，保证数据的唯一性。虽然唯一约束不允许出现重复的值，但是可以有多个null，同一个表可以有多个唯一约束，多个列组合的约束。 在创建唯一约束的时候，如果不给唯一约束名称，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引. mysql mysql\u003e CREATE TABLE stu3(id INT UNIQUE, sex CHAR(2)); mysql\u003e CREATE TABLE stu3(id INT, sex CHAR(2), UNIQUE(id)); # 第二种写法 # 效果 插入重复值报错 mysql\u003e INSERT INTO stu3 VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu3 VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'id' 2.4.4 主键约束 PRIMARY KEY每个表最多只允许一个主键，建立主键约束可以在列级别创建，也可以在表级别上创建。 MySQL的主键名总是PRIMARY KEY， 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的唯一索引。 mysql #已有表，修改，删除 ALTER TABLE table_name ADD primary key(column_name); /*必须是不存在重复值的列*/ ALTER TABLE table_name DROP primary key; # 创建时设置 mysql\u003e CREATE TABLE stu4(id INT PRIMARY KEY, sex CHAR(2)); mysql\u003e CREATE TABLE stu4(id INT, sex CHAR(2), PRIMARY KEY(id)); # 第二种写法 # 效果 只能有一个列为主键，且没有重复 mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY' 2.4.5 自增约束 AUTO_INCREMENTMySQL的中AUTO_INCREMENT类型的属性用于为一个表中记录自动生成ID功能。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 mysql ALTER TABLE 表名 CHANGE id id INT AUTO_INCREMENT; #必须先是索引 ALTER TABLE 表名 AUTO_INCREMENT=number; # 设置初始值 # 创建时 mysql\u003e CREATE TABLE stu5(id INT AUTO_INCREMENT,sex CHAR(2)); # 错误，必须是索引 ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key mysql\u003e CREATE TABLE stu5(id INT PRIMARY KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式 mysql\u003e CREATE TABLE stu6(id INT UNIQUE KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式 # 效果 不提供初始值，自动递增分配， 提供重复的则报错 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:4","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#24-列属性约束"},{"categories":["program"],"content":" 2.4 列.属性约束 MySOL关键字 含义 NULL 数据列可包含NULL值 ，默认不填即为NULL。 NOT NULL 数据列不允许包含NULL值 ，在操作数据库时如果输入该字段的数据为NULL ，就会报错。 DEFAULT 默认值，DATE，TIME不能使用函数默认值。DATETIME与TIMESTAMP可以使用NOW()函数默认值。 PRIMARY KEY 主键 ，您可以使用多列来定义主键，列间以逗号分隔。主键不管有没NOT NULL修饰，都不能为NULL，主键值不能重复。主键可以由多个字段组成。例如：PRIMARY KEY (id, name) AUTO_INCREMENT 定义列为自增的属性，数值会自动加1, 默认初始值为0。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集 2.4.1 列默认值 DEFAULT在未指定默认值的情况下，系统提供default null这样的约束。只有列中提供了default，在插入时，才可以省略。 mysql # 设置/删除 DEFAULT ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值; ALTER TABLE 表名 ALTER 列名 DROP DEFAULT; 2.4.2 非空约束 NOT NULLNULL存在的意义在于标志。 NULL类型特征:所有的类型的值都可以是null，包括int、float等数据类型,空字符串是不等于null，0也不等于null。 非空约束用于确保当前列的值不为空值，非空约束只能出现在表对象的列上。 mysql # 已有，设置 ALTER TABLE 表名 MODIFY 列名 INT NOT NULL DEFAULT 0; # 创建表 mysql\u003e CREATE TABLE stu2 ( id INT DEFAULT NULL, sex CHAR(2) NOT NULL ) # 效果 不能默认初始化 mysql\u003e INSERT INTO stu2 VALUES(); ERROR 1364 (HY000): Field 'sex' doesn't have a default value 2.4.3 唯一约束 UNIQUE KEY唯一约束是指定table的列或列组合不能重复，保证数据的唯一性。虽然唯一约束不允许出现重复的值，但是可以有多个null，同一个表可以有多个唯一约束，多个列组合的约束。 在创建唯一约束的时候，如果不给唯一约束名称，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引. mysql mysql\u003e CREATE TABLE stu3(id INT UNIQUE, sex CHAR(2)); mysql\u003e CREATE TABLE stu3(id INT, sex CHAR(2), UNIQUE(id)); # 第二种写法 # 效果 插入重复值报错 mysql\u003e INSERT INTO stu3 VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu3 VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'id' 2.4.4 主键约束 PRIMARY KEY每个表最多只允许一个主键，建立主键约束可以在列级别创建，也可以在表级别上创建。 MySQL的主键名总是PRIMARY KEY， 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的唯一索引。 mysql #已有表，修改，删除 ALTER TABLE table_name ADD primary key(column_name); /*必须是不存在重复值的列*/ ALTER TABLE table_name DROP primary key; # 创建时设置 mysql\u003e CREATE TABLE stu4(id INT PRIMARY KEY, sex CHAR(2)); mysql\u003e CREATE TABLE stu4(id INT, sex CHAR(2), PRIMARY KEY(id)); # 第二种写法 # 效果 只能有一个列为主键，且没有重复 mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY' 2.4.5 自增约束 AUTO_INCREMENTMySQL的中AUTO_INCREMENT类型的属性用于为一个表中记录自动生成ID功能。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 mysql ALTER TABLE 表名 CHANGE id id INT AUTO_INCREMENT; #必须先是索引 ALTER TABLE 表名 AUTO_INCREMENT=number; # 设置初始值 # 创建时 mysql\u003e CREATE TABLE stu5(id INT AUTO_INCREMENT,sex CHAR(2)); # 错误，必须是索引 ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key mysql\u003e CREATE TABLE stu5(id INT PRIMARY KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式 mysql\u003e CREATE TABLE stu6(id INT UNIQUE KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式 # 效果 不提供初始值，自动递增分配， 提供重复的则报错 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:4","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#241-列默认值-default"},{"categories":["program"],"content":" 2.4 列.属性约束 MySOL关键字 含义 NULL 数据列可包含NULL值 ，默认不填即为NULL。 NOT NULL 数据列不允许包含NULL值 ，在操作数据库时如果输入该字段的数据为NULL ，就会报错。 DEFAULT 默认值，DATE，TIME不能使用函数默认值。DATETIME与TIMESTAMP可以使用NOW()函数默认值。 PRIMARY KEY 主键 ，您可以使用多列来定义主键，列间以逗号分隔。主键不管有没NOT NULL修饰，都不能为NULL，主键值不能重复。主键可以由多个字段组成。例如：PRIMARY KEY (id, name) AUTO_INCREMENT 定义列为自增的属性，数值会自动加1, 默认初始值为0。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集 2.4.1 列默认值 DEFAULT在未指定默认值的情况下，系统提供default null这样的约束。只有列中提供了default，在插入时，才可以省略。 mysql # 设置/删除 DEFAULT ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值; ALTER TABLE 表名 ALTER 列名 DROP DEFAULT; 2.4.2 非空约束 NOT NULLNULL存在的意义在于标志。 NULL类型特征:所有的类型的值都可以是null，包括int、float等数据类型,空字符串是不等于null，0也不等于null。 非空约束用于确保当前列的值不为空值，非空约束只能出现在表对象的列上。 mysql # 已有，设置 ALTER TABLE 表名 MODIFY 列名 INT NOT NULL DEFAULT 0; # 创建表 mysql\u003e CREATE TABLE stu2 ( id INT DEFAULT NULL, sex CHAR(2) NOT NULL ) # 效果 不能默认初始化 mysql\u003e INSERT INTO stu2 VALUES(); ERROR 1364 (HY000): Field 'sex' doesn't have a default value 2.4.3 唯一约束 UNIQUE KEY唯一约束是指定table的列或列组合不能重复，保证数据的唯一性。虽然唯一约束不允许出现重复的值，但是可以有多个null，同一个表可以有多个唯一约束，多个列组合的约束。 在创建唯一约束的时候，如果不给唯一约束名称，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引. mysql mysql\u003e CREATE TABLE stu3(id INT UNIQUE, sex CHAR(2)); mysql\u003e CREATE TABLE stu3(id INT, sex CHAR(2), UNIQUE(id)); # 第二种写法 # 效果 插入重复值报错 mysql\u003e INSERT INTO stu3 VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu3 VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'id' 2.4.4 主键约束 PRIMARY KEY每个表最多只允许一个主键，建立主键约束可以在列级别创建，也可以在表级别上创建。 MySQL的主键名总是PRIMARY KEY， 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的唯一索引。 mysql #已有表，修改，删除 ALTER TABLE table_name ADD primary key(column_name); /*必须是不存在重复值的列*/ ALTER TABLE table_name DROP primary key; # 创建时设置 mysql\u003e CREATE TABLE stu4(id INT PRIMARY KEY, sex CHAR(2)); mysql\u003e CREATE TABLE stu4(id INT, sex CHAR(2), PRIMARY KEY(id)); # 第二种写法 # 效果 只能有一个列为主键，且没有重复 mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY' 2.4.5 自增约束 AUTO_INCREMENTMySQL的中AUTO_INCREMENT类型的属性用于为一个表中记录自动生成ID功能。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 mysql ALTER TABLE 表名 CHANGE id id INT AUTO_INCREMENT; #必须先是索引 ALTER TABLE 表名 AUTO_INCREMENT=number; # 设置初始值 # 创建时 mysql\u003e CREATE TABLE stu5(id INT AUTO_INCREMENT,sex CHAR(2)); # 错误，必须是索引 ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key mysql\u003e CREATE TABLE stu5(id INT PRIMARY KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式 mysql\u003e CREATE TABLE stu6(id INT UNIQUE KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式 # 效果 不提供初始值，自动递增分配， 提供重复的则报错 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:4","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#242--非空约束-not-null"},{"categories":["program"],"content":" 2.4 列.属性约束 MySOL关键字 含义 NULL 数据列可包含NULL值 ，默认不填即为NULL。 NOT NULL 数据列不允许包含NULL值 ，在操作数据库时如果输入该字段的数据为NULL ，就会报错。 DEFAULT 默认值，DATE，TIME不能使用函数默认值。DATETIME与TIMESTAMP可以使用NOW()函数默认值。 PRIMARY KEY 主键 ，您可以使用多列来定义主键，列间以逗号分隔。主键不管有没NOT NULL修饰，都不能为NULL，主键值不能重复。主键可以由多个字段组成。例如：PRIMARY KEY (id, name) AUTO_INCREMENT 定义列为自增的属性，数值会自动加1, 默认初始值为0。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集 2.4.1 列默认值 DEFAULT在未指定默认值的情况下，系统提供default null这样的约束。只有列中提供了default，在插入时，才可以省略。 mysql # 设置/删除 DEFAULT ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值; ALTER TABLE 表名 ALTER 列名 DROP DEFAULT; 2.4.2 非空约束 NOT NULLNULL存在的意义在于标志。 NULL类型特征:所有的类型的值都可以是null，包括int、float等数据类型,空字符串是不等于null，0也不等于null。 非空约束用于确保当前列的值不为空值，非空约束只能出现在表对象的列上。 mysql # 已有，设置 ALTER TABLE 表名 MODIFY 列名 INT NOT NULL DEFAULT 0; # 创建表 mysql\u003e CREATE TABLE stu2 ( id INT DEFAULT NULL, sex CHAR(2) NOT NULL ) # 效果 不能默认初始化 mysql\u003e INSERT INTO stu2 VALUES(); ERROR 1364 (HY000): Field 'sex' doesn't have a default value 2.4.3 唯一约束 UNIQUE KEY唯一约束是指定table的列或列组合不能重复，保证数据的唯一性。虽然唯一约束不允许出现重复的值，但是可以有多个null，同一个表可以有多个唯一约束，多个列组合的约束。 在创建唯一约束的时候，如果不给唯一约束名称，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引. mysql mysql\u003e CREATE TABLE stu3(id INT UNIQUE, sex CHAR(2)); mysql\u003e CREATE TABLE stu3(id INT, sex CHAR(2), UNIQUE(id)); # 第二种写法 # 效果 插入重复值报错 mysql\u003e INSERT INTO stu3 VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu3 VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'id' 2.4.4 主键约束 PRIMARY KEY每个表最多只允许一个主键，建立主键约束可以在列级别创建，也可以在表级别上创建。 MySQL的主键名总是PRIMARY KEY， 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的唯一索引。 mysql #已有表，修改，删除 ALTER TABLE table_name ADD primary key(column_name); /*必须是不存在重复值的列*/ ALTER TABLE table_name DROP primary key; # 创建时设置 mysql\u003e CREATE TABLE stu4(id INT PRIMARY KEY, sex CHAR(2)); mysql\u003e CREATE TABLE stu4(id INT, sex CHAR(2), PRIMARY KEY(id)); # 第二种写法 # 效果 只能有一个列为主键，且没有重复 mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY' 2.4.5 自增约束 AUTO_INCREMENTMySQL的中AUTO_INCREMENT类型的属性用于为一个表中记录自动生成ID功能。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 mysql ALTER TABLE 表名 CHANGE id id INT AUTO_INCREMENT; #必须先是索引 ALTER TABLE 表名 AUTO_INCREMENT=number; # 设置初始值 # 创建时 mysql\u003e CREATE TABLE stu5(id INT AUTO_INCREMENT,sex CHAR(2)); # 错误，必须是索引 ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key mysql\u003e CREATE TABLE stu5(id INT PRIMARY KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式 mysql\u003e CREATE TABLE stu6(id INT UNIQUE KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式 # 效果 不提供初始值，自动递增分配， 提供重复的则报错 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:4","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#243-唯一约束-unique-key"},{"categories":["program"],"content":" 2.4 列.属性约束 MySOL关键字 含义 NULL 数据列可包含NULL值 ，默认不填即为NULL。 NOT NULL 数据列不允许包含NULL值 ，在操作数据库时如果输入该字段的数据为NULL ，就会报错。 DEFAULT 默认值，DATE，TIME不能使用函数默认值。DATETIME与TIMESTAMP可以使用NOW()函数默认值。 PRIMARY KEY 主键 ，您可以使用多列来定义主键，列间以逗号分隔。主键不管有没NOT NULL修饰，都不能为NULL，主键值不能重复。主键可以由多个字段组成。例如：PRIMARY KEY (id, name) AUTO_INCREMENT 定义列为自增的属性，数值会自动加1, 默认初始值为0。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集 2.4.1 列默认值 DEFAULT在未指定默认值的情况下，系统提供default null这样的约束。只有列中提供了default，在插入时，才可以省略。 mysql # 设置/删除 DEFAULT ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值; ALTER TABLE 表名 ALTER 列名 DROP DEFAULT; 2.4.2 非空约束 NOT NULLNULL存在的意义在于标志。 NULL类型特征:所有的类型的值都可以是null，包括int、float等数据类型,空字符串是不等于null，0也不等于null。 非空约束用于确保当前列的值不为空值，非空约束只能出现在表对象的列上。 mysql # 已有，设置 ALTER TABLE 表名 MODIFY 列名 INT NOT NULL DEFAULT 0; # 创建表 mysql\u003e CREATE TABLE stu2 ( id INT DEFAULT NULL, sex CHAR(2) NOT NULL ) # 效果 不能默认初始化 mysql\u003e INSERT INTO stu2 VALUES(); ERROR 1364 (HY000): Field 'sex' doesn't have a default value 2.4.3 唯一约束 UNIQUE KEY唯一约束是指定table的列或列组合不能重复，保证数据的唯一性。虽然唯一约束不允许出现重复的值，但是可以有多个null，同一个表可以有多个唯一约束，多个列组合的约束。 在创建唯一约束的时候，如果不给唯一约束名称，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引. mysql mysql\u003e CREATE TABLE stu3(id INT UNIQUE, sex CHAR(2)); mysql\u003e CREATE TABLE stu3(id INT, sex CHAR(2), UNIQUE(id)); # 第二种写法 # 效果 插入重复值报错 mysql\u003e INSERT INTO stu3 VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu3 VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'id' 2.4.4 主键约束 PRIMARY KEY每个表最多只允许一个主键，建立主键约束可以在列级别创建，也可以在表级别上创建。 MySQL的主键名总是PRIMARY KEY， 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的唯一索引。 mysql #已有表，修改，删除 ALTER TABLE table_name ADD primary key(column_name); /*必须是不存在重复值的列*/ ALTER TABLE table_name DROP primary key; # 创建时设置 mysql\u003e CREATE TABLE stu4(id INT PRIMARY KEY, sex CHAR(2)); mysql\u003e CREATE TABLE stu4(id INT, sex CHAR(2), PRIMARY KEY(id)); # 第二种写法 # 效果 只能有一个列为主键，且没有重复 mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY' 2.4.5 自增约束 AUTO_INCREMENTMySQL的中AUTO_INCREMENT类型的属性用于为一个表中记录自动生成ID功能。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 mysql ALTER TABLE 表名 CHANGE id id INT AUTO_INCREMENT; #必须先是索引 ALTER TABLE 表名 AUTO_INCREMENT=number; # 设置初始值 # 创建时 mysql\u003e CREATE TABLE stu5(id INT AUTO_INCREMENT,sex CHAR(2)); # 错误，必须是索引 ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key mysql\u003e CREATE TABLE stu5(id INT PRIMARY KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式 mysql\u003e CREATE TABLE stu6(id INT UNIQUE KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式 # 效果 不提供初始值，自动递增分配， 提供重复的则报错 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:4","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#244--主键约束-primary-key"},{"categories":["program"],"content":" 2.4 列.属性约束 MySOL关键字 含义 NULL 数据列可包含NULL值 ，默认不填即为NULL。 NOT NULL 数据列不允许包含NULL值 ，在操作数据库时如果输入该字段的数据为NULL ，就会报错。 DEFAULT 默认值，DATE，TIME不能使用函数默认值。DATETIME与TIMESTAMP可以使用NOW()函数默认值。 PRIMARY KEY 主键 ，您可以使用多列来定义主键，列间以逗号分隔。主键不管有没NOT NULL修饰，都不能为NULL，主键值不能重复。主键可以由多个字段组成。例如：PRIMARY KEY (id, name) AUTO_INCREMENT 定义列为自增的属性，数值会自动加1, 默认初始值为0。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集 2.4.1 列默认值 DEFAULT在未指定默认值的情况下，系统提供default null这样的约束。只有列中提供了default，在插入时，才可以省略。 mysql # 设置/删除 DEFAULT ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值; ALTER TABLE 表名 ALTER 列名 DROP DEFAULT; 2.4.2 非空约束 NOT NULLNULL存在的意义在于标志。 NULL类型特征:所有的类型的值都可以是null，包括int、float等数据类型,空字符串是不等于null，0也不等于null。 非空约束用于确保当前列的值不为空值，非空约束只能出现在表对象的列上。 mysql # 已有，设置 ALTER TABLE 表名 MODIFY 列名 INT NOT NULL DEFAULT 0; # 创建表 mysql\u003e CREATE TABLE stu2 ( id INT DEFAULT NULL, sex CHAR(2) NOT NULL ) # 效果 不能默认初始化 mysql\u003e INSERT INTO stu2 VALUES(); ERROR 1364 (HY000): Field 'sex' doesn't have a default value 2.4.3 唯一约束 UNIQUE KEY唯一约束是指定table的列或列组合不能重复，保证数据的唯一性。虽然唯一约束不允许出现重复的值，但是可以有多个null，同一个表可以有多个唯一约束，多个列组合的约束。 在创建唯一约束的时候，如果不给唯一约束名称，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引. mysql mysql\u003e CREATE TABLE stu3(id INT UNIQUE, sex CHAR(2)); mysql\u003e CREATE TABLE stu3(id INT, sex CHAR(2), UNIQUE(id)); # 第二种写法 # 效果 插入重复值报错 mysql\u003e INSERT INTO stu3 VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu3 VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'id' 2.4.4 主键约束 PRIMARY KEY每个表最多只允许一个主键，建立主键约束可以在列级别创建，也可以在表级别上创建。 MySQL的主键名总是PRIMARY KEY， 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的唯一索引。 mysql #已有表，修改，删除 ALTER TABLE table_name ADD primary key(column_name); /*必须是不存在重复值的列*/ ALTER TABLE table_name DROP primary key; # 创建时设置 mysql\u003e CREATE TABLE stu4(id INT PRIMARY KEY, sex CHAR(2)); mysql\u003e CREATE TABLE stu4(id INT, sex CHAR(2), PRIMARY KEY(id)); # 第二种写法 # 效果 只能有一个列为主键，且没有重复 mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); Query OK, 1 row affected (0.00 sec) mysql\u003e INSERT INTO stu4(id,sex) VALUES(1,'f'); ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY' 2.4.5 自增约束 AUTO_INCREMENTMySQL的中AUTO_INCREMENT类型的属性用于为一个表中记录自动生成ID功能。一个表只能有一个自增字段，并且该字段必须是主键或者索引。 mysql ALTER TABLE 表名 CHANGE id id INT AUTO_INCREMENT; #必须先是索引 ALTER TABLE 表名 AUTO_INCREMENT=number; # 设置初始值 # 创建时 mysql\u003e CREATE TABLE stu5(id INT AUTO_INCREMENT,sex CHAR(2)); # 错误，必须是索引 ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key mysql\u003e CREATE TABLE stu5(id INT PRIMARY KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式 mysql\u003e CREATE TABLE stu6(id INT UNIQUE KEY AUTO_INCREMENT ,sex CHAR(2)); # 正确方式 # 效果 不提供初始值，自动递增分配， 提供重复的则报错 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:4","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#245-自增约束-auto_increment"},{"categories":["program"],"content":" 2.4 行操作 行增 mysql INSERT INTO 表名( 字段1, 字段2,... 字段N ) VALUES( value1, value2,... valueN ); # 字段（field）和值（value）都可以省略 行删 mysql DELETE FROM \u003c表名\u003e [WHERE \u003c删除条件\u003e] # 栗子 delete from class where _id=9; delete from class; # 不跟条件表示删除整个表内容（不是整个表，框架还在），等价于 truncate table \u003c表名\u003e 行改 mysql UPDATE \u003c表名\u003e SET \u003c列名=更新值\u003e [WHERE \u003c更新条件\u003e] # 栗子 update class SET score=100 WHERE name=\"郑同学\"; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:2:5","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#24-行操作"},{"categories":["program"],"content":" 3 行查询","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:0","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#3-行查询"},{"categories":["program"],"content":" 3.1 全列查询/投影查询 mysql SELECT column_name0,column_name1... FROM table_name0,table_name1... [WHERE clause] [LIMIT N] [OFFSET M ] # 查询表phonelist所有字段信息 SELECT * FROM phonelist; # 只查询名字（name）为小张的所有字段信息 SELECT * FROM phonelist WHERE name=\"小张\"; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:1","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#31-全列查询投影查询"},{"categories":["program"],"content":" 3.2 消除重复distinct 可用于一列，也可用于多列，使用后如果目标字段有重复的内容，只打印一个 mysql SELECT DISTINCT column_name0,column_name1... FROM table_name0,table_name1... [WHERE clause] [LIMIT N] [OFFSET M ] # 不出现重复打印班级里的同学名字 SELECT DISTINCT name FROM class; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:2","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#32-消除重复"},{"categories":["program"],"content":" 3.3 算术操作符 对NUMBER型数据可以使用算数操作符创建表达式（+ - * /） 对DATE型数据可以使用算数操作符创建表达式（+ -） mysql # 吧所有同学学号乘以10再打印 SELECT id*10 FROM class; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:3","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#33-算术操作符"},{"categories":["program"],"content":" 3.4 空值判断 IS NULL/IS NOT NULL 空值是指不可用、未分配的值,也就是没有值。 空值不等于零或空格 任意类型都可以支持空值，也就是说任何类型的字段都可以允许空值作为值的存在 空字符串和字符串为null的区别 包括空值的任何算术表达式都等于空，使用IFNULL(expr1,expr2)来处理, expr1为NULL就用expr2替代。 mysql # 查询班级所有name字段不为空的所有信息 SELECT * FROM class WHERE name IS NOT NULL; # 计算 学分 = 成绩/10，成绩为NULL的按0分算 SELECT IFNULL(score,0)/10 FROM class; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:4","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#34-空值判断-is-nullis-not-null"},{"categories":["program"],"content":" 3.5 比较运算符 比较运算符 表达式 用法 等于，不等于，大于，小于 =,!=,\u003c\u003e,\u003c,\u003c=,\u003e,\u003e= WHERE num\u003e=0 AND num\u003c=10 在两值之间（闭区间） BETWEEN … AND … WHRER num BETWEEN 0 AND 10 不在两值之间 NOT BETEWEEN … 同上，BETWEEN 前加 NOT 匹配在集合中的值 IN（list） WHERE name IN(‘abc’,’efg’,‘h’) 匹配不在集合中的值 NOT IN（list） 同上 模糊匹配 LIKE WHRER name LIKE ‘%abc’ OR name LIKE ‘abc_’ LIKE运算符必须使用通配符才有意义： 匹配单个字符_匹配任意多个字符% ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:5","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#35-比较运算符"},{"categories":["program"],"content":" 3.6 逻辑运算符 逻辑运算符 意义 AND 如果组合的条件都是true,返回true. OR 如果组合的条件 之一是true,返回true. NOT 如果下面的条件是false,返回true. ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:6","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#36-逻辑运算符"},{"categories":["program"],"content":" 3.7 结果排序使用ORDER BY 子句将记录排序，ORDER BY 子句出现在SELECT语句的最后，ORDER BY 可以使用别名。ASC: 升序。DESC: 降序。缺省:升序。 mysql # 查询所有信息，按id降序排序 SELECT * FROM phonelist ORDER BY id DESC; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:3:7","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#37-结果排序"},{"categories":["program"],"content":" 4 进阶","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:0","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#4-进阶"},{"categories":["program"],"content":" 4.1 索引 4.1.1 索引介绍 索引分单列索引和组合索引。 单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。 组合索引，即一个索引包含多个列。 创建索引时，你需要确保该索引是应用在SQL查询语句的条件(一般作为 WHERE 子句的条件)。 索引提高查询速度，降低更新表的速度。空间换时间 4.1.2 索引操作 查看索引 mysql SHOW INDEX FROM 表名; 创建索引 自动创建的索引，当在表上定义一个PRIMARY KEY时，自动创建一个对应的唯一索引。当在表上定义一个外键时，自动创建一个普通索引； 手动创建的索引，用户可以创建索引以加速查询，在一列或者多列上创建索引。如果多列在一起，就叫做复合索引；在很多情况下，复合索引比单个索引更好。 mysql CREATE INDEX index_name ON 表名(列名); # index_name 自定义 CREATE UNIQUE INDEX index_name ON 表名(列名); # unique 表示唯一索引 ALTER TABLE 表名 ADD INDEX index_name(列名); # 列名有多个就是组合索引 CREATE TABLE `news`( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(255) NOT NULL, `content` varchar(255) NULL, `time` varchar(20) NULL DEFAULT NULL, PRIMARY KEY (`id`), INDEX index_name (title(255)) )# 创建表同时建立索引，PRIMARY KEY 其实也是索引 删除索引 mysql ALTER TABLE 表名 DROP INDEX index_name; 检查语句是否使用索引 并不是所有情况下都会使用索引，只有当MySQL认为索引足够能够提升查询性能时才会使用； mysql EXPLAIN select * from table_name where clause; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:1","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#41-索引"},{"categories":["program"],"content":" 4.1 索引 4.1.1 索引介绍 索引分单列索引和组合索引。 单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。 组合索引，即一个索引包含多个列。 创建索引时，你需要确保该索引是应用在SQL查询语句的条件(一般作为 WHERE 子句的条件)。 索引提高查询速度，降低更新表的速度。空间换时间 4.1.2 索引操作 查看索引 mysql SHOW INDEX FROM 表名; 创建索引 自动创建的索引，当在表上定义一个PRIMARY KEY时，自动创建一个对应的唯一索引。当在表上定义一个外键时，自动创建一个普通索引； 手动创建的索引，用户可以创建索引以加速查询，在一列或者多列上创建索引。如果多列在一起，就叫做复合索引；在很多情况下，复合索引比单个索引更好。 mysql CREATE INDEX index_name ON 表名(列名); # index_name 自定义 CREATE UNIQUE INDEX index_name ON 表名(列名); # unique 表示唯一索引 ALTER TABLE 表名 ADD INDEX index_name(列名); # 列名有多个就是组合索引 CREATE TABLE `news`( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(255) NOT NULL, `content` varchar(255) NULL, `time` varchar(20) NULL DEFAULT NULL, PRIMARY KEY (`id`), INDEX index_name (title(255)) )# 创建表同时建立索引，PRIMARY KEY 其实也是索引 删除索引 mysql ALTER TABLE 表名 DROP INDEX index_name; 检查语句是否使用索引 并不是所有情况下都会使用索引，只有当MySQL认为索引足够能够提升查询性能时才会使用； mysql EXPLAIN select * from table_name where clause; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:1","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#411-索引介绍"},{"categories":["program"],"content":" 4.1 索引 4.1.1 索引介绍 索引分单列索引和组合索引。 单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。 组合索引，即一个索引包含多个列。 创建索引时，你需要确保该索引是应用在SQL查询语句的条件(一般作为 WHERE 子句的条件)。 索引提高查询速度，降低更新表的速度。空间换时间 4.1.2 索引操作 查看索引 mysql SHOW INDEX FROM 表名; 创建索引 自动创建的索引，当在表上定义一个PRIMARY KEY时，自动创建一个对应的唯一索引。当在表上定义一个外键时，自动创建一个普通索引； 手动创建的索引，用户可以创建索引以加速查询，在一列或者多列上创建索引。如果多列在一起，就叫做复合索引；在很多情况下，复合索引比单个索引更好。 mysql CREATE INDEX index_name ON 表名(列名); # index_name 自定义 CREATE UNIQUE INDEX index_name ON 表名(列名); # unique 表示唯一索引 ALTER TABLE 表名 ADD INDEX index_name(列名); # 列名有多个就是组合索引 CREATE TABLE `news`( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(255) NOT NULL, `content` varchar(255) NULL, `time` varchar(20) NULL DEFAULT NULL, PRIMARY KEY (`id`), INDEX index_name (title(255)) )# 创建表同时建立索引，PRIMARY KEY 其实也是索引 删除索引 mysql ALTER TABLE 表名 DROP INDEX index_name; 检查语句是否使用索引 并不是所有情况下都会使用索引，只有当MySQL认为索引足够能够提升查询性能时才会使用； mysql EXPLAIN select * from table_name where clause; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:1","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#412-索引操作"},{"categories":["program"],"content":" 4.2 分页查询 分页查询：一般情况下，客户端通过传递 pageNo（页码）、pageSize（每页条数）两个参数去分页查询数据库中的数据，在数据量较小（元组百/千级）时使用 MySQL自带的 limit 来解决这个问题： mysql # 从第n行开始，打印m条数据，行数从0开始，可以不加offset，默认从0开始 SELECT * FROM 表名 LIMIT m OFFSET n; # 另一种写法，从第n行开始打印m条 select * from 表名 limit n,m; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:2","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#42-分页查询"},{"categories":["program"],"content":" 4.3 函数select func();可以查看函数效果； 4.3.1 字符函数 函数 功能 LOWER/UPPER 大小写转换 CONCAT 字符连接 CHAR_LENGTH/LENGTH 求字符串长度 LPAD/RPAD 左/右 填充 LTRIM/RTRIM/TRIM 去除 全部/左边/右边 空格 REPLACE 替换 SUBSTRING 获取子串 mysql SELECT LOWER(\"ABC\"); # abc SELECT UPPER(\"abc\"); # ABC SELECT CONCAT(\"china\",\"is\",UPPER(\"greate\"));# china is GREATE SELECT CHAR_LENGTH(\"abc\"); # 3 SELECT LENGTH(\"china\"); # 5 SELECT RPAD(\"abc\",6,\"xyz\"); # abcxyz SELECT LPAD(\"abc\",6,\"X\"); # XXXabc SELECT TRIM(\" abc \"); SELECT REPLACE(\"abc\",\"b\",\"BB\"); # aBBc SELECT SUBSTRING(\"abcchina\",3); # cchina SELECT SUBSTRING(\"abcchina\",3,4); # cchi SELECT SUBSTRING(\"abcchina\",‐3); # ina 4.3.2 数学函数 函数 功能 ABS 求绝对值 MOD 求模 FLOOR/CEIL 向下/向上取整 ROUND 四舍五入 TRUNCATE 按位数截断 mysql SELECT ABS(‐100); # 100 SELECT MOD(100,3); # 1 #一下都是对浮点型数字进行操作 SELECT FLOOR(1.23); # 1 SELECT CEIL(1.23); # 2 SELECT ROUND(3.145); # 3 SELECT ROUND(3.145,2); # 3.15 保留俩位小数 SELECT TRUNCATE(3.14,1); # 3.1 截取小数点后1位 4.3.3 日期函数 函数 功能 NOW 当前时间 2017-08-06 22:33:39 YEAR 年 MONTH 月 DAY 日 HOUR 时 MINUTE 分 SECOND 秒 CURRENT_DATE 年-月-日 CURRENT_TIME 时：分：秒 LAST_DAY 所在月份的最后一天 DATE_ADD/DATE_SUB 增减 DATEDIFF 日期差 mysql SELECT NOW(); # 2019-02-13 12:51:39 SELECT YEAR(NOW()); # 2019 SELECT MONTH(NOW()); # 2 SELECT DAY(NOW()); # 13 # HOUT MINUTE SECOND 用法同上 SELECT CURRENT_DATE(); # 2019-02-13 简写CURDATE() SELECT CURRENT_TIME(); # 12:56:20 简写CURTIME() SELECT LAST_DAY(NOW()); # 2019-02-28 SELECT LAST_DAY(str_to_date('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s')); # 2019-12-31 SELECT DATE_ADD(NOW(),INTERVAL 2 DAY); # 2019-02-15 13:02:01 SELECT DATE_SUB(NOW(),INTERVAL 3 HOUR); SELECT DATEDIFF(LAST_DAY(NOW()),NOW()); # 15 4.3.4 转换函数 函数 功能 FORMAT 数字到字符串的转化 DATE_FORMAT 时间到字符串 STR_TO_DATE 字符串到时间 mysql SELECT FORMAT(235235.346326,2); # 小数点保留2位 235,235.35 SELECT DATE_FORMAT(NOW(),'%b %d %Y %h:%i %p'); # Feb 13 2019 01:16 PM SELECT DATE_FORMAT(NOW(),'%m-%d-%Y'); # 02-13-2019 SELECT STR_TO_DATE('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s'); # 2019-12-01 00:00:00 4.3.5 聚合函数 函数 功能 COUNT() 返回指定列中（满足条件的）非NULL值的个数 AVG() 返回指定列（满足条件的）的平均值 SUM() 返回指定列（满足条件的）的所有值之和 MAX() 返回指定列（满足条件的）的最大值 MIN() 返回指定列（满足条件的）的最小值 mysql # 计算班级 50分以上同学的分数最大差 SELECT MAX(score)‐MIN(score) FROM class WHERE; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:3","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#43-函数"},{"categories":["program"],"content":" 4.3 函数select func();可以查看函数效果； 4.3.1 字符函数 函数 功能 LOWER/UPPER 大小写转换 CONCAT 字符连接 CHAR_LENGTH/LENGTH 求字符串长度 LPAD/RPAD 左/右 填充 LTRIM/RTRIM/TRIM 去除 全部/左边/右边 空格 REPLACE 替换 SUBSTRING 获取子串 mysql SELECT LOWER(\"ABC\"); # abc SELECT UPPER(\"abc\"); # ABC SELECT CONCAT(\"china\",\"is\",UPPER(\"greate\"));# china is GREATE SELECT CHAR_LENGTH(\"abc\"); # 3 SELECT LENGTH(\"china\"); # 5 SELECT RPAD(\"abc\",6,\"xyz\"); # abcxyz SELECT LPAD(\"abc\",6,\"X\"); # XXXabc SELECT TRIM(\" abc \"); SELECT REPLACE(\"abc\",\"b\",\"BB\"); # aBBc SELECT SUBSTRING(\"abcchina\",3); # cchina SELECT SUBSTRING(\"abcchina\",3,4); # cchi SELECT SUBSTRING(\"abcchina\",‐3); # ina 4.3.2 数学函数 函数 功能 ABS 求绝对值 MOD 求模 FLOOR/CEIL 向下/向上取整 ROUND 四舍五入 TRUNCATE 按位数截断 mysql SELECT ABS(‐100); # 100 SELECT MOD(100,3); # 1 #一下都是对浮点型数字进行操作 SELECT FLOOR(1.23); # 1 SELECT CEIL(1.23); # 2 SELECT ROUND(3.145); # 3 SELECT ROUND(3.145,2); # 3.15 保留俩位小数 SELECT TRUNCATE(3.14,1); # 3.1 截取小数点后1位 4.3.3 日期函数 函数 功能 NOW 当前时间 2017-08-06 22:33:39 YEAR 年 MONTH 月 DAY 日 HOUR 时 MINUTE 分 SECOND 秒 CURRENT_DATE 年-月-日 CURRENT_TIME 时：分：秒 LAST_DAY 所在月份的最后一天 DATE_ADD/DATE_SUB 增减 DATEDIFF 日期差 mysql SELECT NOW(); # 2019-02-13 12:51:39 SELECT YEAR(NOW()); # 2019 SELECT MONTH(NOW()); # 2 SELECT DAY(NOW()); # 13 # HOUT MINUTE SECOND 用法同上 SELECT CURRENT_DATE(); # 2019-02-13 简写CURDATE() SELECT CURRENT_TIME(); # 12:56:20 简写CURTIME() SELECT LAST_DAY(NOW()); # 2019-02-28 SELECT LAST_DAY(str_to_date('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s')); # 2019-12-31 SELECT DATE_ADD(NOW(),INTERVAL 2 DAY); # 2019-02-15 13:02:01 SELECT DATE_SUB(NOW(),INTERVAL 3 HOUR); SELECT DATEDIFF(LAST_DAY(NOW()),NOW()); # 15 4.3.4 转换函数 函数 功能 FORMAT 数字到字符串的转化 DATE_FORMAT 时间到字符串 STR_TO_DATE 字符串到时间 mysql SELECT FORMAT(235235.346326,2); # 小数点保留2位 235,235.35 SELECT DATE_FORMAT(NOW(),'%b %d %Y %h:%i %p'); # Feb 13 2019 01:16 PM SELECT DATE_FORMAT(NOW(),'%m-%d-%Y'); # 02-13-2019 SELECT STR_TO_DATE('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s'); # 2019-12-01 00:00:00 4.3.5 聚合函数 函数 功能 COUNT() 返回指定列中（满足条件的）非NULL值的个数 AVG() 返回指定列（满足条件的）的平均值 SUM() 返回指定列（满足条件的）的所有值之和 MAX() 返回指定列（满足条件的）的最大值 MIN() 返回指定列（满足条件的）的最小值 mysql # 计算班级 50分以上同学的分数最大差 SELECT MAX(score)‐MIN(score) FROM class WHERE; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:3","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#431-字符函数"},{"categories":["program"],"content":" 4.3 函数select func();可以查看函数效果； 4.3.1 字符函数 函数 功能 LOWER/UPPER 大小写转换 CONCAT 字符连接 CHAR_LENGTH/LENGTH 求字符串长度 LPAD/RPAD 左/右 填充 LTRIM/RTRIM/TRIM 去除 全部/左边/右边 空格 REPLACE 替换 SUBSTRING 获取子串 mysql SELECT LOWER(\"ABC\"); # abc SELECT UPPER(\"abc\"); # ABC SELECT CONCAT(\"china\",\"is\",UPPER(\"greate\"));# china is GREATE SELECT CHAR_LENGTH(\"abc\"); # 3 SELECT LENGTH(\"china\"); # 5 SELECT RPAD(\"abc\",6,\"xyz\"); # abcxyz SELECT LPAD(\"abc\",6,\"X\"); # XXXabc SELECT TRIM(\" abc \"); SELECT REPLACE(\"abc\",\"b\",\"BB\"); # aBBc SELECT SUBSTRING(\"abcchina\",3); # cchina SELECT SUBSTRING(\"abcchina\",3,4); # cchi SELECT SUBSTRING(\"abcchina\",‐3); # ina 4.3.2 数学函数 函数 功能 ABS 求绝对值 MOD 求模 FLOOR/CEIL 向下/向上取整 ROUND 四舍五入 TRUNCATE 按位数截断 mysql SELECT ABS(‐100); # 100 SELECT MOD(100,3); # 1 #一下都是对浮点型数字进行操作 SELECT FLOOR(1.23); # 1 SELECT CEIL(1.23); # 2 SELECT ROUND(3.145); # 3 SELECT ROUND(3.145,2); # 3.15 保留俩位小数 SELECT TRUNCATE(3.14,1); # 3.1 截取小数点后1位 4.3.3 日期函数 函数 功能 NOW 当前时间 2017-08-06 22:33:39 YEAR 年 MONTH 月 DAY 日 HOUR 时 MINUTE 分 SECOND 秒 CURRENT_DATE 年-月-日 CURRENT_TIME 时：分：秒 LAST_DAY 所在月份的最后一天 DATE_ADD/DATE_SUB 增减 DATEDIFF 日期差 mysql SELECT NOW(); # 2019-02-13 12:51:39 SELECT YEAR(NOW()); # 2019 SELECT MONTH(NOW()); # 2 SELECT DAY(NOW()); # 13 # HOUT MINUTE SECOND 用法同上 SELECT CURRENT_DATE(); # 2019-02-13 简写CURDATE() SELECT CURRENT_TIME(); # 12:56:20 简写CURTIME() SELECT LAST_DAY(NOW()); # 2019-02-28 SELECT LAST_DAY(str_to_date('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s')); # 2019-12-31 SELECT DATE_ADD(NOW(),INTERVAL 2 DAY); # 2019-02-15 13:02:01 SELECT DATE_SUB(NOW(),INTERVAL 3 HOUR); SELECT DATEDIFF(LAST_DAY(NOW()),NOW()); # 15 4.3.4 转换函数 函数 功能 FORMAT 数字到字符串的转化 DATE_FORMAT 时间到字符串 STR_TO_DATE 字符串到时间 mysql SELECT FORMAT(235235.346326,2); # 小数点保留2位 235,235.35 SELECT DATE_FORMAT(NOW(),'%b %d %Y %h:%i %p'); # Feb 13 2019 01:16 PM SELECT DATE_FORMAT(NOW(),'%m-%d-%Y'); # 02-13-2019 SELECT STR_TO_DATE('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s'); # 2019-12-01 00:00:00 4.3.5 聚合函数 函数 功能 COUNT() 返回指定列中（满足条件的）非NULL值的个数 AVG() 返回指定列（满足条件的）的平均值 SUM() 返回指定列（满足条件的）的所有值之和 MAX() 返回指定列（满足条件的）的最大值 MIN() 返回指定列（满足条件的）的最小值 mysql # 计算班级 50分以上同学的分数最大差 SELECT MAX(score)‐MIN(score) FROM class WHERE; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:3","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#432-数学函数"},{"categories":["program"],"content":" 4.3 函数select func();可以查看函数效果； 4.3.1 字符函数 函数 功能 LOWER/UPPER 大小写转换 CONCAT 字符连接 CHAR_LENGTH/LENGTH 求字符串长度 LPAD/RPAD 左/右 填充 LTRIM/RTRIM/TRIM 去除 全部/左边/右边 空格 REPLACE 替换 SUBSTRING 获取子串 mysql SELECT LOWER(\"ABC\"); # abc SELECT UPPER(\"abc\"); # ABC SELECT CONCAT(\"china\",\"is\",UPPER(\"greate\"));# china is GREATE SELECT CHAR_LENGTH(\"abc\"); # 3 SELECT LENGTH(\"china\"); # 5 SELECT RPAD(\"abc\",6,\"xyz\"); # abcxyz SELECT LPAD(\"abc\",6,\"X\"); # XXXabc SELECT TRIM(\" abc \"); SELECT REPLACE(\"abc\",\"b\",\"BB\"); # aBBc SELECT SUBSTRING(\"abcchina\",3); # cchina SELECT SUBSTRING(\"abcchina\",3,4); # cchi SELECT SUBSTRING(\"abcchina\",‐3); # ina 4.3.2 数学函数 函数 功能 ABS 求绝对值 MOD 求模 FLOOR/CEIL 向下/向上取整 ROUND 四舍五入 TRUNCATE 按位数截断 mysql SELECT ABS(‐100); # 100 SELECT MOD(100,3); # 1 #一下都是对浮点型数字进行操作 SELECT FLOOR(1.23); # 1 SELECT CEIL(1.23); # 2 SELECT ROUND(3.145); # 3 SELECT ROUND(3.145,2); # 3.15 保留俩位小数 SELECT TRUNCATE(3.14,1); # 3.1 截取小数点后1位 4.3.3 日期函数 函数 功能 NOW 当前时间 2017-08-06 22:33:39 YEAR 年 MONTH 月 DAY 日 HOUR 时 MINUTE 分 SECOND 秒 CURRENT_DATE 年-月-日 CURRENT_TIME 时：分：秒 LAST_DAY 所在月份的最后一天 DATE_ADD/DATE_SUB 增减 DATEDIFF 日期差 mysql SELECT NOW(); # 2019-02-13 12:51:39 SELECT YEAR(NOW()); # 2019 SELECT MONTH(NOW()); # 2 SELECT DAY(NOW()); # 13 # HOUT MINUTE SECOND 用法同上 SELECT CURRENT_DATE(); # 2019-02-13 简写CURDATE() SELECT CURRENT_TIME(); # 12:56:20 简写CURTIME() SELECT LAST_DAY(NOW()); # 2019-02-28 SELECT LAST_DAY(str_to_date('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s')); # 2019-12-31 SELECT DATE_ADD(NOW(),INTERVAL 2 DAY); # 2019-02-15 13:02:01 SELECT DATE_SUB(NOW(),INTERVAL 3 HOUR); SELECT DATEDIFF(LAST_DAY(NOW()),NOW()); # 15 4.3.4 转换函数 函数 功能 FORMAT 数字到字符串的转化 DATE_FORMAT 时间到字符串 STR_TO_DATE 字符串到时间 mysql SELECT FORMAT(235235.346326,2); # 小数点保留2位 235,235.35 SELECT DATE_FORMAT(NOW(),'%b %d %Y %h:%i %p'); # Feb 13 2019 01:16 PM SELECT DATE_FORMAT(NOW(),'%m-%d-%Y'); # 02-13-2019 SELECT STR_TO_DATE('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s'); # 2019-12-01 00:00:00 4.3.5 聚合函数 函数 功能 COUNT() 返回指定列中（满足条件的）非NULL值的个数 AVG() 返回指定列（满足条件的）的平均值 SUM() 返回指定列（满足条件的）的所有值之和 MAX() 返回指定列（满足条件的）的最大值 MIN() 返回指定列（满足条件的）的最小值 mysql # 计算班级 50分以上同学的分数最大差 SELECT MAX(score)‐MIN(score) FROM class WHERE; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:3","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#433-日期函数"},{"categories":["program"],"content":" 4.3 函数select func();可以查看函数效果； 4.3.1 字符函数 函数 功能 LOWER/UPPER 大小写转换 CONCAT 字符连接 CHAR_LENGTH/LENGTH 求字符串长度 LPAD/RPAD 左/右 填充 LTRIM/RTRIM/TRIM 去除 全部/左边/右边 空格 REPLACE 替换 SUBSTRING 获取子串 mysql SELECT LOWER(\"ABC\"); # abc SELECT UPPER(\"abc\"); # ABC SELECT CONCAT(\"china\",\"is\",UPPER(\"greate\"));# china is GREATE SELECT CHAR_LENGTH(\"abc\"); # 3 SELECT LENGTH(\"china\"); # 5 SELECT RPAD(\"abc\",6,\"xyz\"); # abcxyz SELECT LPAD(\"abc\",6,\"X\"); # XXXabc SELECT TRIM(\" abc \"); SELECT REPLACE(\"abc\",\"b\",\"BB\"); # aBBc SELECT SUBSTRING(\"abcchina\",3); # cchina SELECT SUBSTRING(\"abcchina\",3,4); # cchi SELECT SUBSTRING(\"abcchina\",‐3); # ina 4.3.2 数学函数 函数 功能 ABS 求绝对值 MOD 求模 FLOOR/CEIL 向下/向上取整 ROUND 四舍五入 TRUNCATE 按位数截断 mysql SELECT ABS(‐100); # 100 SELECT MOD(100,3); # 1 #一下都是对浮点型数字进行操作 SELECT FLOOR(1.23); # 1 SELECT CEIL(1.23); # 2 SELECT ROUND(3.145); # 3 SELECT ROUND(3.145,2); # 3.15 保留俩位小数 SELECT TRUNCATE(3.14,1); # 3.1 截取小数点后1位 4.3.3 日期函数 函数 功能 NOW 当前时间 2017-08-06 22:33:39 YEAR 年 MONTH 月 DAY 日 HOUR 时 MINUTE 分 SECOND 秒 CURRENT_DATE 年-月-日 CURRENT_TIME 时：分：秒 LAST_DAY 所在月份的最后一天 DATE_ADD/DATE_SUB 增减 DATEDIFF 日期差 mysql SELECT NOW(); # 2019-02-13 12:51:39 SELECT YEAR(NOW()); # 2019 SELECT MONTH(NOW()); # 2 SELECT DAY(NOW()); # 13 # HOUT MINUTE SECOND 用法同上 SELECT CURRENT_DATE(); # 2019-02-13 简写CURDATE() SELECT CURRENT_TIME(); # 12:56:20 简写CURTIME() SELECT LAST_DAY(NOW()); # 2019-02-28 SELECT LAST_DAY(str_to_date('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s')); # 2019-12-31 SELECT DATE_ADD(NOW(),INTERVAL 2 DAY); # 2019-02-15 13:02:01 SELECT DATE_SUB(NOW(),INTERVAL 3 HOUR); SELECT DATEDIFF(LAST_DAY(NOW()),NOW()); # 15 4.3.4 转换函数 函数 功能 FORMAT 数字到字符串的转化 DATE_FORMAT 时间到字符串 STR_TO_DATE 字符串到时间 mysql SELECT FORMAT(235235.346326,2); # 小数点保留2位 235,235.35 SELECT DATE_FORMAT(NOW(),'%b %d %Y %h:%i %p'); # Feb 13 2019 01:16 PM SELECT DATE_FORMAT(NOW(),'%m-%d-%Y'); # 02-13-2019 SELECT STR_TO_DATE('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s'); # 2019-12-01 00:00:00 4.3.5 聚合函数 函数 功能 COUNT() 返回指定列中（满足条件的）非NULL值的个数 AVG() 返回指定列（满足条件的）的平均值 SUM() 返回指定列（满足条件的）的所有值之和 MAX() 返回指定列（满足条件的）的最大值 MIN() 返回指定列（满足条件的）的最小值 mysql # 计算班级 50分以上同学的分数最大差 SELECT MAX(score)‐MIN(score) FROM class WHERE; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:3","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#434-转换函数"},{"categories":["program"],"content":" 4.3 函数select func();可以查看函数效果； 4.3.1 字符函数 函数 功能 LOWER/UPPER 大小写转换 CONCAT 字符连接 CHAR_LENGTH/LENGTH 求字符串长度 LPAD/RPAD 左/右 填充 LTRIM/RTRIM/TRIM 去除 全部/左边/右边 空格 REPLACE 替换 SUBSTRING 获取子串 mysql SELECT LOWER(\"ABC\"); # abc SELECT UPPER(\"abc\"); # ABC SELECT CONCAT(\"china\",\"is\",UPPER(\"greate\"));# china is GREATE SELECT CHAR_LENGTH(\"abc\"); # 3 SELECT LENGTH(\"china\"); # 5 SELECT RPAD(\"abc\",6,\"xyz\"); # abcxyz SELECT LPAD(\"abc\",6,\"X\"); # XXXabc SELECT TRIM(\" abc \"); SELECT REPLACE(\"abc\",\"b\",\"BB\"); # aBBc SELECT SUBSTRING(\"abcchina\",3); # cchina SELECT SUBSTRING(\"abcchina\",3,4); # cchi SELECT SUBSTRING(\"abcchina\",‐3); # ina 4.3.2 数学函数 函数 功能 ABS 求绝对值 MOD 求模 FLOOR/CEIL 向下/向上取整 ROUND 四舍五入 TRUNCATE 按位数截断 mysql SELECT ABS(‐100); # 100 SELECT MOD(100,3); # 1 #一下都是对浮点型数字进行操作 SELECT FLOOR(1.23); # 1 SELECT CEIL(1.23); # 2 SELECT ROUND(3.145); # 3 SELECT ROUND(3.145,2); # 3.15 保留俩位小数 SELECT TRUNCATE(3.14,1); # 3.1 截取小数点后1位 4.3.3 日期函数 函数 功能 NOW 当前时间 2017-08-06 22:33:39 YEAR 年 MONTH 月 DAY 日 HOUR 时 MINUTE 分 SECOND 秒 CURRENT_DATE 年-月-日 CURRENT_TIME 时：分：秒 LAST_DAY 所在月份的最后一天 DATE_ADD/DATE_SUB 增减 DATEDIFF 日期差 mysql SELECT NOW(); # 2019-02-13 12:51:39 SELECT YEAR(NOW()); # 2019 SELECT MONTH(NOW()); # 2 SELECT DAY(NOW()); # 13 # HOUT MINUTE SECOND 用法同上 SELECT CURRENT_DATE(); # 2019-02-13 简写CURDATE() SELECT CURRENT_TIME(); # 12:56:20 简写CURTIME() SELECT LAST_DAY(NOW()); # 2019-02-28 SELECT LAST_DAY(str_to_date('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s')); # 2019-12-31 SELECT DATE_ADD(NOW(),INTERVAL 2 DAY); # 2019-02-15 13:02:01 SELECT DATE_SUB(NOW(),INTERVAL 3 HOUR); SELECT DATEDIFF(LAST_DAY(NOW()),NOW()); # 15 4.3.4 转换函数 函数 功能 FORMAT 数字到字符串的转化 DATE_FORMAT 时间到字符串 STR_TO_DATE 字符串到时间 mysql SELECT FORMAT(235235.346326,2); # 小数点保留2位 235,235.35 SELECT DATE_FORMAT(NOW(),'%b %d %Y %h:%i %p'); # Feb 13 2019 01:16 PM SELECT DATE_FORMAT(NOW(),'%m-%d-%Y'); # 02-13-2019 SELECT STR_TO_DATE('2019-12-01 00:00:00','%Y-%m-%d %H:%i:%s'); # 2019-12-01 00:00:00 4.3.5 聚合函数 函数 功能 COUNT() 返回指定列中（满足条件的）非NULL值的个数 AVG() 返回指定列（满足条件的）的平均值 SUM() 返回指定列（满足条件的）的所有值之和 MAX() 返回指定列（满足条件的）的最大值 MIN() 返回指定列（满足条件的）的最小值 mysql # 计算班级 50分以上同学的分数最大差 SELECT MAX(score)‐MIN(score) FROM class WHERE; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:3","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#435-聚合函数"},{"categories":["program"],"content":" 4.4 分组查询 4.4.1 GROUP BY在对数据表中数据进行统计时，可能需要按照一定的类别分别进行统计， 如score字段中，值相同的行被视作一类（分组） 单独使用GROUP BY关键字，查询的是每个分组中的一条记录，意义不大。 一般情况下，GROUP BY都和聚合函数一起使用 mysql # 统计60分以上，各个分数的人数 SELECT COUNT(*),score FROM class WHERE score\u003e60 GROUP BY score; 4.4.2 HAVINGHAVING关键字和 WHERE 关键字的作用相同，都是用于设置条件表达式，对查询结果进行过滤。 两者的区别，HAVING关键字后，可以跟聚合函数，而WHERE关键字不能，通常情况下，HAVING关键字，都是和GROUP BY一起使用，用于对分组后的结果进行过滤 mysql ## 统计60分以上，各个分数的人数, 并且只筛选相同分数的人数小于10人的分组 SELECT COUNT(*),score FROM class WHERE score\u003e60 GROUP BY score HAVING count(*)\u003c10; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:4","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#44-分组查询"},{"categories":["program"],"content":" 4.4 分组查询 4.4.1 GROUP BY在对数据表中数据进行统计时，可能需要按照一定的类别分别进行统计， 如score字段中，值相同的行被视作一类（分组） 单独使用GROUP BY关键字，查询的是每个分组中的一条记录，意义不大。 一般情况下，GROUP BY都和聚合函数一起使用 mysql # 统计60分以上，各个分数的人数 SELECT COUNT(*),score FROM class WHERE score\u003e60 GROUP BY score; 4.4.2 HAVINGHAVING关键字和 WHERE 关键字的作用相同，都是用于设置条件表达式，对查询结果进行过滤。 两者的区别，HAVING关键字后，可以跟聚合函数，而WHERE关键字不能，通常情况下，HAVING关键字，都是和GROUP BY一起使用，用于对分组后的结果进行过滤 mysql ## 统计60分以上，各个分数的人数, 并且只筛选相同分数的人数小于10人的分组 SELECT COUNT(*),score FROM class WHERE score\u003e60 GROUP BY score HAVING count(*)\u003c10; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:4","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#441-group-by"},{"categories":["program"],"content":" 4.4 分组查询 4.4.1 GROUP BY在对数据表中数据进行统计时，可能需要按照一定的类别分别进行统计， 如score字段中，值相同的行被视作一类（分组） 单独使用GROUP BY关键字，查询的是每个分组中的一条记录，意义不大。 一般情况下，GROUP BY都和聚合函数一起使用 mysql # 统计60分以上，各个分数的人数 SELECT COUNT(*),score FROM class WHERE score\u003e60 GROUP BY score; 4.4.2 HAVINGHAVING关键字和 WHERE 关键字的作用相同，都是用于设置条件表达式，对查询结果进行过滤。 两者的区别，HAVING关键字后，可以跟聚合函数，而WHERE关键字不能，通常情况下，HAVING关键字，都是和GROUP BY一起使用，用于对分组后的结果进行过滤 mysql ## 统计60分以上，各个分数的人数, 并且只筛选相同分数的人数小于10人的分组 SELECT COUNT(*),score FROM class WHERE score\u003e60 GROUP BY score HAVING count(*)\u003c10; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:4","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#442-having"},{"categories":["program"],"content":" 4.5 多表查询 补充 可以给表起别名 mysql # 这里给表 phonelist 起了别名 p，多表操作别名很方便 SELECT p.name FROM phonelist p where p.id=2; 多表查询,如果没有连接条件,则会产生笛卡尔积，实际运行环境下，应避免使用全笛卡尔集。 笛卡儿积，即如果有两个表，拿第一个表的一条数据跟第二个表每条数据都关联，这样的数据没有意义 在WHERE加入有效的连接条件（等值连接）。注意连接 n张表，至少需要 n-1个连接条件。 这个博客讲的很清楚 mysql SELECT a.t1 b.msg FROM a,b WHERE a.id=b.id; #这里id就是连接条件，id相同才会被关联 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:5","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#45-多表查询"},{"categories":["program"],"content":" 4.6 主键和外键 主键约束(PRIMARY KEY): 约束在当前表中,指定列的值非空且唯一。 外键约束(FOREIGN KEY): A表中的外键列的值必须引用于于B表中的某主键列。 mysql ALTER TABLE `A` ADD FOREIGN KEY(`myid`) REFERENCES `B`(`id`); 如果建立外键后，要删除B中数据的时候，需要先删除A中相关的数据。 可以看作表A是B的附属，没有B，A就没有意义了； ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:6","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#46-主键和外键"},{"categories":["program"],"content":" 4.7 子查询 子查询指的就是在一个查询之中嵌套了其他的若干查询。 在使用select语句查询数据时,有时候会遇到这样的情况，在where查询条件中的限制条件不是一个确定的值，而是一个来自于另一个查询的结果。 子查询一般出现在FROM和WHERE子句中。 4.7.1 子查询返回单行单列 单行单列子查询：只包含一个字段的查询，返回的查询结果也只包含一行数据, 看做是一个值. 使用在WHERE之后。 mysql # 查询分数高于班级平均分的同学的姓名 SELECT name FROM class WHERE score\u003e(SELECT AVG(score) FROM class); 4.7.2 子查询返回多行单列 多行单列子查询：只包含了一个字段，但返回的查询结果可能多行或者零行，看做是多个值，使用在WHERE之后。 关键字 含义 IN 与列表中的任意一个值相等 ANY 与子查询返回的任意一个值比较 ALL 与子查询返回的每一个值比较 mysql # 查询工资等于部门经理的员工信息. SELECT * FROM emp WHERE sal IN (SELECT sal FROM emp WHERE JOB='manager'); SELECT * FROM emp WHERE sal \u003e ANY (SELECT sal FROM emp WHERE JOB='manager'); SELECT * FROM emp WHERE sal \u003e ALL (SELECT sal FROM emp WHERE JOB='manager'); 4.7.3 子查询返回多行多列 多行多列子查询：包含多个字段的返回，查询结构可能是单行或者多行，看做是临时表，使用在FROM之后，临时表需要有别名。 mysql # tmp是临时表别名 SELECT tmp.* FROM (SELECT deptno,AVG(sal) avg_sal FROM emp GROUP BY deptno) tmp WHERE tmp.avg_sal \u003e 2000; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:7","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#47-子查询"},{"categories":["program"],"content":" 4.7 子查询 子查询指的就是在一个查询之中嵌套了其他的若干查询。 在使用select语句查询数据时,有时候会遇到这样的情况，在where查询条件中的限制条件不是一个确定的值，而是一个来自于另一个查询的结果。 子查询一般出现在FROM和WHERE子句中。 4.7.1 子查询返回单行单列 单行单列子查询：只包含一个字段的查询，返回的查询结果也只包含一行数据, 看做是一个值. 使用在WHERE之后。 mysql # 查询分数高于班级平均分的同学的姓名 SELECT name FROM class WHERE score\u003e(SELECT AVG(score) FROM class); 4.7.2 子查询返回多行单列 多行单列子查询：只包含了一个字段，但返回的查询结果可能多行或者零行，看做是多个值，使用在WHERE之后。 关键字 含义 IN 与列表中的任意一个值相等 ANY 与子查询返回的任意一个值比较 ALL 与子查询返回的每一个值比较 mysql # 查询工资等于部门经理的员工信息. SELECT * FROM emp WHERE sal IN (SELECT sal FROM emp WHERE JOB='manager'); SELECT * FROM emp WHERE sal \u003e ANY (SELECT sal FROM emp WHERE JOB='manager'); SELECT * FROM emp WHERE sal \u003e ALL (SELECT sal FROM emp WHERE JOB='manager'); 4.7.3 子查询返回多行多列 多行多列子查询：包含多个字段的返回，查询结构可能是单行或者多行，看做是临时表，使用在FROM之后，临时表需要有别名。 mysql # tmp是临时表别名 SELECT tmp.* FROM (SELECT deptno,AVG(sal) avg_sal FROM emp GROUP BY deptno) tmp WHERE tmp.avg_sal \u003e 2000; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:7","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#471-子查询返回单行单列"},{"categories":["program"],"content":" 4.7 子查询 子查询指的就是在一个查询之中嵌套了其他的若干查询。 在使用select语句查询数据时,有时候会遇到这样的情况，在where查询条件中的限制条件不是一个确定的值，而是一个来自于另一个查询的结果。 子查询一般出现在FROM和WHERE子句中。 4.7.1 子查询返回单行单列 单行单列子查询：只包含一个字段的查询，返回的查询结果也只包含一行数据, 看做是一个值. 使用在WHERE之后。 mysql # 查询分数高于班级平均分的同学的姓名 SELECT name FROM class WHERE score\u003e(SELECT AVG(score) FROM class); 4.7.2 子查询返回多行单列 多行单列子查询：只包含了一个字段，但返回的查询结果可能多行或者零行，看做是多个值，使用在WHERE之后。 关键字 含义 IN 与列表中的任意一个值相等 ANY 与子查询返回的任意一个值比较 ALL 与子查询返回的每一个值比较 mysql # 查询工资等于部门经理的员工信息. SELECT * FROM emp WHERE sal IN (SELECT sal FROM emp WHERE JOB='manager'); SELECT * FROM emp WHERE sal \u003e ANY (SELECT sal FROM emp WHERE JOB='manager'); SELECT * FROM emp WHERE sal \u003e ALL (SELECT sal FROM emp WHERE JOB='manager'); 4.7.3 子查询返回多行多列 多行多列子查询：包含多个字段的返回，查询结构可能是单行或者多行，看做是临时表，使用在FROM之后，临时表需要有别名。 mysql # tmp是临时表别名 SELECT tmp.* FROM (SELECT deptno,AVG(sal) avg_sal FROM emp GROUP BY deptno) tmp WHERE tmp.avg_sal \u003e 2000; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:7","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#472-子查询返回多行单列"},{"categories":["program"],"content":" 4.7 子查询 子查询指的就是在一个查询之中嵌套了其他的若干查询。 在使用select语句查询数据时,有时候会遇到这样的情况，在where查询条件中的限制条件不是一个确定的值，而是一个来自于另一个查询的结果。 子查询一般出现在FROM和WHERE子句中。 4.7.1 子查询返回单行单列 单行单列子查询：只包含一个字段的查询，返回的查询结果也只包含一行数据, 看做是一个值. 使用在WHERE之后。 mysql # 查询分数高于班级平均分的同学的姓名 SELECT name FROM class WHERE score\u003e(SELECT AVG(score) FROM class); 4.7.2 子查询返回多行单列 多行单列子查询：只包含了一个字段，但返回的查询结果可能多行或者零行，看做是多个值，使用在WHERE之后。 关键字 含义 IN 与列表中的任意一个值相等 ANY 与子查询返回的任意一个值比较 ALL 与子查询返回的每一个值比较 mysql # 查询工资等于部门经理的员工信息. SELECT * FROM emp WHERE sal IN (SELECT sal FROM emp WHERE JOB='manager'); SELECT * FROM emp WHERE sal \u003e ANY (SELECT sal FROM emp WHERE JOB='manager'); SELECT * FROM emp WHERE sal \u003e ALL (SELECT sal FROM emp WHERE JOB='manager'); 4.7.3 子查询返回多行多列 多行多列子查询：包含多个字段的返回，查询结构可能是单行或者多行，看做是临时表，使用在FROM之后，临时表需要有别名。 mysql # tmp是临时表别名 SELECT tmp.* FROM (SELECT deptno,AVG(sal) avg_sal FROM emp GROUP BY deptno) tmp WHERE tmp.avg_sal \u003e 2000; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:7","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#473-子查询返回多行多列"},{"categories":["program"],"content":" 4.8 备份与回复 备份 bash kirito@host:~$ mysqldump ‐u账户 ‐p密码 数据库名称\u003e文件存储地址 # 栗子 kirito@host:~$ mysqldump ‐uroot ‐p123456 testDB\u003e /home/kirito/testDB_bak.sql 恢复 shell kirito@host:~$ mysql ‐u账户 ‐p密码 数据库名称\u003c 文件存储地址 （数据库要已存在） # 栗子 kirito@host:~$ mysql ‐uroot ‐p123456 testDB\u003c /home/kirito/_bak.sql mysql # 也可以进入数据库导入 CREATE DATABASE testdb; USE testdb; SOURCE /home/kirito/_bak.sql; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:8","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#48-备份与回复"},{"categories":["program"],"content":" 4.9 SQL语句执行顺序 书写顺序 mysql SELECT [DISTINCT] [聚合函数] FROM WHERE GROUP BY HAVING ORDER BY 执行顺序 mysql FROM WHERE GROUP BY #从这里开始可以使用别名 聚合函数 HAVING SELECT DISTINCT ORDER BY ","date":"2019-03-19","objectID":"/mysql-operation-manual/:4:9","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#49-sql语句执行顺序"},{"categories":["program"],"content":" 5 事务处理(transaction)在数据库中，所谓事务是指一组逻辑操作单元，使数据从一种状态变换到另一种状态。为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元:当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 事务的操作:先定义开始一个事务，然后对数据作修改操作，这时如果提交(COMMIT)，这些修改就永久地保存下来，如果回退(ROLLBACK)，数据库管理系统将放弃您所作的所有修改而回到开始事务时的状态。 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:5:0","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#5-事务处理transaction"},{"categories":["program"],"content":" 5.1 事务的ACID属性 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。(数据不被破坏). 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰,每一个事务都存在一个事务空间,彼此不干扰。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响. ","date":"2019-03-19","objectID":"/mysql-operation-manual/:5:1","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#51-事务的acid属性"},{"categories":["program"],"content":" 5.2 事务语句 mysql BEGIN # 开启一个事务 COMMIT # 提交事务 ROLLBACK # 回滚事务 # 栗子 BEGIN; SELECT * FROM class WHERE id=1; UPDATE class SET score=100 WHERE id=1; COMMIT; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:5:2","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#52-事务语句"},{"categories":["program"],"content":" 5.3 事务并发问题 数据库的事务并发问题: 存在五种问题:脏读，不可重复读，幻读，第一类丢失更新，第二类丢失更新。 详细见附录 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:5:3","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#53-事务并发问题"},{"categories":["program"],"content":" 5.4 锁机制 mysql中使用repeatable read模式，只存在第二类丢失更新，通过加锁的方式可以避免。 mysql for update # 加锁 锁释放发生在回滚和提交。 # lock in share mode # 共享锁 /* for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。 */ # 栗子 BEGIN; SELECT * FROM class WHERE id=1 FOR UPDATE; # 加锁 UPDATE class SET score=100 WHERE id=1; COMMIT; # 释放 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:5:4","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#54-锁机制"},{"categories":["program"],"content":" 附录","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:0","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#附录"},{"categories":["program"],"content":" A 数据类型 A.1 数值类型MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M\u003eD，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 A.2 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个\"零\"值，当指定不合法的MySQL不能表示的值时使用\"零\"值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 (字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 A.3 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 ALTER TABLE table_name DRO P INDEX index_name; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:1","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#a-数据类型"},{"categories":["program"],"content":" A 数据类型 A.1 数值类型MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M\u003eD，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 A.2 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个\"零\"值，当指定不合法的MySQL不能表示的值时使用\"零\"值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 (字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 A.3 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 ALTER TABLE table_name DRO P INDEX index_name; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:1","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#a1-数值类型"},{"categories":["program"],"content":" A 数据类型 A.1 数值类型MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M\u003eD，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 A.2 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个\"零\"值，当指定不合法的MySQL不能表示的值时使用\"零\"值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 (字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 A.3 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 ALTER TABLE table_name DRO P INDEX index_name; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:1","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#a2-日期和时间类型"},{"categories":["program"],"content":" A 数据类型 A.1 数值类型MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M\u003eD，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 A.2 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个\"零\"值，当指定不合法的MySQL不能表示的值时使用\"零\"值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 (字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 A.3 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 ALTER TABLE table_name DRO P INDEX index_name; ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:1","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#a3-字符串类型"},{"categories":["program"],"content":" B 并发问题 B.1 脏读（dirty readA事物读取B事物尚未提交更改的数据，并在这个数据的基础上操作。如果B事物恰巧回滚，那么A事物读取到的事物是根本不被承认的。如下列： 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询余额1000元 T4 取出500元，余额改为500元 T5 查询余额500元（脏读） T6 撤销事物余额1000元 T7 汇入100元，余额改为600元 T8 提交事物 在这个场景中B希望取出500元，而后又撤销了动作，而A往相同账户转入100元，就因为A读取到了B未提交更改数据，造成账户白白丢失500元。（注：在oracal数据库中，不会发生脏读的情况） B.2 不可重复读（unrepeatable read）不可重复读是指：A事物读取到B事物已提交的更改数据。假设A在取款事物过程中，B往账户转入100元，A两次读取到的余额不一致。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户余额为1000元 T4 查询账户余额位1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 查询账户余额900元（和T4查询不一致） 同一事务中两次查询账户余额不一致 B.3 幻读（phantom read）A事物读取B事物提交的新增数据，这时A事物将出现幻读 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 统计账户总存款为10000元 T4 新增一个存款账户，并转入100元 T5 提交事物 T6 再次统计存款为10100元（幻读） 如果新增数据刚好满足查询条件，这个数据就会进入事物的视野，因而产生两次统计结果不一致的情况 注：幻读和不可重复读的区别在于前者读取到的是已提交的新增数据，后者读取到的是已提交的更新数据（或者删除的数据）。为了避免这两种情况，采取的策略是不同的，防止读到更改操作，只需要对操作数据添加行级锁，阻止操作中的数据发生变化；而防止读到新增数据，则往往添加表级锁–将整张表锁定，防止新增数据（Oracal通过多版本数据的方式实现） B.4 第一类丢失更新A事物撤销时，覆盖掉 B事物已提交的更新数据。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 转入100元，修改余额为1100元 T6 提交事物 T7 取出100元，修改余额为900元 T8 撤销事物（或提交事物） T9 余额回复为1000元（丢失更新） A事物在撤销时，将B事物转入的100元抹去了 B.5 第二类丢失更新A事物覆盖B事物已提交的数据，造成B事物所有的操作丢失 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 转入100元 T8 提交事物 T9 修改余额为1100元（丢失更新） B.6 隔离级别为了解决上述的问题，提出了隔离级别的概念，不同的隔离级别可以处理的并发问题是不一样的。使用不同的隔离级别就可以阻止自己所期望的并发问题。 隔离级别 脏读 不可重复度 幻读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED √ √ √ × √ READ COMMITTED × √ √ √ √ REPREATABLE READ × × √ √ √ SERIALIZABLE × × × × × √ 表示可能出现的情况， × 号表示不会出现 SQL92推荐使用REPREATABLE READ，用户可自定义 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:2","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#b-并发问题"},{"categories":["program"],"content":" B 并发问题 B.1 脏读（dirty readA事物读取B事物尚未提交更改的数据，并在这个数据的基础上操作。如果B事物恰巧回滚，那么A事物读取到的事物是根本不被承认的。如下列： 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询余额1000元 T4 取出500元，余额改为500元 T5 查询余额500元（脏读） T6 撤销事物余额1000元 T7 汇入100元，余额改为600元 T8 提交事物 在这个场景中B希望取出500元，而后又撤销了动作，而A往相同账户转入100元，就因为A读取到了B未提交更改数据，造成账户白白丢失500元。（注：在oracal数据库中，不会发生脏读的情况） B.2 不可重复读（unrepeatable read）不可重复读是指：A事物读取到B事物已提交的更改数据。假设A在取款事物过程中，B往账户转入100元，A两次读取到的余额不一致。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户余额为1000元 T4 查询账户余额位1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 查询账户余额900元（和T4查询不一致） 同一事务中两次查询账户余额不一致 B.3 幻读（phantom read）A事物读取B事物提交的新增数据，这时A事物将出现幻读 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 统计账户总存款为10000元 T4 新增一个存款账户，并转入100元 T5 提交事物 T6 再次统计存款为10100元（幻读） 如果新增数据刚好满足查询条件，这个数据就会进入事物的视野，因而产生两次统计结果不一致的情况 注：幻读和不可重复读的区别在于前者读取到的是已提交的新增数据，后者读取到的是已提交的更新数据（或者删除的数据）。为了避免这两种情况，采取的策略是不同的，防止读到更改操作，只需要对操作数据添加行级锁，阻止操作中的数据发生变化；而防止读到新增数据，则往往添加表级锁–将整张表锁定，防止新增数据（Oracal通过多版本数据的方式实现） B.4 第一类丢失更新A事物撤销时，覆盖掉 B事物已提交的更新数据。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 转入100元，修改余额为1100元 T6 提交事物 T7 取出100元，修改余额为900元 T8 撤销事物（或提交事物） T9 余额回复为1000元（丢失更新） A事物在撤销时，将B事物转入的100元抹去了 B.5 第二类丢失更新A事物覆盖B事物已提交的数据，造成B事物所有的操作丢失 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 转入100元 T8 提交事物 T9 修改余额为1100元（丢失更新） B.6 隔离级别为了解决上述的问题，提出了隔离级别的概念，不同的隔离级别可以处理的并发问题是不一样的。使用不同的隔离级别就可以阻止自己所期望的并发问题。 隔离级别 脏读 不可重复度 幻读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED √ √ √ × √ READ COMMITTED × √ √ √ √ REPREATABLE READ × × √ √ √ SERIALIZABLE × × × × × √ 表示可能出现的情况， × 号表示不会出现 SQL92推荐使用REPREATABLE READ，用户可自定义 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:2","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#b1-脏读dirty-read"},{"categories":["program"],"content":" B 并发问题 B.1 脏读（dirty readA事物读取B事物尚未提交更改的数据，并在这个数据的基础上操作。如果B事物恰巧回滚，那么A事物读取到的事物是根本不被承认的。如下列： 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询余额1000元 T4 取出500元，余额改为500元 T5 查询余额500元（脏读） T6 撤销事物余额1000元 T7 汇入100元，余额改为600元 T8 提交事物 在这个场景中B希望取出500元，而后又撤销了动作，而A往相同账户转入100元，就因为A读取到了B未提交更改数据，造成账户白白丢失500元。（注：在oracal数据库中，不会发生脏读的情况） B.2 不可重复读（unrepeatable read）不可重复读是指：A事物读取到B事物已提交的更改数据。假设A在取款事物过程中，B往账户转入100元，A两次读取到的余额不一致。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户余额为1000元 T4 查询账户余额位1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 查询账户余额900元（和T4查询不一致） 同一事务中两次查询账户余额不一致 B.3 幻读（phantom read）A事物读取B事物提交的新增数据，这时A事物将出现幻读 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 统计账户总存款为10000元 T4 新增一个存款账户，并转入100元 T5 提交事物 T6 再次统计存款为10100元（幻读） 如果新增数据刚好满足查询条件，这个数据就会进入事物的视野，因而产生两次统计结果不一致的情况 注：幻读和不可重复读的区别在于前者读取到的是已提交的新增数据，后者读取到的是已提交的更新数据（或者删除的数据）。为了避免这两种情况，采取的策略是不同的，防止读到更改操作，只需要对操作数据添加行级锁，阻止操作中的数据发生变化；而防止读到新增数据，则往往添加表级锁–将整张表锁定，防止新增数据（Oracal通过多版本数据的方式实现） B.4 第一类丢失更新A事物撤销时，覆盖掉 B事物已提交的更新数据。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 转入100元，修改余额为1100元 T6 提交事物 T7 取出100元，修改余额为900元 T8 撤销事物（或提交事物） T9 余额回复为1000元（丢失更新） A事物在撤销时，将B事物转入的100元抹去了 B.5 第二类丢失更新A事物覆盖B事物已提交的数据，造成B事物所有的操作丢失 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 转入100元 T8 提交事物 T9 修改余额为1100元（丢失更新） B.6 隔离级别为了解决上述的问题，提出了隔离级别的概念，不同的隔离级别可以处理的并发问题是不一样的。使用不同的隔离级别就可以阻止自己所期望的并发问题。 隔离级别 脏读 不可重复度 幻读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED √ √ √ × √ READ COMMITTED × √ √ √ √ REPREATABLE READ × × √ √ √ SERIALIZABLE × × × × × √ 表示可能出现的情况， × 号表示不会出现 SQL92推荐使用REPREATABLE READ，用户可自定义 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:2","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#b2-不可重复读unrepeatable-read"},{"categories":["program"],"content":" B 并发问题 B.1 脏读（dirty readA事物读取B事物尚未提交更改的数据，并在这个数据的基础上操作。如果B事物恰巧回滚，那么A事物读取到的事物是根本不被承认的。如下列： 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询余额1000元 T4 取出500元，余额改为500元 T5 查询余额500元（脏读） T6 撤销事物余额1000元 T7 汇入100元，余额改为600元 T8 提交事物 在这个场景中B希望取出500元，而后又撤销了动作，而A往相同账户转入100元，就因为A读取到了B未提交更改数据，造成账户白白丢失500元。（注：在oracal数据库中，不会发生脏读的情况） B.2 不可重复读（unrepeatable read）不可重复读是指：A事物读取到B事物已提交的更改数据。假设A在取款事物过程中，B往账户转入100元，A两次读取到的余额不一致。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户余额为1000元 T4 查询账户余额位1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 查询账户余额900元（和T4查询不一致） 同一事务中两次查询账户余额不一致 B.3 幻读（phantom read）A事物读取B事物提交的新增数据，这时A事物将出现幻读 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 统计账户总存款为10000元 T4 新增一个存款账户，并转入100元 T5 提交事物 T6 再次统计存款为10100元（幻读） 如果新增数据刚好满足查询条件，这个数据就会进入事物的视野，因而产生两次统计结果不一致的情况 注：幻读和不可重复读的区别在于前者读取到的是已提交的新增数据，后者读取到的是已提交的更新数据（或者删除的数据）。为了避免这两种情况，采取的策略是不同的，防止读到更改操作，只需要对操作数据添加行级锁，阻止操作中的数据发生变化；而防止读到新增数据，则往往添加表级锁–将整张表锁定，防止新增数据（Oracal通过多版本数据的方式实现） B.4 第一类丢失更新A事物撤销时，覆盖掉 B事物已提交的更新数据。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 转入100元，修改余额为1100元 T6 提交事物 T7 取出100元，修改余额为900元 T8 撤销事物（或提交事物） T9 余额回复为1000元（丢失更新） A事物在撤销时，将B事物转入的100元抹去了 B.5 第二类丢失更新A事物覆盖B事物已提交的数据，造成B事物所有的操作丢失 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 转入100元 T8 提交事物 T9 修改余额为1100元（丢失更新） B.6 隔离级别为了解决上述的问题，提出了隔离级别的概念，不同的隔离级别可以处理的并发问题是不一样的。使用不同的隔离级别就可以阻止自己所期望的并发问题。 隔离级别 脏读 不可重复度 幻读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED √ √ √ × √ READ COMMITTED × √ √ √ √ REPREATABLE READ × × √ √ √ SERIALIZABLE × × × × × √ 表示可能出现的情况， × 号表示不会出现 SQL92推荐使用REPREATABLE READ，用户可自定义 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:2","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#b3-幻读phantom-read"},{"categories":["program"],"content":" B 并发问题 B.1 脏读（dirty readA事物读取B事物尚未提交更改的数据，并在这个数据的基础上操作。如果B事物恰巧回滚，那么A事物读取到的事物是根本不被承认的。如下列： 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询余额1000元 T4 取出500元，余额改为500元 T5 查询余额500元（脏读） T6 撤销事物余额1000元 T7 汇入100元，余额改为600元 T8 提交事物 在这个场景中B希望取出500元，而后又撤销了动作，而A往相同账户转入100元，就因为A读取到了B未提交更改数据，造成账户白白丢失500元。（注：在oracal数据库中，不会发生脏读的情况） B.2 不可重复读（unrepeatable read）不可重复读是指：A事物读取到B事物已提交的更改数据。假设A在取款事物过程中，B往账户转入100元，A两次读取到的余额不一致。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户余额为1000元 T4 查询账户余额位1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 查询账户余额900元（和T4查询不一致） 同一事务中两次查询账户余额不一致 B.3 幻读（phantom read）A事物读取B事物提交的新增数据，这时A事物将出现幻读 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 统计账户总存款为10000元 T4 新增一个存款账户，并转入100元 T5 提交事物 T6 再次统计存款为10100元（幻读） 如果新增数据刚好满足查询条件，这个数据就会进入事物的视野，因而产生两次统计结果不一致的情况 注：幻读和不可重复读的区别在于前者读取到的是已提交的新增数据，后者读取到的是已提交的更新数据（或者删除的数据）。为了避免这两种情况，采取的策略是不同的，防止读到更改操作，只需要对操作数据添加行级锁，阻止操作中的数据发生变化；而防止读到新增数据，则往往添加表级锁–将整张表锁定，防止新增数据（Oracal通过多版本数据的方式实现） B.4 第一类丢失更新A事物撤销时，覆盖掉 B事物已提交的更新数据。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 转入100元，修改余额为1100元 T6 提交事物 T7 取出100元，修改余额为900元 T8 撤销事物（或提交事物） T9 余额回复为1000元（丢失更新） A事物在撤销时，将B事物转入的100元抹去了 B.5 第二类丢失更新A事物覆盖B事物已提交的数据，造成B事物所有的操作丢失 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 转入100元 T8 提交事物 T9 修改余额为1100元（丢失更新） B.6 隔离级别为了解决上述的问题，提出了隔离级别的概念，不同的隔离级别可以处理的并发问题是不一样的。使用不同的隔离级别就可以阻止自己所期望的并发问题。 隔离级别 脏读 不可重复度 幻读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED √ √ √ × √ READ COMMITTED × √ √ √ √ REPREATABLE READ × × √ √ √ SERIALIZABLE × × × × × √ 表示可能出现的情况， × 号表示不会出现 SQL92推荐使用REPREATABLE READ，用户可自定义 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:2","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#b4-第一类丢失更新"},{"categories":["program"],"content":" B 并发问题 B.1 脏读（dirty readA事物读取B事物尚未提交更改的数据，并在这个数据的基础上操作。如果B事物恰巧回滚，那么A事物读取到的事物是根本不被承认的。如下列： 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询余额1000元 T4 取出500元，余额改为500元 T5 查询余额500元（脏读） T6 撤销事物余额1000元 T7 汇入100元，余额改为600元 T8 提交事物 在这个场景中B希望取出500元，而后又撤销了动作，而A往相同账户转入100元，就因为A读取到了B未提交更改数据，造成账户白白丢失500元。（注：在oracal数据库中，不会发生脏读的情况） B.2 不可重复读（unrepeatable read）不可重复读是指：A事物读取到B事物已提交的更改数据。假设A在取款事物过程中，B往账户转入100元，A两次读取到的余额不一致。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户余额为1000元 T4 查询账户余额位1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 查询账户余额900元（和T4查询不一致） 同一事务中两次查询账户余额不一致 B.3 幻读（phantom read）A事物读取B事物提交的新增数据，这时A事物将出现幻读 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 统计账户总存款为10000元 T4 新增一个存款账户，并转入100元 T5 提交事物 T6 再次统计存款为10100元（幻读） 如果新增数据刚好满足查询条件，这个数据就会进入事物的视野，因而产生两次统计结果不一致的情况 注：幻读和不可重复读的区别在于前者读取到的是已提交的新增数据，后者读取到的是已提交的更新数据（或者删除的数据）。为了避免这两种情况，采取的策略是不同的，防止读到更改操作，只需要对操作数据添加行级锁，阻止操作中的数据发生变化；而防止读到新增数据，则往往添加表级锁–将整张表锁定，防止新增数据（Oracal通过多版本数据的方式实现） B.4 第一类丢失更新A事物撤销时，覆盖掉 B事物已提交的更新数据。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 转入100元，修改余额为1100元 T6 提交事物 T7 取出100元，修改余额为900元 T8 撤销事物（或提交事物） T9 余额回复为1000元（丢失更新） A事物在撤销时，将B事物转入的100元抹去了 B.5 第二类丢失更新A事物覆盖B事物已提交的数据，造成B事物所有的操作丢失 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 转入100元 T8 提交事物 T9 修改余额为1100元（丢失更新） B.6 隔离级别为了解决上述的问题，提出了隔离级别的概念，不同的隔离级别可以处理的并发问题是不一样的。使用不同的隔离级别就可以阻止自己所期望的并发问题。 隔离级别 脏读 不可重复度 幻读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED √ √ √ × √ READ COMMITTED × √ √ √ √ REPREATABLE READ × × √ √ √ SERIALIZABLE × × × × × √ 表示可能出现的情况， × 号表示不会出现 SQL92推荐使用REPREATABLE READ，用户可自定义 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:2","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#b5-第二类丢失更新"},{"categories":["program"],"content":" B 并发问题 B.1 脏读（dirty readA事物读取B事物尚未提交更改的数据，并在这个数据的基础上操作。如果B事物恰巧回滚，那么A事物读取到的事物是根本不被承认的。如下列： 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询余额1000元 T4 取出500元，余额改为500元 T5 查询余额500元（脏读） T6 撤销事物余额1000元 T7 汇入100元，余额改为600元 T8 提交事物 在这个场景中B希望取出500元，而后又撤销了动作，而A往相同账户转入100元，就因为A读取到了B未提交更改数据，造成账户白白丢失500元。（注：在oracal数据库中，不会发生脏读的情况） B.2 不可重复读（unrepeatable read）不可重复读是指：A事物读取到B事物已提交的更改数据。假设A在取款事物过程中，B往账户转入100元，A两次读取到的余额不一致。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户余额为1000元 T4 查询账户余额位1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 查询账户余额900元（和T4查询不一致） 同一事务中两次查询账户余额不一致 B.3 幻读（phantom read）A事物读取B事物提交的新增数据，这时A事物将出现幻读 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 统计账户总存款为10000元 T4 新增一个存款账户，并转入100元 T5 提交事物 T6 再次统计存款为10100元（幻读） 如果新增数据刚好满足查询条件，这个数据就会进入事物的视野，因而产生两次统计结果不一致的情况 注：幻读和不可重复读的区别在于前者读取到的是已提交的新增数据，后者读取到的是已提交的更新数据（或者删除的数据）。为了避免这两种情况，采取的策略是不同的，防止读到更改操作，只需要对操作数据添加行级锁，阻止操作中的数据发生变化；而防止读到新增数据，则往往添加表级锁–将整张表锁定，防止新增数据（Oracal通过多版本数据的方式实现） B.4 第一类丢失更新A事物撤销时，覆盖掉 B事物已提交的更新数据。 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 转入100元，修改余额为1100元 T6 提交事物 T7 取出100元，修改余额为900元 T8 撤销事物（或提交事物） T9 余额回复为1000元（丢失更新） A事物在撤销时，将B事物转入的100元抹去了 B.5 第二类丢失更新A事物覆盖B事物已提交的数据，造成B事物所有的操作丢失 时间 事物A 事物B T1 开始事物 T2 开始事物 T3 查询账户为1000元 T4 查询账户为1000元 T5 取出100元，修改余额为900元 T6 提交事物 T7 转入100元 T8 提交事物 T9 修改余额为1100元（丢失更新） B.6 隔离级别为了解决上述的问题，提出了隔离级别的概念，不同的隔离级别可以处理的并发问题是不一样的。使用不同的隔离级别就可以阻止自己所期望的并发问题。 隔离级别 脏读 不可重复度 幻读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED √ √ √ × √ READ COMMITTED × √ √ √ √ REPREATABLE READ × × √ √ √ SERIALIZABLE × × × × × √ 表示可能出现的情况， × 号表示不会出现 SQL92推荐使用REPREATABLE READ，用户可自定义 ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:2","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#b6-隔离级别"},{"categories":["program"],"content":" C 使用libmysqlclient库g++ a.cpp -lmysqlclient -o a.out cpp //a.cpp 简单示例 #include \u003cstdio.h\u003e #include \u003cmysql/mysql.h\u003e MYSQL mysql,*sock; //连接要用到 int main(){ const char * host = \"127.0.0.1\"; //主机名 const char * user = \"root\"; const char * passwd = \"123456\"; const char * db = \"zsh\"; //数据库名字 unsigned int port = 3306; //不改动默认就是这个 const char * unix_socket = NULL; unsigned long client_flag = 0; //一般0 const char * i_query = \"select * from phonelist\"; //查询语句 int ret; MYSQL_RES * result; MYSQL_ROW row; mysql_init(\u0026mysql); //必须 if((sock = mysql_real_connect(\u0026mysql,host,user,passwd,db,port,unix_socket,client_flag)) == NULL){ ret = mysql_errno(\u0026mysql); printf(\"connect error,errno %d\\n\",ret); //fprintf(stderr,\"%s\\n\",mysql_error(\u0026mysql)); exit(1); }else{ fprintf(stderr,\"connect success\\n\"); } mysql_query(\u0026mysql,\"set names utf8\");//在连接后使用，中文显示正常 /* 这一句等于 SET character_set_client = utf8; SET character_set_results = utf8; SET character_set_connection = utf8; */ if(mysql_query(\u0026mysql,i_query) != 0){ fprintf(stderr,\"query error\\n\"); exit(1); }else{ if((result = mysql_store_result(\u0026mysql)) == NULL){ fprintf(stderr,\"save result error\\n\"); exit(1); }else{ int field_num = mysql_field_count(\u0026mysql); //获得列数 MYSQL_FIELD * fields = mysql_fetch_fields(result); //列名 for(int i=0; i\u003cfield_num; i++){ printf(\"%s \\t\",fields[i].name); }putchar('\\n'); while((row = mysql_fetch_row(result)) != NULL){ for(int i=0; i\u003cfield_num; i++){ printf(\"%s \\t\",row[i]); }putchar('\\n'); } } } mysql_free_result(result); mysql_close(sock); exit(EXIT_SUCCESS); } ","date":"2019-03-19","objectID":"/mysql-operation-manual/:6:3","series":null,"tags":["mysql"],"title":"MySQL操作手册(个人笔记)","uri":"/mysql-operation-manual/#c-使用libmysqlclient库"},{"categories":["algorithm"],"content":" 01背包有n种物品，一个承重量为m的背包，每种物品最多只能拿一个或者不拿，且每个物品都有价值v[i]和重量w[i]，问怎么拿使背包内物品价值最大。 定义dp[i][j]表示走到第i个物品，背包重量为j时的价值。 转移方程dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) dp[i-1][j]表示不拿当前物品，背包重量为j时的价值 dp[i-1][j-w[i]] + v[i]表示当前拿过后，背包重量为j时的价值 cpp for(int i=1; i\u003c=n; i++){ for(int j=0; j\u003c=m; j++){ if(j \u003e= w[i]){//当前承重量为j时能放进 dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]); }else dp[i][j] = dp[i-1][j]; } } } //dp[n][m]就是最大价值 可以发现处理第i个物品时,只需要知道i-1的状态就行了。 滚动数组优化： cpp for(int i=1; i\u003c=n; i++){ for(int j=m; j\u003e=w[i]; j--){//一定是从m到w[i],反了是完全背包了 dp[j] = max(dp[j], dp[j-w[i]] + v[i]); } } //dp[m]就是最大价值 注意for(int j=m; j\u003e=w[i]; j--)，一定是从大到小，容量大的状态需要通过容量小的状态转移过来。如果先更新容量小的状态，就会重复计算，变成完全背包。 ","date":"2019-01-21","objectID":"/knapsack/:1:0","series":null,"tags":["dp","algorithm"],"title":"背包问题","uri":"/knapsack/#01背包"},{"categories":["algorithm"],"content":" 完全背包只有一个条件跟01背包不一样，每种物品有无数个，随便拿。 转移方程dp[i][j] = max(dp[i-1][j-k*w[i]] + k*v[i]), 0 \u003c= k*w[i] \u003c= m 这里k就是拿的数量。 还是可以用滚动数组 cpp for(int i=1; i\u003c=n; i++){ for(int j=w[i]; j\u003c=m; j++){//从w[i]到m,跟01相反 dp[j] = max(dp[j], dp[j-w[i]] + v[i]); } } //dp[m]就是最大价值 先更新小的会影响大的，很巧妙的地方就是利用重复计算达到拿多个的目的。 ","date":"2019-01-21","objectID":"/knapsack/:2:0","series":null,"tags":["dp","algorithm"],"title":"背包问题","uri":"/knapsack/#完全背包"},{"categories":["algorithm"],"content":" 多重背包只是跟前两个背包条件不一样，现在每种物品有num[i]个 转移方程dp[i][j] = max(dp[i-1][j-k*w[i]] + k*v[i]), 0 \u003c= k \u003c= num[i] 且 k*w[i] \u003c= m 跟完全背包差不多。 使用滚动数组： cpp void _01(int w, int v, int m){//01背包, for(int i=m; i\u003e=w; i--){ dp[i] = max(dp[i], dp[i-w] + v); } } void _all(int w, int v, int m){//完全背包 for(int i=w; i\u003c=m; i++){ dp[i] = max(dp[i], dp[i-w] + v); } } //利用上面两个函数，多重背包如下 for(int i=1; i\u003c=n; i++){//遍历每种物品 if(num[i]*w[i] \u003e m){ //背包装不下所有当前物品，就可以看做完全背包 _all(w[i], v[i], m); }else{ //装的下就进行多次01背包 //如果num[i] = 10 //每次拿 1 2 4 3 个 //这里相当于拿了10轮，这么处理更快 int k=1; while(k\u003cnum[i]){ _01(k*w[i], k*v[i], m); num[i] -= k; k \u003c\u003c= 1; } _01(num[i]*w[i], num[i]*v[i], m); } } //dp[m]就是结果 ","date":"2019-01-21","objectID":"/knapsack/:3:0","series":null,"tags":["dp","algorithm"],"title":"背包问题","uri":"/knapsack/#多重背包"},{"categories":["algorithm"],"content":" 总结三种背包都不算难，不用滚动数组更好理解，不需要用滚动数组的时候直接套转移方程正常dp就行。 ","date":"2019-01-21","objectID":"/knapsack/:4:0","series":null,"tags":["dp","algorithm"],"title":"背包问题","uri":"/knapsack/#总结"},{"categories":["algorithm"],"content":"RMQ区间最值查询，对于长度为n的数组A[]。 RMQ(i,j)，返回数组A区间[i , j]内的最大值或最小值。 ","date":"2019-01-20","objectID":"/rmq/:0:0","series":null,"tags":["dp","algorithm"],"title":"RMQ区间最值查询","uri":"/rmq/#"},{"categories":["algorithm"],"content":" 思路：(线段树也是可以的 ST算法： O(nlogn)预处理，O(1)查询 定义dp[i][j]表示从第i个数起连续2^j个数中(即区间[i...i+2^j-1])的最值 如A={0,1,2,3},dp[0][1]=1,dp[0][2]=3.这里求最大值 初始化dp[i][0] = A[i] 转移方程：dp[i][j] = max(dp[i][j-1], dp[i+2^(j-1)][j-1]) 查询：如果查询区间[i,j]内的最值，先求区间长度为j-i+1 令k = log2(j-i+1)，则RMQ(i,j) = max(dp[i][k], dp[j-(2^k)+1][k]) cpp #include \u003ciostream\u003e using namespace std; namespace RMQ{ int *A; int dp[100][10];//第二维大小log2(n)就行 void init(int n){//数组长度 for(int i=0; i\u003cn; i++){ dp[i][0] = A[i]; } for(int j=1; (1\u003c\u003cj)\u003c=n; j++){ for(int i=0; i+(1\u003c\u003cj)-1\u003cn; i++){ dp[i][j] = max(dp[i][j-1], dp[i+(1\u003c\u003c(j-1))][j-1]); } } } int query(int l, int r){ int k=0; //k=log2(r-l+1) while((1\u003c\u003ck+1) \u003c= r-l+1) k++; return max(dp[l][k] ,dp[r-(1\u003c\u003ck)+1][k]); } } int main(){ int data[] = {3 ,2 ,4 ,5 ,6 ,8 ,1 ,2 ,9 ,7}; RMQ::A=data; RMQ::init(10); cout\u003c\u003cRMQ::query(0,9)\u003c\u003cendl;//3....7 -\u003e 9 cout\u003c\u003cRMQ::query(1,1)\u003c\u003cendl;//2 -\u003e 2 cout\u003c\u003cRMQ::query(4,6)\u003c\u003cendl;//6 8 1 -\u003e 8 return 0; } ","date":"2019-01-20","objectID":"/rmq/:1:0","series":null,"tags":["dp","algorithm"],"title":"RMQ区间最值查询","uri":"/rmq/#思路"},{"categories":["algorithm"],"content":" 例题POJ3264 题目大意： 第一行输入 n,q 表示一个长度为n的数列，q组询问 接下来n行 每行一个整数表示数列内容 接下来q行 每行一个l r 表示一个区间 输出每个区间内 最大值 减去 最小值 是多少 text Sample Input 1 7 3 4 2 5 1 5 4 6 2 2 Sample Output 6 3 0 ac代码 cpp #include \u003ciostream\u003e #include \u003cstdio.h\u003e using std::max; using std::min; namespace RMQ{ int *A; int dp[50000][32]; int dp2[50000][32]; void init(int n){//数组长度 for(int i=0; i\u003cn; i++){ dp[i][0] = A[i]; dp2[i][0] = A[i]; } for(int j=1; (1\u003c\u003cj)\u003c=n; j++){ for(int i=0; i+(1\u003c\u003cj)-1\u003cn; i++){ dp[i][j] = max(dp[i][j-1], dp[i+(1\u003c\u003c(j-1))][j-1]); dp2[i][j] = min(dp2[i][j-1], dp2[i+(1\u003c\u003c(j-1))][j-1]); } } } int query(int l, int r){ int k=0; //k=log2(r-l+1) while((1\u003c\u003ck+1) \u003c= r-l+1) k++; return max(dp[l][k] ,dp[r-(1\u003c\u003ck)+1][k])-min(dp2[l][k] ,dp2[r-(1\u003c\u003ck)+1][k]); } } int data[50000]; int main(){ int n,q; scanf(\"%d %d\",\u0026n,\u0026q); for(int i=0;i\u003cn;++i){ scanf(\"%d\",\u0026data[i]); } RMQ::A=data; RMQ::init(n); int l,r; while(q--){ scanf(\"%d %d\",\u0026l,\u0026r); printf(\"%d\\n\",RMQ::query(l-1,r-1)); } return 0; } ","date":"2019-01-20","objectID":"/rmq/:2:0","series":null,"tags":["dp","algorithm"],"title":"RMQ区间最值查询","uri":"/rmq/#例题"},{"categories":["algorithm"],"content":" 求模式串在目标串中出现的次数和位置","date":"2019-01-17","objectID":"/kmp/:1:0","series":null,"tags":["pattern-matching","algorithm"],"title":"kmp","uri":"/kmp/#求模式串在目标串中出现的次数和位置"},{"categories":["algorithm"],"content":" next数组的一些性质KMP最小循环节、循环周期： 定理：假设S的长度为len则S存在最小循环节，对S构造next数组，循环节的长度L为len-next[len]，子串为S[0…len-next[len]-1]。 （1）如果len可以被len - next[len]整除，则表明字符串S可以完全由循环节循环组成，循环周期T = len/L。 （2）如果不能，说明还需要再添加几个字母才能补全。需要补的个数是循环个数L-len%L = L-(len-L)%L = L-next[len]%L，L = len-next[len]。 ","date":"2019-01-17","objectID":"/kmp/:1:1","series":null,"tags":["pattern-matching","algorithm"],"title":"kmp","uri":"/kmp/#next数组的一些性质"},{"categories":["algorithm"],"content":" 代码 cpp namespace KMP{ int next[10010]; // 处理模式串的next数组,x[i-next[i]...i-1] == x[0....next[i]-1] void kmp_pre(char x[], int m, int _next[]){ int i, j; j = _next[0] = -1; i = 0; while(i \u003c m){ while(-1 != j \u0026\u0026 x[i] != x[j]) j = _next[j]; _next[++i] = ++j; } } // 改进next数组,减少回溯次数，但不能使用next的性质 void kmp_pre_2(char x[], int m, int fast_next[]){ int i, j; j = fast_next[0] = -1; i = 0; while(i \u003c m){ while(-1 != j \u0026\u0026 x[i] != x[j]) j = fast_next[j]; if(x[++i] == x[++j]) fast_next[i] = fast_next[j]; else fast_next[i] = j; } } //模式匹配,返回出现次数，x模式串，y主串 int kmp(char x[], int m, char y[], int n){ int i, j; int ans = 0; kmp_pre(x, m, next); //kmp_pre_2(x, m, next); i = j = 0; while(i \u003c n){ while(-1 !=j \u0026\u0026 y[i] != x[j]) j = next[j]; i++; j++; if(j \u003e= m){ ans++; //i-m即为模式串在主串中的开始位置 j = next[j]; } } return ans; } } ","date":"2019-01-17","objectID":"/kmp/:2:0","series":null,"tags":["pattern-matching","algorithm"],"title":"kmp","uri":"/kmp/#代码"},{"categories":["algorithm"],"content":" 例题hdu3336 next数组+dp 大意：给你个字符串如abab，它的子串a，ab，aba，abab出现次数 即2+2+1+1=6 dp[i]表示以第i个字符结尾的子串出现次数 dp[i] = dp[next[i]] + 1 对于abab，next[]={-1,0,0,1,2} 当i=1时，表示子串a，dp[1] = dp[next[1]] + 1 = dp[0] + 1 = 1，‘a’ 当i=2时，表示子串ab，dp[2] = dp[next[2]] + 1 = dp[0] + 1 = 1，‘ab’ 当i=3时，表示子串aba，dp[3] = dp[next[3]] + 1 = dp[1] + 1 = 2，‘a’,‘aba’ 当i=4时，表示子串abab，dp[4] = dp[next[4]] + 1 = dp[2] + 1 = 2，‘ab’,‘abab’ 以a结尾的有’a’,‘a’,‘aba’; 以b结尾的有’ab’,‘ab’,‘abab’; cpp #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #define mem(x,y) memset(x,y,sizeof(x)) const int mod = 10007; namespace KMP{ int next[200001]; // 处理模式串的next数组,x[i-next[i]...i-1] == x[0....next[i]-1] void kmp_pre(char x[], int m, int _next[]){ int i, j; j = _next[0] = -1; i = 0; while(i \u003c m){ while(-1 != j \u0026\u0026 x[i] != x[j]) j = _next[j]; _next[++i] = ++j; } } } int t,n;//200000 char str[200001]; int dp[200001]; int main(){ scanf(\"%d\",\u0026t); while(t--){ mem(KMP::next,0); scanf(\"%d\",\u0026n); scanf(\"%s\",str); KMP::kmp_pre(str,n,KMP::next); int ans=0; mem(dp,0); for(int i=1;i\u003c=n;i++){ dp[i] = (dp[KMP::next[i]]+1)%mod; ans = (ans + dp[i])%mod; } printf(\"%d\\n\",ans ); } return 0; } ","date":"2019-01-17","objectID":"/kmp/:3:0","series":null,"tags":["pattern-matching","algorithm"],"title":"kmp","uri":"/kmp/#例题"},{"categories":["algorithm"],"content":"回文串是指是正着读和反着读都一样的字符串，比如abcba。 最长回文子串是指在一个字符串中能找到的最长回文串，如这个字符串最长回文字串是最后6个字符：abacacbaaaab 用马拉车算法求一个串中的最长回文子串： 首先将字符串长度处理成奇数，如\"abbc\"处理成\"$a#b#b#c#\"。 然后从左到右边遍历求出以每个字符为中心的回文半径Mp, 其中最大的那个回文半径就对应着最长的回文子串。 ","date":"2019-01-17","objectID":"/manacher/:0:0","series":null,"tags":["algorithm"],"title":"最长回文子串-马拉车","uri":"/manacher/#"},{"categories":["algorithm"],"content":" Manacher算法实现如下： 图中id表示如果以这个下标为中心，回文半径最远可以到达的位置是mx（这表示区间(id,mx]与[mx\",id)是对称的, id位置就是对称轴）。 马拉车的思想是利用左边已经求出的回文半径，帮助计算右边的回文半径。如果我们要求下标i的回文半径，那么： 2*id-i 指的就是是下标i关于id的对称位置i\",(i肯定在id的右边,因为是从左往右遍历处理) 计算回文半径Mp[i]: 如果mx\u003ei(图1,2)，即id处的回文半径能够覆盖当前位置，那么i关于id的对称位置i\"一定也在以id为中心的回文串中。 i\"位于id左边，所以i\"的结果前面已经算出来了，直接得出i\"的回文半径就是Mp[i\"] = Mp[2*id-i]。 （图里左边的红色部分就是回文半径为Mp[i\"]的回文串，右边是对称的部分） 这时候计算i的回文半径还分两种情况: mx-i \u003e Mp[2*id-i] mx-i \u003c Mp[2*id-i] 分别对应图1、2。Mp[i]的值选取两者中较小的那一个。 因为图中只有同时被红色和绿色覆盖的，才关于i对称，其他的未知。 如果，mx \u003c= i(图3)，那么i的回文半径只能通过一次次比较求得。 细节见代码，返回值是最长回文串长度。 cpp namespace Manacher{ const int MAXN = 100;//字符串最大长度 char Ma[MAXN*2];//处理后的字符串 int Mp[MAXN*2];//每个位置的回文半径,max(Mp[i])-1就是最长回文长度 int Manacher(const char s[], int len){ int l = 0, ret = 0; Ma[l++] = '$'; Ma[l++] = '#'; for(int i = 0; i\u003clen; i++){ Ma[l++] = s[i]; Ma[l++] = '#'; } Ma[l] = 0; int mx = 0, id = 0; //从id处回文半径可以达到mx处 for(int i = 0; i \u003c l; i++){ Mp[i] = mx \u003e i ? min(Mp[2*id-i], mx - i) : 1; while(Ma[i + Mp[i]] == Ma[i - Mp[i]]) Mp[i]++; ret = max(Mp[i]-1,ret); if(i + Mp[i] \u003e mx){ mx = i + Mp[i]; id = i; } } return ret; } } ","date":"2019-01-17","objectID":"/manacher/:1:0","series":null,"tags":["algorithm"],"title":"最长回文子串-马拉车","uri":"/manacher/#manacher"},{"categories":["algorithm"],"content":" 例题POJ3974 裸题 ","date":"2019-01-17","objectID":"/manacher/:2:0","series":null,"tags":["algorithm"],"title":"最长回文子串-马拉车","uri":"/manacher/#例题"},{"categories":["algorithm"],"content":"哈尔滨理工大学软件与微电子学院第八届程序设计竞赛同步赛（高年级） 小乐乐搭积木 链接：https://ac.nowcoder.com/acm/contest/301/B 来源：牛客网 ","date":"2018-12-06","objectID":"/contour-dp/:0:0","series":null,"tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/#"},{"categories":["algorithm"],"content":" 题目描述 小乐乐想要给自己搭建一个积木城堡。 积木城堡我们假设为n*m的平面矩形。 小乐乐现在手里有 1*2，2*1两种地砖。 小乐乐想知道自己有多少种组合方案。 ","date":"2018-12-06","objectID":"/contour-dp/:1:0","series":null,"tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/#题目描述"},{"categories":["algorithm"],"content":" 输入描述: 第一行输入整数 n,m。(1\u003c=n,m\u003c=10) ","date":"2018-12-06","objectID":"/contour-dp/:2:0","series":null,"tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/#输入描述"},{"categories":["algorithm"],"content":" 输出描述: 输出组合方案数。 ","date":"2018-12-06","objectID":"/contour-dp/:3:0","series":null,"tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/#输出描述"},{"categories":["algorithm"],"content":" 示例输入 2 3 输出 3 ","date":"2018-12-06","objectID":"/contour-dp/:4:0","series":null,"tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/#示例"},{"categories":["algorithm"],"content":" ac代码 cpp #include \u003ciostream\u003e #include \u003cstring.h\u003e using namespace std; int n,m; int dp[2][(1\u003c\u003c11)],cur,mask; //mask 掩码 void update(int a,int b){ dp[cur][b] += dp[cur^1][a]; //更新状态方案数 } int main(){ cin\u003e\u003en\u003e\u003em; mask = (1\u003c\u003cm)-1; //设置掩码 memset(dp,0,sizeof(dp)); cur = 0; //滚动数组 dp[cur][(1\u003c\u003cm)-1] = 1; //初始化 for(int i = 0;i \u003c n;i++){ for(int j = 0;j \u003c m;j++){//当前处理位置(i,j) cur ^= 1; memset(dp[cur],0,sizeof(dp[cur])); for(int k = 0;k \u003c (1\u003c\u003cm);k++){//枚举当前状态 //当前和上都放 上有空位就不能往左，也不能不放 if(i \u0026\u0026 !(k\u0026(1\u003c\u003c(m-1))))//不是第一行，且正上方为空 { update(k,((k\u003c\u003c1)^1)\u0026mask);//新状态尾部置1 }else { //当前和左放 if(j \u0026\u0026 (!(k\u00261)))//不是第一列并且左边为空 update(k,((k\u003c\u003c1)^3)\u0026mask);//新状态尾两个11 //不放 update(k,(k\u003c\u003c1)\u0026mask); //掩码是只取低m位作为状态 } } } } cout\u003c\u003cdp[cur][(1\u003c\u003cm)-1]\u003c\u003cendl; return 0; } ","date":"2018-12-06","objectID":"/contour-dp/:5:0","series":null,"tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/#ac代码"},{"categories":["algorithm"],"content":" 思路轮廓线dp，状压 在这道题中，假设我们有一个 5*5 的格子要填充(如图)，黑色部分不是格子的一部分，只是作为虚拟出来的\"顶\"。 图1中蓝色部分表示已经填充好的部分；黄色部分是状态压缩表示的状态，已经填充为1，没有为0；红色表示当前处理的位置。 图2中我们用状态01111表示当前的\"轮廓\"。这个状态的\"头\"总是在\"当前\"的上面，这个状态的\"尾\"大部分时候在\"当前\"的左边(图4的情况不是)。 图3中，我们\"当前\"的处理方式只能是填充\"当前\"和\"头\"(竖着放)，因为如果我们不这样，上方的空位就无法被填充，会被忽略过去。 图4中，“当前\"的左边没有格子，而且上方是0，不可能往左放，只能往上放(竖着放)。处理过之后就变成下面的新状态了。 图5中，有两种选择，往左放或者不放。 特别的，如何初始化？ 处理第一行的时候，假设上面还有一层，并且都填充了(就是图中黑色部分)，这样就可以像其他位置一样处理。 怎么记录方案数？ 每一个状态都是由另一个状态得到的，状态1 —\u003e状态2 ; 状态3 —\u003e 状态2; 可能很多状态都能到状态2，那么状态2的方案数就是： 状态1方案数 + 状态2方案数 + … 设dp[cur][state]表示cur(当前)位置为state状态的方案数。last为上一个位置。 设 k 表示处理当前位置前的状态(轮廓)，new为处理当前位置后的状态(轮廓) 转移方程有 cpp dp[cur][new] += dp[last][k]; 我先去上课 。。。。 具体实现可以看代码。 需要注意的几点： 初始化是当上面有一行不存在的，已经填充好的一行 dp[cur][(1\u003c\u003cm)-1] = 1 cur ^= 1 是滚动数组的操作，因为当前位置状态只和它之前位置状态有关 任何时候，上方有空位就不能选择左或者不填。 ","date":"2018-12-06","objectID":"/contour-dp/:6:0","series":null,"tags":["algorithm","dp"],"title":"轮廓线dp","uri":"/contour-dp/#思路"},{"categories":["program"],"content":"记录cpp中大部分的知识点，个人理解有限，不一定都正确。 ","date":"2017-12-23","objectID":"/cpp-note/:0:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#"},{"categories":["program"],"content":" 2.2 cout控制输出长度/格式： cpp cout\u003c\u003csetw(8)\u003c\u003ca\u003c\u003cendl; //setw()在头文件\u003ciomanip\u003e中，只能右对齐，等价%8d cout\u003c\u003csetiosflags(ios::left)\u003c\u003csetw(8)\u003c\u003ca\u003c\u003cendl;//这样为左对齐 cout\u003c\u003csetw(8)\u003c\u003csetprecision(2)\u003c\u003csetiosflags(ios::fixed)\u003c\u003cb\u003c\u003cendl;//b是一个浮点数，等价于%8.2f cout\u003c\u003csetfill('x')\u003c\u003cset(8)\u003c\u003ca\u003c\u003cendl;//将空白用x填充 cout\u003c\u003chex\u003c\u003ca\u003c\u003cendl;//等价于printf(\"%x\\n\",a);十六进制 cout\u003c\u003coct\u003c\u003ca\u003c\u003cendl;//等价于printf(\"%o\\n\",a);八进制 cout\u003c\u003ca\u003c\u003cendl;//等价于printf(\"%d\\n\",a);十进制 ","date":"2017-12-23","objectID":"/cpp-note/:1:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#22-cout控制输出长度格式"},{"categories":["program"],"content":" 2.3 函数重载（静多态）匹配原则 严格匹配 隐式转换（小到大可以，大到小不可以）寻求匹配，找到则匹配 返回值不构成重载 cpp extern \"C\"{} //将括号内按c的方式编译，不与其他同名函数重载。c库每一个头文件都有 //--------------------------------------------------------- #ifdef __cplusplus//如果是c++编译器 extern \"c\"{ #endif // __cplusplus // 内容 #ifdef __cplusplus } #endif //表示不使用c++的重载特性 //---------------------------------------------------------- ","date":"2017-12-23","objectID":"/cpp-note/:2:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#23-函数重载静多态"},{"categories":["program"],"content":" 2.4 运算符重载Operator Overload cpp //运算符其实就是函数 struct zuobiao //坐标 { int x;int y; }; zuobiao operator + (zuobiao a,zuobiao b) { zuobiao c; c.x=a.x+b.x; c.y=a.y+b.y; return c; } ","date":"2017-12-23","objectID":"/cpp-note/:3:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#24-运算符重载operator-overload"},{"categories":["program"],"content":" 2.5 默认参数Default Parameters参数只能从右往左默认，中间不能跳跃 ","date":"2017-12-23","objectID":"/cpp-note/:4:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#25-默认参数default-parameters"},{"categories":["program"],"content":" 2.6 引用Raference\u0026前为类型名时为引用，其他均为取地址 变量名，本身是一段内存的引用，即别名（alias）。此处引入的引用是为已有变量起一个别名，声明如下 cpp int a; int \u0026ra=a; //1. 引用是一种声明关系，必须初始化，引用不开辟空间 //2. 此种声明关系一经声明 不可变更 int \u0026rr=ra; //3. 可以对引用，再次引用。多次引用的结果，多个引用指向同一个变量 //引用的本质是对指针的包装，指针可以有引用，但不应该有引用的指针 //const int\u0026ra=a; 能用const就用；use const whatever possible //思考：引用的本质是什么？ int \u0026 ra = a； int * const p = \u0026a; 引用的本质是不可以修改指向的指针； ","date":"2017-12-23","objectID":"/cpp-note/:5:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#26-引用raference"},{"categories":["program"],"content":" 2.7 new/delete(申请动态内存) cpp int *p = new int(200); //开一个int类型单变量并初始化为200 int *ps = new string(\"hellwo world\");//开一个string类型单变量并初始化为 hellow world int *p1 = new int[5]{0};//开一个int数组 每一项初始化为0； int **pp = new int*[5];//指针数组，存放的指针 int (*p)[4] = new int[3][4] {{0}};//p是一个指针 它指向包含4个int元素的一维数组 p为首地址 记不住怎么写编译器可以给你提示 //也可以new一个结构体 但初始化应用 {} 因为可能有有多个值 /*应用程序在内存中分为 代码区、 全局(静态)数据存储区、 栈区、 堆区。 通过new出来的内存在堆区。 局部变量，函数参数等存在栈区 */ int *p = new int ; delete p; int *p=new int[5]; delete []p; int (*p)[4][3]=new int[5][4][3]; delete []p; //异常处理 new很少出错 一般别用 int *p = new(std::nothrow) int ; if(p == nullptr){return -1}//NULL 好像变成nullptr了c++11 ","date":"2017-12-23","objectID":"/cpp-note/:6:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#27-newdelete申请动态内存"},{"categories":["program"],"content":" 2.8 内联函数 cpp inline int sqr(int i) { return i*i; }//inline 是给编译器的一种建议，编译器来决定是否inline，但你不说编译器一定不inline 66666 //适用环境 函数体很小 且 频繁使用 ","date":"2017-12-23","objectID":"/cpp-note/:7:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#28-内联函数"},{"categories":["program"],"content":" 2.9 cast强制类型转换 cpp int a=5; float b=6.5; static_cast //对于隐式类型可以转化的，可用这个 b=static_cast\u003cfloat\u003e(a); //作者不想让你强转，所以搞这么麻烦 哈啊哈 void *p;int *q; p=q;//可以 q=p;//不可以 q=static_cast\u003cint*\u003e(p);OK dynamic_cast reinterpret_cast //对于无隐式类型的转化，static_cast无效，例如将int赋值给int*指针 reinterpert重新解释 const_cast //脱常 只能用于指针和引用 void fun1(int \u0026 v) { cout\u003c\u003cv\u003c\u003cendl; } int main() { const int a; fun1(a); //这是传不进去的 fun1(const_cast\u003cint \u0026\u003e(a));//这样就传进去了 不要妄图用这个方法修改const 其行为是未定义的且没有意义 return 0; } ","date":"2017-12-23","objectID":"/cpp-note/:8:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#29-cast强制类型转换"},{"categories":["program"],"content":" 2.10 const cpp #define N 200 //宏，在预处理阶段发生了替换 const int n = 200; //在编译阶段发生了替换 //所以const永远不会发生改变 ","date":"2017-12-23","objectID":"/cpp-note/:9:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#210-const"},{"categories":["program"],"content":" 2.11 命名空间Namespace cpp int v=55; main() { int v=5; cout\u003c\u003cv\u003c\u003cendl;//打印局部变量 cout\u003c\u003c::v\u003c\u003cendl;//打印全局变量 }//全局命名空间其实是一个没有名字的命名空间，也可以用::作用域运算符访问。 namespace //是对全局命名空间的再次划分 namespace name//协同开发 可以在不同文件中定义同名空间，将自动合并 { int x; void func() { printf(\"haha\"); } struct xy { int x;int y; }; //可以写很多，包括再写一个命名空间 } ","date":"2017-12-23","objectID":"/cpp-note/:10:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#211-命名空间namespace"},{"categories":["program"],"content":" 2.12 字符串类型string cpp //位于命名空间std；它是一个类不是关键字 //用cin输入时有空格会结束，但输出时字符串里可以有空格 string str=\"china\"，s2=\"0\"; cout\u003c\u003cstr.size()\u003c\u003cenld; //获得长度 char buf[100]; strcpy(buf,str.c_str());//strcpy位于string.h str.c_str()对象函数返回一个c语言类型的字符串，以兼容c cout\u003c\u003cbuf\u003c\u003cendl; str.swap(s2);//用对象方法交换 int n=str.find('a',0);//查找a，返回下标，第二个参数为从0开始，找不到返回-1 int n=str.find(\"in\",0);//查找字串,有返回首下标，没有返回-( //删空格 string ss=\" sdfsdfs \"; ss.erase(0,ss.find_first_not_of(' '));//从0删到第一个不是空格，参数一从什么地方删，参数二删几个 ss.erase(ss.find_last_not_of(' ')+1);//从最后一个不是空格删到最后 ","date":"2017-12-23","objectID":"/cpp-note/:11:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#212-字符串类型string"},{"categories":["program"],"content":" 3.1 封装Encapsulation cpp //c语言的封装风格，数据放在一起打包为struck，然后吧数据以引用或指针的方式传递给行为。 struct date { int year; int month; int day; }; void init(date \u0026 d) { cin\u003e\u003ed.year; cin\u003e\u003ed.month; cin\u003e\u003ed.day; } //c++认为c封装不彻底，1数据和行为分离，2没有权限控制。 //权限控制 private protected public class date2 { private: int year; int month; int day; public: viod print() { cout\u003c\u003cyear\u003c\u003cendl; } }; //类名也是一种特别的名称空间 ","date":"2017-12-23","objectID":"/cpp-note/:12:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#31-封装encapsulation"},{"categories":["program"],"content":" 3.2 类的构造器constructor cpp //constructor 构造器 //1.与类名相同，无返回值，生成对象时自动调用，用于初始化 //2.可以有参数，可以重载，默认参数 class sss { public: sss() { cout\u003c\u003c\"我是构造器\"\u003c\u003cendl; } sss(int i) { cout\u003c\u003ci; } }; sss s(100);//使用构造器的重载， 创建对象时加参数 ","date":"2017-12-23","objectID":"/cpp-note/:13:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#32-类的构造器constructor"},{"categories":["program"],"content":" 3.2.2 类的析构器destructor cpp //1.~类名（）无参无反，对象销毁时的内存处理工作 class sss { public: ~ksss() { cout\u003c\u003c\"我是析构器\"\u003c\u003cendl; } }; ","date":"2017-12-23","objectID":"/cpp-note/:14:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#322-类的析构器destructor"},{"categories":["program"],"content":" 4.1 自实现string cpp //代码in坚果云 class A { public: A(int i=0;int j=0;int k=0)//参数列表，效率高，在函数声明之后，实现体之前，：开头 :x(i),y(j),z(k)//初始化顺序，跟变量的声明顺序有关，初始化列表中的顺序无关，即xyz顺序可变 { } private: int x,y,z; }; //拷贝构造器 //由已存在的对象，创建新对象，也就是所新对象不是由构造器来构造，而是由 //拷贝构造器来完成，拷贝构造器的格式是固定的 class A { A(const A \u0026 another)//\u0026是引用 }; //若不提供，系统提供默认，自定义是系统不再提供默认 //系统提供的默认是一种等位拷贝，浅浅的拷贝，会导致内存重析构。doble free //含有堆空间时要自实现拷贝 //友元 同类对象无私处，异类对象有友元 //运算符重载 //赋值运算符重载 string s4=s3;//本质不是赋值，而是拷贝构造，在声明时候=号表示初始化 //this指针 //系统创建对象时，默认生成当前对象的this指针。 //对对象来说，传引用效率很高，不然调用拷贝构造效率低。 //栈上的对象可以返回，但不能返回栈上的引用（除非实例不会销毁，比如对象方法返回自己，结束后对象还在，引用有效） A \u0026 func(){//这是错的，func执行完b会销毁，但这个回传的引用仍指向这个地址 A b; return b; } ","date":"2017-12-23","objectID":"/cpp-note/:15:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#41-自实现string"},{"categories":["program"],"content":" 5.1 const static 修饰类static 在c中，修饰全部变量表示吧作用于限制在本文件内 修饰局部变量表示吧变量生命周期提升为全局 c++中在类内部，用来实现族类对象间的数据共享。 c++中，修饰类成员时，表示这个成员变量属于整个类，而不是某个对象（既属于类，也属于对象，但终归于类） cpp static int a;//声明写在类内 int A::a=0;//初始化写在内外 修饰成员函数时，也属于整个类；因为他属于类，没有this指针（this只有对象实例有） cpp //不能访问数据成员及成员，没有this static string getstr(); const static int h=0; //static const 修饰数据成员，必须在类内初始化；就地初始化 const 修饰数据成员，初始化位置只能在 参数列表里；（新版本虽然可以直接等于号初始化，但别被惯傻了） 修饰成员函数（注意不是修饰返回类型），位置放在声明之后，实现体之前，大概也没有别的地方可以放了（haha） const函数承诺不会修改数据成员，也只能调用其他const函数。 还可以构成重载（wtf？） 修饰类对象，从对象层面不修改成员，只能调用const成员函数，构成重载就是配饰有无const的对象的情况 即const对象只能调用const成员函数，非const对象优先调用非const成员函数（若无则调用const成员函数） ","date":"2017-12-23","objectID":"/cpp-note/:16:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#51-const-static-修饰类"},{"categories":["program"],"content":" 5.2 指向类成员的指针 cpp //都指向非静态成员 \"成员类型 类名::* 指针名 = \u0026类名::成员名\" class stuu { void print(); private: int a; }; //指向数据成员 //在定义时必须和类关联，使用时必须和对象关联 int stuu::* pa=\u0026stuu::a; stuu dx; cout\u003c\u003cdx.*pa\u003c\u003cendl; //(内部实现，实际上时记录了偏移量) //指向函数成员 // void (stuu::*pf)()=\u0026stuu::print; (dx.*pf)(); tip://在类中想用常量时 enum{cnt=4};//因为用const必须参数列表初始化，static const 太浪费 ","date":"2017-12-23","objectID":"/cpp-note/:17:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#52-指向类成员的指针"},{"categories":["program"],"content":" 5.3 友元 友元可以是友元函数，友元类，异类才有友元（同类无私处） 友元是单方面的，你拿我当朋友不等于我也拿你当朋友(涩会涩会) 访问时必须通过 cpp class A { friend void dis(A \u0026 t); friend class B; }; // 该函数可以访问A的私有成员 void dis(A \u0026 t);//访问时必须通过对象访问，因为他不是成员函数 // 该类可以访问A的私有成员 class B{void dis(A \u0026 t);}; ","date":"2017-12-23","objectID":"/cpp-note/:18:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#53-友元"},{"categories":["program"],"content":" 5.4 单双目运算符重载 cpp //不能重载的运算符 . .* :: ?: sizeof //sizeof是运算符，不是函数 //除了=号外，基类中被重载的操作符都将被派生类继承 //“赋值运算符重载函数”不是不能被派生类继承，而是被派生类的默认“赋值运算符重载函数”给shadow了 //通常情况下，双目运算符重载为成员需要一个参数，重载为友元要两个参数，做成员时this也是参数 //重载-（负号）时用const修饰成员函数，-c=t就不会过编译了，这才是对的，注意-(-c)所以只能用const修饰成员函数而不是返回值。 // Clock operator++(Clock\u0026 c) //前置单目运算符 ++c Clock operator++(Clock\u0026 c,int) //后置单目运算符 c++ //day 6.2 //流输入输出运算符重载 istream \u0026 operator\u003e\u003e(istream\u0026,自定义类\u0026); ostream \u0026 operator\u003c\u003c(istream\u0026,const 自定义类\u0026); ","date":"2017-12-23","objectID":"/cpp-note/:19:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#54-单双目运算符重载"},{"categories":["program"],"content":" 5.5 类型转化 使用 类型转化构造器 cpp //实现 其他类型 到 本类型 的转化 class 本类型 { 本类型(const 其他类型 \u0026 Ta) //这是一个构造器 [ //实现转化 //this-\u003edata = Ta.data ; ] }; 本类型 = 其他类型; //隐式转化可用 先调用类型转化，在调用赋值运算符重载 //我们把只有一个参数的构造器成为类型转化构造器 explicit //加在转化构造器前表示只能使用 显式转化 本类型 = static_cast\u003c本类型\u003e(其他类型); 使用 类型转换操作符函数 cpp class 源类 { //无参无返回 operator 目标类型(void) { //根据需要进行转化 //目类标型.data = this-\u003edata; return 目标类型(this-\u003edata2,this.data2);//特殊，里面有返回, //实际也可以这么写 目标类型 swa; swa.data1 = this-\u003edata1; return swa; } }; ","date":"2017-12-23","objectID":"/cpp-note/:20:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#55-类型转化"},{"categories":["program"],"content":" 5.6 运算符重载提高篇 函数操作符()重载 – 仿函数 cpp //把类对象当作函数名使用，主要应与于STL和模板 class 类名 { 返回值类型 operator() (参数类型) { } }; //lambda 本质就是仿函数 operator bool();//对象可以对void * 重载,if(A)情况，会调用bool(); operator void *();//对象可以对void * 重载，if(A)情况，没有bool()会调用void*(),然后void*被强转成bool; 重载 new delete new[] delete[] cpp //定制化时使用，给特定类定制 void * operator new(size_t) void operator delete(void *) void * operator new[](size_t) void operator delete[](void *) //注：operator new 中 size_t 参数是编译器自动计算传递的 其实是 unsigned int //了解一下就行↓ #include \u003cmemory\u003e class A{int a;}; auto_ptr\u003cA\u003e ptr(new A); //auto_ptr 类模板 auto_ptr\u003cA\u003e模板类 ptr-\u003ea=1; //一个对象的行为想指针，重载了 -\u003e () * //new被ptr托管后，不需要再关心delete的问题 ","date":"2017-12-23","objectID":"/cpp-note/:21:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#56-运算符重载提高篇"},{"categories":["program"],"content":" 6.1 继承与派生Inherit\u0026Derive c++ 通过继承关系实现了代码的可重用性。 cpp class 派生类名:继承方式 基类名 { }; //一个派生类可以有多个基类 //继承方式 public protected private /* 父类 公有继承 保护继承 私有继承 成员属性↘ public public protected private protected protected protected private private 不可访问 不可访问 不可访问（inaccessable） */ protected 对于外界访问属性来说等同于 private，但在派生类中可见 几点说明: * 可见不可见都全盘接收，除了构造器与析构器，基类可能会造成派生类的成员冗余，是需要设计的 * 派生类有了自己的个性，才有意义 派生类的构造器 cpp 类名(参数总列表) :父类名(父类构造器列表),自己的成员 { //在参数列表里调用父类构造器，然后再初始化自己的成员 //在父类中如果有标配，重载或默认，把无参的情况包含进来，子类可以不显式的调用父类构造器，隐式调用 } //初始化顺序，父类，其他类对象成员，本类的初始化 派生类的拷贝构造器 cpp //子类未实现拷贝时，会调用父类构造器 //子类一旦实现拷贝构造，则必须显式的调用父类拷贝构造器 son(const son \u0026 another) :father(another) { // ↑↑↑赋值兼容（子类对象(引用或指针)可以赋给父类对象） this-\u003edata=another.data; } 派生类赋值重载 cpp //子类中未实现赋值重载时，会调用父类的赋值重载 //子类一旦实现赋值重载，不会自动调用父类赋值重载 son\u0026 operator=(son\u0026 another) { //赋值兼容 father::operator=(another);//重载是会被子类继承的，所以可以调用。与构造器不同 this-\u003edata=another.data; } 重名问题 子类中会把父类中重名的成员shadow掉，只需要名字相同即可 尽量不要重名，否则，调用时加上命名空间 overload 重载 发生在同一作用域，函数名相同，参数列表不同（个数，类型，顺序） shadow 发生在父子类当中，只要函数名相同即可 派生类的友元函数 父类的友元函数，子类也可以调用 传参时子类赋值给了父类，赋值兼容 派生类的析构器 析构顺序：子类，成员，基类 与构造相反 多继承 你有n个爹（逃） 三角问题，多个父类中相同的成员，用到要加父类作用域 给调用者带来很大的不便 办法，提取相同成员到一个公共类M中，然后让被提取的类，分别继承这个公共类M（三角变成了四角） 但是子类还是无法访问这个成员，因为两个基类都继承了M，这个成员还是有两份 最终办法 虚继承 虚继承 virtual(加在继承方式前面) cpp //上面的 M 就叫做 虚基类 //虚继承的意义：在多继承中，保存各个父类的多份同名成员，虽然有时是必要的，可以在不同数据成员中存放不同数据，但在大多数情况下 //是我们不希望出现的，因为保留多份数据成员的拷贝，不仅占用较多的存储空间，还增加了访问困难 //虚基类和虚继承，实现了在多继承中只保留一份共同（同名）成员。 //虚基类，需要抽象和设计，虚继承，是一种继承的扩展 //初始化问题，多继承的类中一定要调用虚基类的构造器，父类可以用默认 class A{ A(int i){} }; class B:virtual public A{ B(int n):A(n){} }; class C:virtual public A{ C(int n):A(n){} }; class D:public B,public C{ D(int n):A(n),B(n),C(n){}//结果有A()控制，其他配角 }; ","date":"2017-12-23","objectID":"/cpp-note/:22:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#61-继承与派生inheritderive"},{"categories":["program"],"content":" 7.1 多态PolyMorphism男人不止一面（逃），几个相似但不完全相同的对象，收到同一个消息后，执行不同的操作 c++中所谓的多态是指，由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应 增加程序的灵活性，可以减轻系统升级，维护，调试的工作量和复杂度 赋值兼容（多态实现的前提） 赋值兼容规则 是指在需要基类对象的任何地方都可以使用 公有派生类(其他不行) 的对象来替代，赋值兼容是一种默认行为，不需要任何的显式步骤 派生类的对象可以赋值给基类对象 派生类的对象可以初始化基类的引用 派生类的对象的地址可以赋给指向基类的指针 只能使用基类原有的成员 多态形成的条件 静多态: 函数重载，也是一种多态现象，通过命名倾轧在编译阶段决定，故称静多态 动多态: 在运行阶段决定 条件是 父类中有虚函数 子类override(覆写)父类中的虚函数 用已被子类对象赋值的父类指针或引用（对象不行），调用共用接口（发生虚函数调用） 虚函数 cpp class A { public: virtual void func();//只需在声明时加； }; //父类时有虚函数时，子类覆写override虚函数时（同名同参同返回），可以不加virtual，但建议加上 //将子类对象赋值给父类引用或指针时，用这个父类指针或引用访问的虚函数为子类的虚函数（如果有的话） //子类中虚函数的访问权限可以不和父类一致 //覆写范围是很大的，如果不覆写默认从父类继承 纯虚函数 cpp class A { virtual void func()=0;//格式，没有实现体 }; //含有纯虚函数的类，称为抽象基类（java中叫interface），不可以实例化（A a; 不可以） //作用就是给族类提供接口用的,抽象基类不能实例化，但可以用指针和引用指向一个子类，实现多态 //抽象基类存在的意义就是被继承 //如果派生类中没有对该函数override，则这个函数在派生类中仍为纯虚函数，派生类仍为纯虚基类 含有虚函数的析构: 虚析构，就是为了delete基类指针时将子类对象析构完全 含有虚函数的类，析构函数也应该声明为虚函数 在delete父类指针的时候，会调用子类的析构函数，实现完整析构 当一个类中有虚函数的时候，请将析构器声明为vritual 若干限制 静态成员函数不能是虚函数，静态成员函数不受对象的捆绑，只有类的信息 内联函数，普通函数，不能是虚函数 构造函数不能是虚函数 析构函数通常声明为虚函数 设计模式 – 依赖倒置原则 //定义，高层模块不应该依赖底层模块，二者都应该依赖抽象 //抽象不应该依赖细节，细节应该依赖抽象 //核心：面向接口编程 ","date":"2017-12-23","objectID":"/cpp-note/:23:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#71-多态polymorphism"},{"categories":["program"],"content":" 8.1 多态的实现原理 虚函数表 virtual table 类实例化时，内存最前面先放一个指向v-table的指针，然后是数据成员 v-table中，先放父类虚函数，再放子类虚函数 如果子类override了父类虚函数，则替换虚函数表相应位置的函数指针 多态实现的前题，一定是生成完了v-table之后，所以在父类构造器调用虚函数实现不了多态 ","date":"2017-12-23","objectID":"/cpp-note/:24:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#81-多态的实现原理"},{"categories":["program"],"content":" 8.2 运行时类型信息RTTIrun time type identificaition。运行时信息，来自于多态，所以一下运算符只用于基于多态的继承体系中 typeid运算符 cpp //使用这个运算符 要包含头文件\u003ctypeinfo\u003e //返回包含数据信息的type_info对象引用 //type_info重载了==,!=来比较是否相等，函数name()返回类型名称 //type_info的拷贝赋值为私有，不可操作，只用来做调试 B b; cout\u003c\u003ctypeid(b).name()\u003c\u003cendl;//输出b信息 A * a=\u0026b; cout\u003c\u003ctypeid(*a).name()\u003c\u003cendl;//输出b信息 //可以帮你辨别一个指针到底指向谁，在多态中 ","date":"2017-12-23","objectID":"/cpp-note/:25:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#82-运行时类型信息rtti"},{"categories":["program"],"content":" 8.3 typecast static_cast\u003c\u003e() 在一个方向上可以做隐式转换，在另一个方向方向可以做静态转换 发生在编译阶段，不保证后续使用的正确性 用于父子类不安全 reinterpret_cast\u003c\u003e() 既不在编译期也不再运行期进行检查，安全性完全由程序员决定 dynamic_cast\u003c\u003e() 运行时的类型转换方法，检查指针所指类型，然后判断是否与要转换的类型有一种“is a”的关系 如果是，返回对象地址，不是返回null 只用于含有虚函数的父子类中 ","date":"2017-12-23","objectID":"/cpp-note/:26:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#83-typecast"},{"categories":["program"],"content":" 9 c++模板 template cpp //泛型（Generic Programming）：多种数据类型上皆可操作的含义 //语法格式 template\u003ctypename/class 类型参数表\u003e 返回类型 函数模板名(函数参数表) { 函数模板实现体 } template\u003ctypename T,typename T2....\u003e void swapp(T a,T b) { a^=b;b^=a;a^=b; } template\u003ctypename T\u003e class stackk{ stackk(); }; template\u003ctypename T\u003e stackk::stackk\u003cT\u003e() {} //定义实现分开时，都要顶着帽子，（写类时，函数在外部实现也要戴帽子，并且函数名后加\u003cT\u003e） //模板适用于参数个数相同，函数体相同的情况 //参数个数如果不同，不要使用模板 ","date":"2017-12-23","objectID":"/cpp-note/:27:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#9-c模板-template"},{"categories":["program"],"content":" 10 C++ 流类综述流类对象都重载了 \u003c\u003c 和 \u003e\u003e 输入输出IO流 IO对象的构造器和赋值重载是private，不能拷贝或赋值，使用时只能传引用或指针 IO对象是由缓冲区的，缓冲区写满或遇到endl才写入,(cin背后是键盘，cout背后是屏幕) endl,flush,unitbuf 都可以刷缓冲 标准输出 cout cerr clog cpp //cout.unsetf(ios::dec); //cout.setf(ios::hex); //\u003ciomanip\u003e 流算子头文件,上面并不好用 //cout\u003c\u003ched\u003c\u003ca\u003c\u003cendl; 标准输入 cin cpp //istream 成员函数 cin.get();//读一个字符返回，包括空格回车tab空字符 cin.get(buf,1024,'\\n'); cin.getline(buf,1024,'默认回车'); istream\u0026 ignore(streamsize n=1,int delim=EOF);//跳过n个或遇到delim为止，delim也被跳过 int peek();//窥视 当前指针不改动，返回内容（int 型），自己转char istream\u0026 putback(char c);//回推指针，并在此位置替换为c 文件IO流 cpp ifstream ifile(\"1.txt\");//只能从文件读入 默认模式 ios::in if(!ifile)cout\u003c\u003c\"打开失败\"; ofstream ofile(\"2.txt\");//只能写到文件 默认模式 ios::out|ios::trunc //没有这个文件自动创建 fstream iofile(\"3.txt\");//默认模式 ios::in|ios::out|ios::app iofile.close();//刷缓冲区 ios::in ios::out //不会自动创建文件 ios::trunc //覆盖原来 会自动创建文件 ios::app //追加 会自动创建文件 ios::binary //二进制方式 ios::cur //文件当前位置 ios::end //文件末尾 f.seekg(50,ios::cur);//seekget 从当前位置向后50 f.seekp(-50,ios::end);//seekput 从文件尾向前50 //标识 f.eof();//达到文件尾，返回true f.bad();//读写过程出错，返回true f.fail();//除了和bad()一样，格式错误（例如想要读整数，得到字母），遇到eof都返回true f.good();//上面任何返回true，则返回false f.clear();//将所有标记位置位正常，不是清空流 cin.sync();//清空流 //遍历读，一个个读 char c; while(f.get(c),!f.eof()){ f2.put(c);//写入另一个文件 } //一行一行读 char buf[1024]; while(f.getline(buf,1024,'\\n'),!f.eof()){ f2\u003c\u003cbuf\u003c\u003cendl;//用get不会跳过\\n,用getline \\n被跳过，还要补； } //byte流读 ostream \u0026 write(const char * buffer,int len); istream \u0026 read(const char * buffer,int len); struct stu{ char name[100]; char sex; int age; }; stu s[5]= { {\"as\",'y',12}, {\"gg\",'x',1}, {\"rr\",'y',3}, {\"ww\",'x',100}, {\"qq\",'x',107} }; fstream f(\"asd.binary\",ios::in|ios::out|ios::trunc|ios::binary); //f.write(s,sizeof(s)); for(int i=0;i\u003c5;i++) { f.write((char *)\u0026s[i],sizeof(stu)); } f.seekg(0,ios::beg); stu tmp; while(f.read((char*)\u0026tmp,sizeof(stu)),!f.eof()){ cout\u003c\u003ctmp.name\u003c\u003cendl;; } ","date":"2017-12-23","objectID":"/cpp-note/:28:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#10-c-流类综述"},{"categories":["program"],"content":" 11 异常（EXCEPTION） cpp //在可能出错的地方使用try-catch结构 void func(int x){ if(x\u003c0) throw -1;//在try下面调用的函数中可以抛出异常，终止程序往下执行 //程序立即转到上面捕获异常的地方 //异常传递是一个拷贝，如果自定义类型，注意拷贝构造， } try{ func(3); }catch(int e)//如果下方扔出的异常不是int型，将接不到，程序调用另一个函数，终止整个程序 {//可以自己写异常信息类型，这样能得到更多信息 cout\u003c\u003c\"catch a exception \"\u003c\u003ce\u003c\u003cendl; }//catch执行完毕，继续执行后面的语句，如果没有匹配，系统调用terminate终止程序 //可以有多个catch catch(...){ //如果上面都没有接到，这个来接，有这个的时候，系统就不会调用terminate } //如果有多层try-catch结构，底层抛出一个异常，上层没有人接的话，继续传给上上层 //如果直到尽头都没有人接，系统才调用terminate //为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型 //例如： void func() throw(int ,A ,B ,double);//括号没内容表示不抛出异常 //栈自旋 throw抛出异常时，会在离开栈空间时销毁栈，不执行后面的代码，但看作函数执行完毕，退出销毁 //这也是为什么throw不传引用的原因 ===========================华丽的分割线=================================== 全剧终。。。 至此你看完了大部分c++ 没错，是看！！！ ","date":"2017-12-23","objectID":"/cpp-note/:29:0","series":null,"tags":["cpp"],"title":"CPP知识点笔记","uri":"/cpp-note/#11-异常exception"}]